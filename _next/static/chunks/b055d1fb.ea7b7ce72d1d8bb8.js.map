{"version":3,"file":"static/chunks/b055d1fb.ea7b7ce72d1d8bb8.js","mappings":"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","sources":["webpack://_N_E/./node_modules/three/build/three.webgpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2010-2025 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nimport { Color, Vector2, Vector3, Vector4, Matrix2, Matrix3, Matrix4, EventDispatcher, MathUtils, WebGLCoordinateSystem, WebGPUCoordinateSystem, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, BackSide, CubeReflectionMapping, CubeRefractionMapping, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, PointsMaterial, ShadowMaterial, arrayNeedsUint32, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, Camera, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, ArrayCamera, WebXRController, RAD2DEG, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, warnOnce, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';\nexport { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RenderTarget3D, RenderTargetArray, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TimestampQuery, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoFrameTexture, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';\n\nconst refreshUniforms = [\n\t'alphaMap',\n\t'alphaTest',\n\t'anisotropy',\n\t'anisotropyMap',\n\t'anisotropyRotation',\n\t'aoMap',\n\t'attenuationColor',\n\t'attenuationDistance',\n\t'bumpMap',\n\t'clearcoat',\n\t'clearcoatMap',\n\t'clearcoatNormalMap',\n\t'clearcoatNormalScale',\n\t'clearcoatRoughness',\n\t'color',\n\t'dispersion',\n\t'displacementMap',\n\t'emissive',\n\t'emissiveMap',\n\t'envMap',\n\t'gradientMap',\n\t'ior',\n\t'iridescence',\n\t'iridescenceIOR',\n\t'iridescenceMap',\n\t'iridescenceThicknessMap',\n\t'lightMap',\n\t'map',\n\t'matcap',\n\t'metalness',\n\t'metalnessMap',\n\t'normalMap',\n\t'normalScale',\n\t'opacity',\n\t'roughness',\n\t'roughnessMap',\n\t'sheen',\n\t'sheenColor',\n\t'sheenColorMap',\n\t'sheenRoughnessMap',\n\t'shininess',\n\t'specular',\n\t'specularColor',\n\t'specularColorMap',\n\t'specularIntensity',\n\t'specularIntensityMap',\n\t'specularMap',\n\t'thickness',\n\t'transmission',\n\t'transmissionMap'\n];\n\n/**\n * This class is used by {@link WebGPURenderer} as management component.\n * It's primary purpose is to determine whether render objects require a\n * refresh right before they are going to be rendered or not.\n */\nclass NodeMaterialObserver {\n\n\t/**\n\t * Constructs a new node material observer.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t */\n\tconstructor( builder ) {\n\n\t\t/**\n\t\t * A node material can be used by more than one render object so the\n\t\t * monitor must maintain a list of render objects.\n\t\t *\n\t\t * @type {WeakMap<RenderObject,Object>}\n\t\t */\n\t\tthis.renderObjects = new WeakMap();\n\n\t\t/**\n\t\t * Whether the material uses node objects or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.hasNode = this.containsNode( builder );\n\n\t\t/**\n\t\t * Whether the node builder's 3D object is animated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.hasAnimation = builder.object.isSkinnedMesh === true;\n\n\t\t/**\n\t\t * A list of all possible material uniforms\n\t\t *\n\t\t * @type {Array<String>}\n\t\t */\n\t\tthis.refreshUniforms = refreshUniforms;\n\n\t\t/**\n\t\t * Holds the current render ID from the node frame.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderId = 0;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object is verified for the first time of this observer.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the given render object is verified for the first time of this observer.\n\t */\n\tfirstInitialization( renderObject ) {\n\n\t\tconst hasInitialized = this.renderObjects.has( renderObject );\n\n\t\tif ( hasInitialized === false ) {\n\n\t\t\tthis.getRenderObjectData( renderObject );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns monitoring data for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Object} The monitoring data.\n\t */\n\tgetRenderObjectData( renderObject ) {\n\n\t\tlet data = this.renderObjects.get( renderObject );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconst { geometry, material, object } = renderObject;\n\n\t\t\tdata = {\n\t\t\t\tmaterial: this.getMaterialData( material ),\n\t\t\t\tgeometry: {\n\t\t\t\t\tid: geometry.id,\n\t\t\t\t\tattributes: this.getAttributesData( geometry.attributes ),\n\t\t\t\t\tindexVersion: geometry.index ? geometry.index.version : null,\n\t\t\t\t\tdrawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }\n\t\t\t\t},\n\t\t\t\tworldMatrix: object.matrixWorld.clone()\n\t\t\t};\n\n\t\t\tif ( object.center ) {\n\n\t\t\t\tdata.center = object.center.clone();\n\n\t\t\t}\n\n\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\tdata.morphTargetInfluences = object.morphTargetInfluences.slice();\n\n\t\t\t}\n\n\t\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\t\tdata.version = renderObject.bundle.version;\n\n\t\t\t}\n\n\t\t\tif ( data.material.transmission > 0 ) {\n\n\t\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\t\tdata.bufferWidth = width;\n\t\t\t\tdata.bufferHeight = height;\n\n\t\t\t}\n\n\t\t\tthis.renderObjects.set( renderObject, data );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns an attribute data structure holding the attributes versions for\n\t * monitoring.\n\t *\n\t * @param {Object} attributes - The geometry attributes.\n\t * @return {Object} An object for monitoring the versions of attributes.\n\t */\n\tgetAttributesData( attributes ) {\n\n\t\tconst attributesData = {};\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tattributesData[ name ] = {\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\n\t\t}\n\n\t\treturn attributesData;\n\n\t}\n\n\t/**\n\t * Returns `true` if the node builder's material uses\n\t * node properties.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether the node builder's material uses node properties or not.\n\t */\n\tcontainsNode( builder ) {\n\n\t\tconst material = builder.material;\n\n\t\tfor ( const property in material ) {\n\n\t\t\tif ( material[ property ] && material[ property ].isNode )\n\t\t\t\treturn true;\n\n\t\t}\n\n\t\tif ( builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null )\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns a material data structure holding the material property values for\n\t * monitoring.\n\t *\n\t * @param {Material} material - The material.\n\t * @return {Object} An object for monitoring material properties.\n\t */\n\tgetMaterialData( material ) {\n\n\t\tconst data = {};\n\n\t\tfor ( const property of this.refreshUniforms ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( value === null || value === undefined ) continue;\n\n\t\t\tif ( typeof value === 'object' && value.clone !== undefined ) {\n\n\t\t\t\tif ( value.isTexture === true ) {\n\n\t\t\t\t\tdata[ property ] = { id: value.id, version: value.version };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdata[ property ] = value.clone();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdata[ property ] = value;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object has not changed its state.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the given render object has changed its state or not.\n\t */\n\tequals( renderObject ) {\n\n\t\tconst { object, material, geometry } = renderObject;\n\n\t\tconst renderObjectData = this.getRenderObjectData( renderObject );\n\n\t\t// world matrix\n\n\t\tif ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {\n\n\t\t\trenderObjectData.worldMatrix.copy( object.matrixWorld );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// material\n\n\t\tconst materialData = renderObjectData.material;\n\n\t\tfor ( const property in materialData ) {\n\n\t\t\tconst value = materialData[ property ];\n\t\t\tconst mtlValue = material[ property ];\n\n\t\t\tif ( value.equals !== undefined ) {\n\n\t\t\t\tif ( value.equals( mtlValue ) === false ) {\n\n\t\t\t\t\tvalue.copy( mtlValue );\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( mtlValue.isTexture === true ) {\n\n\t\t\t\tif ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {\n\n\t\t\t\t\tvalue.id = mtlValue.id;\n\t\t\t\t\tvalue.version = mtlValue.version;\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( value !== mtlValue ) {\n\n\t\t\t\tmaterialData[ property ] = mtlValue;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialData.transmission > 0 ) {\n\n\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\tif ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {\n\n\t\t\t\trenderObjectData.bufferWidth = width;\n\t\t\t\trenderObjectData.bufferHeight = height;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// geometry\n\n\t\tconst storedGeometryData = renderObjectData.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst storedAttributes = storedGeometryData.attributes;\n\n\t\tconst storedAttributeNames = Object.keys( storedAttributes );\n\t\tconst currentAttributeNames = Object.keys( attributes );\n\n\t\tif ( storedGeometryData.id !== geometry.id ) {\n\n\t\t\tstoredGeometryData.id = geometry.id;\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( storedAttributeNames.length !== currentAttributeNames.length ) {\n\n\t\t\trenderObjectData.geometry.attributes = this.getAttributesData( attributes );\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compare each attribute\n\n\t\tfor ( const name of storedAttributeNames ) {\n\n\t\t\tconst storedAttributeData = storedAttributes[ name ];\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t// attribute was removed\n\t\t\t\tdelete storedAttributes[ name ];\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( storedAttributeData.version !== attribute.version ) {\n\n\t\t\t\tstoredAttributeData.version = attribute.version;\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check index\n\n\t\tconst index = geometry.index;\n\t\tconst storedIndexVersion = storedGeometryData.indexVersion;\n\t\tconst currentIndexVersion = index ? index.version : null;\n\n\t\tif ( storedIndexVersion !== currentIndexVersion ) {\n\n\t\t\tstoredGeometryData.indexVersion = currentIndexVersion;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check drawRange\n\n\t\tif ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {\n\n\t\t\tstoredGeometryData.drawRange.start = geometry.drawRange.start;\n\t\t\tstoredGeometryData.drawRange.count = geometry.drawRange.count;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tif ( renderObjectData.morphTargetInfluences ) {\n\n\t\t\tlet morphChanged = false;\n\n\t\t\tfor ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {\n\n\t\t\t\tif ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {\n\n\t\t\t\t\tmorphChanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( morphChanged ) return true;\n\n\t\t}\n\n\t\t// center\n\n\t\tif ( renderObjectData.center ) {\n\n\t\t\tif ( renderObjectData.center.equals( object.center ) === false ) {\n\n\t\t\t\trenderObjectData.center.copy( object.center );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// bundle\n\n\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\trenderObjectData.version = renderObject.bundle.version;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Checks if the given render object requires a refresh.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {NodeFrame} nodeFrame - The current node frame.\n\t * @return {Boolean} Whether the given render object requires a refresh or not.\n\t */\n\tneedsRefresh( renderObject, nodeFrame ) {\n\n\t\tif ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) )\n\t\t\treturn true;\n\n\t\tconst { renderId } = nodeFrame;\n\n\t\tif ( this.renderId !== renderId ) {\n\n\t\t\tthis.renderId = renderId;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst isStatic = renderObject.object.static === true;\n\t\tconst isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;\n\n\t\tif ( isStatic || isBundle )\n\t\t\treturn false;\n\n\t\tconst notEqual = this.equals( renderObject ) !== true;\n\n\t\treturn notEqual;\n\n\t}\n\n}\n\n/** @module NodeUtils **/\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53( value, seed = 0 ) {\n\n\tlet h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n\n\tif ( value instanceof Array ) {\n\n\t\tfor ( let i = 0, val; i < value.length; i ++ ) {\n\n\t\t\tval = value[ i ];\n\t\t\th1 = Math.imul( h1 ^ val, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ val, 1597334677 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, ch; i < value.length; i ++ ) {\n\n\t\t\tch = value.charCodeAt( i );\n\t\t\th1 = Math.imul( h1 ^ ch, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ ch, 1597334677 );\n\n\t\t}\n\n\t}\n\n\th1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );\n\th1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );\n\th2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );\n\th2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );\n\n\treturn 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );\n\n}\n\n/**\n * Computes a hash for the given string.\n *\n * @method\n * @param {String} str - The string to be hashed.\n * @return {Number} The hash.\n */\nconst hashString = ( str ) => cyrb53( str );\n\n/**\n * Computes a hash for the given array.\n *\n * @method\n * @param {Array<Number>} array - The array to be hashed.\n * @return {Number} The hash.\n */\nconst hashArray = ( array ) => cyrb53( array );\n\n/**\n * Computes a hash for the given list of parameters.\n *\n * @method\n * @param {...Number} params - A list of parameters.\n * @return {Number} The hash.\n */\nconst hash$1 = ( ...params ) => cyrb53( params );\n\n/**\n * Computes a cache key for the given node.\n *\n * @method\n * @param {Object} object - The object to be hashed.\n * @param {Boolean} [force=false] - Whether to force a cache key computation or not.\n * @return {Number} The hash.\n */\nfunction getCacheKey$1( object, force = false ) {\n\n\tconst values = [];\n\n\tif ( object.isNode === true ) {\n\n\t\tvalues.push( object.id );\n\t\tobject = object.getSelf();\n\n\t}\n\n\tfor ( const { property, childNode } of getNodeChildren( object ) ) {\n\n\t\tvalues.push( cyrb53( property.slice( 0, - 4 ) ), childNode.getCacheKey( force ) );\n\n\t}\n\n\treturn cyrb53( values );\n\n}\n\n/**\n * This generator function can be used to iterate over the node children\n * of the given object.\n *\n * @generator\n * @param {Object} node - The object to be hashed.\n * @param {Boolean} [toJSON=false] - Whether to return JSON or not.\n * @yields {Object} A result node holding the property, index (if available) and the child node.\n */\nfunction* getNodeChildren( node, toJSON = false ) {\n\n\tfor ( const property in node ) {\n\n\t\t// Ignore private properties.\n\t\tif ( property.startsWith( '_' ) === true ) continue;\n\n\t\tconst object = node[ property ];\n\n\t\tif ( Array.isArray( object ) === true ) {\n\n\t\t\tfor ( let i = 0; i < object.length; i ++ ) {\n\n\t\t\t\tconst child = object[ i ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: i, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object && object.isNode === true ) {\n\n\t\t\tyield { property, childNode: object };\n\n\t\t} else if ( typeof object === 'object' ) {\n\n\t\t\tfor ( const subProperty in object ) {\n\n\t\t\t\tconst child = object[ subProperty ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: subProperty, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst typeFromLength = /*@__PURE__*/ new Map( [\n\t[ 1, 'float' ],\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst dataFromObject = /*@__PURE__*/ new WeakMap();\n\n/**\n * Returns the data type for the given the length.\n *\n * @method\n * @param {Number} length - The length.\n * @return {String} The data type.\n */\nfunction getTypeFromLength( length ) {\n\n\treturn typeFromLength.get( length );\n\n}\n\n/**\n * Returns the typed array for the given data type.\n *\n * @method\n * @param {String} type - The data type.\n * @return {TypedArray} The typed array.\n */\nfunction getTypedArrayFromType( type ) {\n\n\t// Handle component type for vectors and matrices\n\tif ( /[iu]?vec\\d/.test( type ) ) {\n\n\t\t// Handle int vectors\n\t\tif ( type.startsWith( 'ivec' ) ) return Int32Array;\n\t\t// Handle uint vectors\n\t\tif ( type.startsWith( 'uvec' ) ) return Uint32Array;\n\t\t// Default to float vectors\n\t\treturn Float32Array;\n\n\t}\n\n\t// Handle matrices (always float)\n\tif ( /mat\\d/.test( type ) ) return Float32Array;\n\n\t// Basic types\n\tif ( /float/.test( type ) ) return Float32Array;\n\tif ( /uint/.test( type ) ) return Uint32Array;\n\tif ( /int/.test( type ) ) return Int32Array;\n\n\tthrow new Error( `THREE.NodeUtils: Unsupported type: ${type}` );\n\n}\n\n/**\n * Returns the length for the given data type.\n *\n * @method\n * @param {String} type - The data type.\n * @return {Number} The length.\n */\nfunction getLengthFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 1;\n\tif ( /vec2/.test( type ) ) return 2;\n\tif ( /vec3/.test( type ) ) return 3;\n\tif ( /vec4/.test( type ) ) return 4;\n\tif ( /mat2/.test( type ) ) return 4;\n\tif ( /mat3/.test( type ) ) return 9;\n\tif ( /mat4/.test( type ) ) return 16;\n\n\tconsole.error( 'THREE.TSL: Unsupported type:', type );\n\n}\n\n/**\n * Returns the data type for the given value.\n *\n * @method\n * @param {Any} value - The value.\n * @return {String?} The data type.\n */\nfunction getValueType( value ) {\n\n\tif ( value === undefined || value === null ) return null;\n\n\tconst typeOf = typeof value;\n\n\tif ( value.isNode === true ) {\n\n\t\treturn 'node';\n\n\t} else if ( typeOf === 'number' ) {\n\n\t\treturn 'float';\n\n\t} else if ( typeOf === 'boolean' ) {\n\n\t\treturn 'bool';\n\n\t} else if ( typeOf === 'string' ) {\n\n\t\treturn 'string';\n\n\t} else if ( typeOf === 'function' ) {\n\n\t\treturn 'shader';\n\n\t} else if ( value.isVector2 === true ) {\n\n\t\treturn 'vec2';\n\n\t} else if ( value.isVector3 === true ) {\n\n\t\treturn 'vec3';\n\n\t} else if ( value.isVector4 === true ) {\n\n\t\treturn 'vec4';\n\n\t} else if ( value.isMatrix2 === true ) {\n\n\t\treturn 'mat2';\n\n\t} else if ( value.isMatrix3 === true ) {\n\n\t\treturn 'mat3';\n\n\t} else if ( value.isMatrix4 === true ) {\n\n\t\treturn 'mat4';\n\n\t} else if ( value.isColor === true ) {\n\n\t\treturn 'color';\n\n\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\treturn 'ArrayBuffer';\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * Returns the value/object for the given data type and parameters.\n *\n * @method\n * @param {String} type - The given type.\n * @param {...Any} params - A parameter list.\n * @return {Any} The value/object.\n */\nfunction getValueFromType( type, ...params ) {\n\n\tconst last4 = type ? type.slice( - 4 ) : undefined;\n\n\tif ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()\n\n\t\tif ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];\n\n\t}\n\n\tif ( type === 'color' ) {\n\n\t\treturn new Color( ...params );\n\n\t} else if ( last4 === 'vec2' ) {\n\n\t\treturn new Vector2( ...params );\n\n\t} else if ( last4 === 'vec3' ) {\n\n\t\treturn new Vector3( ...params );\n\n\t} else if ( last4 === 'vec4' ) {\n\n\t\treturn new Vector4( ...params );\n\n\t} else if ( last4 === 'mat2' ) {\n\n\t\treturn new Matrix2( ...params );\n\n\t} else if ( last4 === 'mat3' ) {\n\n\t\treturn new Matrix3( ...params );\n\n\t} else if ( last4 === 'mat4' ) {\n\n\t\treturn new Matrix4( ...params );\n\n\t} else if ( type === 'bool' ) {\n\n\t\treturn params[ 0 ] || false;\n\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\n\n\t\treturn params[ 0 ] || 0;\n\n\t} else if ( type === 'string' ) {\n\n\t\treturn params[ 0 ] || '';\n\n\t} else if ( type === 'ArrayBuffer' ) {\n\n\t\treturn base64ToArrayBuffer( params[ 0 ] );\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * Gets the object data that can be shared between different rendering steps.\n *\n * @param {Object} object - The object to get the data for.\n * @return {Object} The object data.\n */\nfunction getDataFromObject( object ) {\n\n\tlet data = dataFromObject.get( object );\n\n\tif ( data === undefined ) {\n\n\t\tdata = {};\n\t\tdataFromObject.set( object, data );\n\n\t}\n\n\treturn data;\n\n}\n\n/**\n * Converts the given array buffer to a Base64 string.\n *\n * @method\n * @param {ArrayBuffer} arrayBuffer - The array buffer.\n * @return {String} The Base64 string.\n */\nfunction arrayBufferToBase64( arrayBuffer ) {\n\n\tlet chars = '';\n\n\tconst array = new Uint8Array( arrayBuffer );\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\tchars += String.fromCharCode( array[ i ] );\n\n\t}\n\n\treturn btoa( chars );\n\n}\n\n/**\n * Converts the given Base64 string to an array buffer.\n *\n * @method\n * @param {String} base64 - The Base64 string.\n * @return {ArrayBuffer} The array buffer.\n */\nfunction base64ToArrayBuffer( base64 ) {\n\n\treturn Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;\n\n}\n\nvar NodeUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tarrayBufferToBase64: arrayBufferToBase64,\n\tbase64ToArrayBuffer: base64ToArrayBuffer,\n\tgetCacheKey: getCacheKey$1,\n\tgetDataFromObject: getDataFromObject,\n\tgetLengthFromType: getLengthFromType,\n\tgetNodeChildren: getNodeChildren,\n\tgetTypeFromLength: getTypeFromLength,\n\tgetTypedArrayFromType: getTypedArrayFromType,\n\tgetValueFromType: getValueFromType,\n\tgetValueType: getValueType,\n\thash: hash$1,\n\thashArray: hashArray,\n\thashString: hashString\n});\n\n/** @module NodeConstants **/\n\n/**\n * Possible shader stages.\n *\n * @property {string} VERTEX The vertex shader stage.\n * @property {string} FRAGMENT The fragment shader stage.\n */\nconst NodeShaderStage = {\n\tVERTEX: 'vertex',\n\tFRAGMENT: 'fragment'\n};\n\n/**\n * Update types of a node.\n *\n * @property {string} NONE The update method is not executed.\n * @property {string} FRAME The update method is executed per frame.\n * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.\n * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.\n */\nconst NodeUpdateType = {\n\tNONE: 'none',\n\tFRAME: 'frame',\n\tRENDER: 'render',\n\tOBJECT: 'object'\n};\n\n/**\n * Data types of a node.\n *\n * @property {string} BOOLEAN Boolean type.\n * @property {string} INTEGER Integer type.\n * @property {string} FLOAT Float type.\n * @property {string} VECTOR2 Two-dimensional vector type.\n * @property {string} VECTOR3 Three-dimensional vector type.\n * @property {string} VECTOR4 Four-dimensional vector type.\n * @property {string} MATRIX2 2x2 matrix type.\n * @property {string} MATRIX3 3x3 matrix type.\n * @property {string} MATRIX4 4x4 matrix type.\n */\nconst NodeType = {\n\tBOOLEAN: 'bool',\n\tINTEGER: 'int',\n\tFLOAT: 'float',\n\tVECTOR2: 'vec2',\n\tVECTOR3: 'vec3',\n\tVECTOR4: 'vec4',\n\tMATRIX2: 'mat2',\n\tMATRIX3: 'mat3',\n\tMATRIX4: 'mat4'\n};\n\n/**\n * Access types of a node. These are relevant for compute and storage usage.\n *\n * @property {string} READ_ONLY Read-only access\n * @property {string} WRITE_ONLY Write-only access.\n * @property {string} READ_WRITE Read and write access.\n */\nconst NodeAccess = {\n\tREAD_ONLY: 'readOnly',\n\tWRITE_ONLY: 'writeOnly',\n\tREAD_WRITE: 'readWrite',\n};\n\nconst defaultShaderStages = [ 'fragment', 'vertex' ];\nconst defaultBuildStages = [ 'setup', 'analyze', 'generate' ];\nconst shaderStages = [ ...defaultShaderStages, 'compute' ];\nconst vectorComponents = [ 'x', 'y', 'z', 'w' ];\n\nlet _nodeId = 0;\n\n/**\n * Base class for all nodes.\n *\n * @augments EventDispatcher\n */\nclass Node extends EventDispatcher {\n\n\tstatic get type() {\n\n\t\treturn 'Node';\n\n\t}\n\n\t/**\n\t * Constructs a new node.\n\t *\n\t * @param {String?} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node type. This represents the result type of the node (e.g. `float` or `vec3`).\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.nodeType = nodeType;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The UUID of the node.\n\t\t *\n\t\t * @type {String}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t/**\n\t\t * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * Whether this node is global or not. This property is relevant for the internal\n\t\t * node caching system. All nodes which should be declared just once should\n\t\t * set this flag to `true` (a typical example is {@link AttributeNode}).\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.global = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNode = true;\n\n\t\t// private\n\n\t\t/**\n\t\t * The cache key of this node.\n\t\t *\n\t\t * @private\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis._cacheKey = null;\n\n\t\t/**\n\t\t * The cache key 's version.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._cacheKeyVersion = 0;\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\t/**\n\t * Set this property to `true` when the node should be regenerated.\n\t *\n\t * @type {Boolean}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The type of the class. The value is usually the constructor name.\n\t *\n\t * @type {String}\n \t * @readonly\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @param {String} updateType - The update type.\n\t * @return {Node} A reference to this node.\n\t */\n\tonUpdate( callback, updateType ) {\n\n\t\tthis.updateType = updateType;\n\t\tthis.update = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `FRAME`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonFrameUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.FRAME );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `RENDER`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonRenderUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.RENDER );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `OBJECT`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonObjectUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.OBJECT );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#updateReference}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonReference( callback ) {\n\n\t\tthis.updateReference = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The `this` reference might point to a Proxy so this method can be used\n\t * to get the reference to the actual node instance.\n\t *\n\t * @return {Node} A reference to the node.\n\t */\n\tgetSelf() {\n\n\t\t// Returns non-node object.\n\n\t\treturn this.self || this;\n\n\t}\n\n\t/**\n\t * Nodes might refer to other objects like materials. This method allows to dynamically update the reference\n\t * to such objects based on a given state (e.g. the current node frame or builder).\n\t *\n\t * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {Any} The updated reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * By default this method returns the value of the {@link Node#global} flag. This method\n\t * can be overwritten in derived classes if an analytical way is required to determine the\n\t * global status.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn this.global;\n\n\t}\n\n\t/**\n\t * Generator function that can be used to iterate over the child nodes.\n\t *\n\t * @generator\n\t * @yields {Node} A child node.\n\t */\n\t* getChildren() {\n\n\t\tfor ( const { childNode } of getNodeChildren( this ) ) {\n\n\t\t\tyield childNode;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calling this method dispatches the `dispose` event. This event can be used\n\t * to register event listeners for clean up tasks.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Callback for {@link Node#traverse}.\n\t *\n\t * @callback traverseCallback\n\t * @param {Node} node - The current node.\n\t */\n\n\t/**\n\t * Can be used to traverse through the node's hierarchy.\n\t *\n\t * @param {traverseCallback} callback - A callback that is executed per node.\n\t */\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tchildNode.traverse( callback );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the cache key for this node.\n\t *\n\t * @param {Boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.\n\t * @return {Number} The cache key of the node.\n\t */\n\tgetCacheKey( force = false ) {\n\n\t\tforce = force || this.version !== this._cacheKeyVersion;\n\n\t\tif ( force === true || this._cacheKey === null ) {\n\n\t\t\tthis._cacheKey = hash$1( getCacheKey$1( this, force ), this.customCacheKey() );\n\t\t\tthis._cacheKeyVersion = this.version;\n\n\t\t}\n\n\t\treturn this._cacheKey;\n\n\t}\n\n\t/**\n\t * Generate a custom cache key for this node.\n\t *\n\t * @return {Number} The cache key of the node.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Returns the references to this node which is by default `this`.\n\t *\n\t * @return {Node} A reference to this node.\n\t */\n\tgetScope() {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the hash of the node which is used to identify the node. By default it's\n\t * the {@link Node#uuid} however derived node classes might have to overwrite this method\n\t * depending on their implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The hash.\n\t */\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#update}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\treturn this.updateType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateBefore}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateBeforeType() {\n\n\t\treturn this.updateBeforeType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateAfter}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateAfterType() {\n\n\t\treturn this.updateAfterType;\n\n\t}\n\n\t/**\n\t * Certain types are composed of multiple elements. For example a `vec3`\n\t * is composed of three `float` values. This method returns the type of\n\t * these elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The type of the node.\n\t */\n\tgetElementType( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst elementType = builder.getElementType( type );\n\n\t\treturn elementType;\n\n\t}\n\n\t/**\n\t * Returns the node member type for the given name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} name - The name of the member.\n\t * @return {String} The type of the node.\n\t */\n\tgetMemberType( /*uilder, name*/ ) {\n\n\t\treturn 'void';\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The type of the node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tif ( nodeProperties.outputNode ) {\n\n\t\t\treturn nodeProperties.outputNode.getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * This method is used during the build process of a node and ensures\n\t * equal nodes are not built multiple times but just once. For example if\n\t * `attribute( 'uv' )` is used multiple times by the user, the build\n\t * process makes sure to process just the first node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The shared node if possible. Otherwise `this` is returned.\n\t */\n\tgetShared( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\n\n\t\treturn nodeFromHash || this;\n\n\t}\n\n\t/**\n\t * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.\n\t * This method is often overwritten in derived modules to prepare the node which is used as the output/result.\n\t * The output node must be returned in the `return` statement.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node?} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists or null\n\n\t\treturn nodeProperties.outputNode || null;\n\n\t}\n\n\t/**\n\t * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.\n\t * This stage analyzes the node hierarchy and ensures descendent nodes are built.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tanalyze( builder ) {\n\n\t\tconst usageCount = builder.increaseUsage( this );\n\n\t\tif ( usageCount === 1 ) {\n\n\t\t\t// node flow children\n\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\n\n\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.\n\t * This state builds the output node and returns the resulting shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String?} output - Can be used to define the output type.\n\t * @return {String?} The generated shader string.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode && outputNode.isNode === true ) {\n\n\t\t\treturn outputNode.build( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state before it is used to render an object.\n\t * The {@link Node#updateBeforeType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateBefore( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state after it was used to render an object.\n\t * The {@link Node#updateAfterType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateAfter( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state when it is used to render an object.\n\t * The {@link Node#updateType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * This method performs the build of a node. The behavior of this method as well as its return value depend\n\t * on the current build stage (setup, analyze or generate).\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String?} output - Can be used to define the output type.\n\t * @return {String?} When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.\n\t */\n\tbuild( builder, output = null ) {\n\n\t\tconst refNode = this.getShared( builder );\n\n\t\tif ( this !== refNode ) {\n\n\t\t\treturn refNode.build( builder, output );\n\n\t\t}\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addChain( this );\n\n\t\t/* Build stages expected results:\n\t\t\t- \"setup\"\t\t-> Node\n\t\t\t- \"analyze\"\t\t-> null\n\t\t\t- \"generate\"\t-> String\n\t\t*/\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tthis.updateReference( builder );\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.initialized !== true ) {\n\n\t\t\t\t//const stackNodesBeforeSetup = builder.stack.nodes.length;\n\n\t\t\t\tproperties.initialized = true;\n\n\t\t\t\tconst outputNode = this.setup( builder ); // return a node or null\n\t\t\t\tconst isNodeOutput = outputNode && outputNode.isNode === true;\n\n\t\t\t\t/*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {\n\n\t\t\t\t\t// !! no outputNode !!\n\t\t\t\t\t//outputNode = builder.stack;\n\n\t\t\t\t}*/\n\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\n\n\t\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( isNodeOutput ) {\n\n\t\t\t\t\toutputNode.build( builder );\n\n\t\t\t\t}\n\n\t\t\t\tproperties.outputNode = outputNode;\n\n\t\t\t}\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\tthis.analyze( builder );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\t\tif ( isGenerateOnce ) {\n\n\t\t\t\tconst type = this.getNodeType( builder );\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\t\tresult = nodeData.snippet;\n\n\t\t\t\tif ( result === undefined ) {\n\n\t\t\t\t\tresult = this.generate( builder ) || '';\n\n\t\t\t\t\tnodeData.snippet = result;\n\n\t\t\t\t} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {\n\n\t\t\t\t\tbuilder.addFlowCodeHierarchy( this, builder.context.nodeBlock );\n\n\t\t\t\t}\n\n\t\t\t\tresult = builder.format( result, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tresult = this.generate( builder, output ) || '';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeChain( this );\n\t\tbuilder.addSequentialNode( this );\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the child nodes as a JSON object.\n\t *\n\t * @return {Array<Object>} An iterable list of serialized child objects as JSON.\n\t */\n\tgetSerializeChildren() {\n\n\t\treturn getNodeChildren( this );\n\n\t}\n\n\t/**\n\t * Serializes the node to JSON.\n\t *\n\t * @param {Object} json - The output JSON object.\n\t */\n\tserialize( json ) {\n\n\t\tconst nodeChildren = this.getSerializeChildren();\n\n\t\tconst inputNodes = {};\n\n\t\tfor ( const { property, index, childNode } of nodeChildren ) {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tif ( inputNodes[ property ] === undefined ) {\n\n\t\t\t\t\tinputNodes[ property ] = Number.isInteger( index ) ? [] : {};\n\n\t\t\t\t}\n\n\t\t\t\tinputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t} else {\n\n\t\t\t\tinputNodes[ property ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( inputNodes ).length > 0 ) {\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Deserializes the node from the given JSON.\n\t *\n\t * @param {Object} json - The JSON object.\n\t */\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tif ( Array.isArray( json.inputNodes[ property ] ) ) {\n\n\t\t\t\t\tconst inputArray = [];\n\n\t\t\t\t\tfor ( const uuid of json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tinputArray.push( nodes[ uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputArray;\n\n\t\t\t\t} else if ( typeof json.inputNodes[ property ] === 'object' ) {\n\n\t\t\t\t\tconst inputObject = {};\n\n\t\t\t\t\tfor ( const subProperty in json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tconst uuid = json.inputNodes[ property ][ subProperty ];\n\n\t\t\t\t\t\tinputObject[ subProperty ] = nodes[ uuid ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputObject;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes the node into the three.js JSON Object/Scene format.\n\t *\n\t * @param {Object?} meta - An optional JSON object that already holds serialized data from other scene objects.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.6,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif ( isRoot !== true ) meta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Base class for representing element access on an array-like\n * node data structures.\n *\n * @augments Node\n */\nclass ArrayElementNode extends Node { // @TODO: If extending from TempNode it breaks webgpu_compute\n\n\tstatic get type() {\n\n\t\treturn 'ArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs an array element node.\n\t *\n\t * @param {Node} node - The array-like node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The array-like node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The index node that defines the element access.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.indexNode = indexNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the array-like node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, 'uint' );\n\n\t\treturn `${ nodeSnippet }[ ${ indexSnippet } ]`;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a convert operation during the shader generation process\n * meaning it converts the data type of a node to a target data type.\n *\n * @augments Node\n */\nclass ConvertNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConvertNode';\n\n\t}\n\n\t/**\n\t * Constructs a new convert node.\n\t *\n\t * @param {Node} node - The node which type should be converted.\n\t * @param {String} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.\n\t */\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which type should be converted.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The target node type. Multiple types can be defined by separating them with a `|` sign.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the implementation tries to infer the best\n\t * matching type from the {@link ConvertNode#convertTo} property.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst requestType = this.node.getNodeType( builder );\n\n\t\tlet convertTo = null;\n\n\t\tfor ( const overloadingType of this.convertTo.split( '|' ) ) {\n\n\t\t\tif ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {\n\n\t\t\t\tconvertTo = overloadingType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn convertTo;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.convertTo = this.convertTo;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.convertTo = data.convertTo;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst snippet = node.build( builder, type );\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\n/**\n * This module uses cache management to create temporary variables\n * if the node is used more than once to prevent duplicate calculations.\n *\n * The class acts as a base class for many other nodes types.\n *\n * @augments Node\n */\nclass TempNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TempNode';\n\n\t}\n\n\t/**\n\t * Constructs a temp node.\n\t *\n\t * @param {String?} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTempNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes.\n\t */\n\thasDependencies( builder ) {\n\n\t\treturn builder.getDataFromNode( this ).usageCount > 1;\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'generate' ) {\n\n\t\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tif ( nodeData.propertyName !== undefined ) {\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {\n\n\t\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, type );\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tbuilder.addLineFlowCode( `${ propertyName } = ${ snippet }`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a join operation during the shader generation process.\n * For example in can compose/join two single floats into a `vec2` type.\n *\n * @augments TempNode\n */\nclass JoinNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'JoinNode';\n\n\t}\n\n\t/**\n\t * Constructs a new join node.\n\t *\n\t * @param {Array<Node>} nodes - An array of nodes that should be joined.\n\t * @param {String?} [nodeType=null] - The node type.\n\t */\n\tconstructor( nodes = [], nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * An array of nodes that should be joined.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type must be inferred from the\n\t * joined data length if not explicitly defined.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) {\n\n\t\t\treturn builder.getVectorType( this.nodeType );\n\n\t\t}\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst nodes = this.nodes;\n\n\t\tconst primitiveType = builder.getComponentType( type );\n\n\t\tconst snippetValues = [];\n\n\t\tfor ( const input of nodes ) {\n\n\t\t\tlet inputSnippet = input.build( builder );\n\n\t\t\tconst inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );\n\n\t\t\tif ( inputPrimitiveType !== primitiveType ) {\n\n\t\t\t\tinputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );\n\n\t\t\t}\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\tconst snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nconst _stringVectorComponents = vectorComponents.join( '' );\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SplitNode` represents a property access operation which means it is\n * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.\n * For example:\n * ```js\n * const redValue = color.r;\n * ```\n *\n * @augments Node\n */\nclass SplitNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SplitNode';\n\n\t}\n\n\t/**\n\t * Constructs a new split node.\n\t *\n\t * @param {Node} node - The node that should be accessed.\n\t * @param {String} [components='x'] - The components that should be accessed.\n\t */\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be accessed.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The components that should be accessed.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSplitNode = true;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the requested components.\n\t *\n\t * @return {Number} The vector length.\n\t */\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\t/**\n\t * Returns the component type of the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The component type.\n\t */\n\tgetComponentType( builder ) {\n\n\t\treturn builder.getComponentType( this.node.getNodeType( builder ) );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from requested components.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tlet snippet = null;\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// needed expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice( 0, this.components.length ) ) {\n\n\t\t\t\t// unnecessary swizzle\n\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// ignore .components if .node returns float/integer\n\n\t\t\tsnippet = node.build( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SetNode` represents a set operation which means it is used to implement any\n * `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.\n * For example:\n * ```js\n * materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );\n * ```\n *\n * @augments TempNode\n */\nclass SetNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SetNode';\n\n\t}\n\n\t/**\n\t * Constructs a new set node.\n\t *\n\t * @param {Node} sourceNode - The node that should be updated.\n\t * @param {String} components - The components that should be updated.\n\t * @param {Node} targetNode - The value node.\n\t */\n\tconstructor( sourceNode, components, targetNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be updated.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be updated.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * The value node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { sourceNode, components, targetNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\n\t\tconst componentType = builder.getComponentType( targetNode.getNodeType( builder ) );\n\t\tconst targetType = builder.getTypeFromLength( components.length, componentType );\n\n\t\tconst targetSnippet = targetNode.build( builder, targetType );\n\t\tconst sourceSnippet = sourceNode.build( builder, sourceType );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ 0 ] ) {\n\n\t\t\t\tsnippetValues.push( targetSnippet );\n\n\t\t\t\ti += components.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceSnippet + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a flip operation during the shader generation process\n * meaning it flips normalized values with the following formula:\n * ```\n * x = 1 - x;\n * ```\n * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and\n * `flipSTPQ()` method invocations on node objects. For example:\n * ```js\n * uvNode = uvNode.flipY();\n * ```\n *\n * @augments TempNode\n */\nclass FlipNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FlipNode';\n\n\t}\n\n\t/**\n\t * Constructs a new flip node.\n\t *\n\t * @param {Node} sourceNode - The node which component(s) should be flipped.\n\t * @param {String} components - The components that should be flipped e.g. `'x'` or `'xy'`.\n\t */\n\tconstructor( sourceNode, components ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which component(s) should be flipped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be flipped e.g. `'x'` or `'xy'`.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.components = components;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the source node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { components, sourceNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst sourceSnippet = sourceNode.build( builder );\n\n\t\tconst sourceCache = builder.getVarFromNode( this );\n\t\tconst sourceProperty = builder.getPropertyName( sourceCache );\n\n\t\tbuilder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tlet componentIndex = 0;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ componentIndex ] ) {\n\n\t\t\t\tsnippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );\n\n\t\t\t\tcomponentIndex ++;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceProperty + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\n/**\n * Base class for representing data input nodes.\n *\n * @augments Node\n */\nclass InputNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {Any} value - The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInputNode = true;\n\n\t\t/**\n\t\t * The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t\t *\n\t\t * @type {Any}\n\t\t */\n\t\tthis.value = value;\n\n\t\t/**\n\t\t * The precision of the value in the shader.\n\t\t *\n\t\t * @type {('low'|'medium'|'high')?}\n\t\t * @default null\n\t\t */\n\t\tthis.precision = null;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Returns the input type of the node which is by default the node type. Derived modules\n\t * might overwrite this method and use a fixed type or compute one analytically.\n\t *\n\t * A typical example for different input and node types are textures. The input type of a\n\t * normal RGBA texture is `texture` whereas its node type is `vec4`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Sets the precision to the given value. The method can be\n\t * overwritten in derived classes if the final precision must be computed\n\t * analytically.\n\t *\n\t * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.\n\t * @return {InputNode} A reference to this node.\n\t */\n\tsetPrecision( precision ) {\n\n\t\tthis.precision = precision;\n\n\t\treturn this;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value;\n\n\t\tif ( this.value && this.value.toArray ) data.value = this.value.toArray();\n\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t\tif ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );\n\n\t\tdata.precision = this.precision;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;\n\n\t\tthis.precision = data.precision || null;\n\n\t\tif ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nconst _regNum = /float|u?int/;\n\n/**\n * Class for representing a constant value in the shader.\n *\n * @augments InputNode\n */\nclass ConstNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'ConstNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).\n\t * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isConstNode = true;\n\n\t}\n\n\t/**\n\t * Generates the shader string of the value with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated value as a shader string.\n\t */\n\tgenerateConst( builder ) {\n\n\t\treturn builder.generateConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tif ( _regNum.test( type ) && _regNum.test( output ) ) {\n\n\t\t\treturn builder.generateConst( output, this.value );\n\n\t\t}\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\n/**\n * Base class for representing member access on an object-like\n * node data structures.\n *\n * @augments Node\n */\nclass MemberNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MemberNode';\n\n\t}\n\n\t/**\n\t * Constructs an array element node.\n\t *\n\t * @param {Node} node - The array-like node.\n\t * @param {String} property - The property name.\n\t */\n\tconstructor( node, property ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The array-like node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The property name.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMemberNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getMemberType( builder, this.property );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst propertyName = this.node.build( builder );\n\n\t\treturn propertyName + '.' + this.property;\n\n\t}\n\n}\n\n/** @module TSLCore **/\n\nlet currentStack = null;\n\nconst NodeElements = new Map();\n\nfunction addMethodChaining( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) {\n\n\t\tconsole.warn( `Redefinition of method chaining ${ name }` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\nconst parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );\n\nconst shaderNodeHandler = {\n\n\tsetup( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget( node, prop, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( node.isStackNode !== true && prop === 'assign' ) {\n\n\t\t\t\treturn ( ...params ) => {\n\n\t\t\t\t\tcurrentStack.assign( nodeObj, ...params );\n\n\t\t\t\t\treturn nodeObj;\n\n\t\t\t\t};\n\n\t\t\t} else if ( NodeElements.has( prop ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );\n\n\t\t\t} else if ( prop === 'self' ) {\n\n\t\t\t\treturn node;\n\n\t\t\t} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );\n\n\t\t\t} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop );\n\n\t\t\t\treturn nodeObject( new SplitNode( nodeObj, prop ) );\n\n\t\t\t} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );\n\n\t\t\t\treturn ( value ) => nodeObject( new SetNode( node, prop, value ) );\n\n\t\t\t} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );\n\n\t\t\t\treturn () => nodeObject( new FlipNode( nodeObject( node ), prop ) );\n\n\t\t\t} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {\n\n\t\t\t\t// accessing property\n\n\t\t\t\tif ( prop === 'width' ) prop = 'x';\n\t\t\t\telse if ( prop === 'height' ) prop = 'y';\n\t\t\t\telse if ( prop === 'depth' ) prop = 'z';\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t} else if ( /^get$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties\n\n\t\t\t\treturn ( value ) => nodeObject( new MemberNode( nodeObj, value ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.get( node, prop, nodeObj );\n\n\t},\n\n\tset( node, prop, value, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\t// setting properties\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\tnodeObj[ prop ].assign( value );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.set( node, prop, value, nodeObj );\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\tif ( nodeObject === undefined ) {\n\n\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\n\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t}\n\n\t\treturn nodeObject;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn Fn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, inputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.inputNodes = inputNodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.getOutputNode( builder ).getMemberType( builder, name );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, inputNodes } = this;\n\n\t\tconst properties = builder.getNodeProperties( shaderNode );\n\t\tif ( properties.onceOutput ) return properties.onceOutput;\n\n\t\t//\n\n\t\tlet result = null;\n\n\t\tif ( shaderNode.layout ) {\n\n\t\t\tlet functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );\n\n\t\t\tif ( functionNodesCacheMap === undefined ) {\n\n\t\t\t\tfunctionNodesCacheMap = new WeakMap();\n\n\t\t\t\tnodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );\n\n\t\t\t}\n\n\t\t\tlet functionNode = functionNodesCacheMap.get( shaderNode );\n\n\t\t\tif ( functionNode === undefined ) {\n\n\t\t\t\tfunctionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );\n\n\t\t\t\tfunctionNodesCacheMap.set( shaderNode, functionNode );\n\n\t\t\t}\n\n\t\t\tif ( builder.currentFunctionNode !== null ) {\n\n\t\t\t\tbuilder.currentFunctionNode.includes.push( functionNode );\n\n\t\t\t}\n\n\t\t\tresult = nodeObject( functionNode.call( inputNodes ) );\n\n\t\t} else {\n\n\t\t\tconst jsFunc = shaderNode.jsFunc;\n\t\t\tconst outputNode = inputNodes !== null || jsFunc.length > 1 ? jsFunc( inputNodes || [], builder ) : jsFunc( builder );\n\n\t\t\tresult = nodeObject( outputNode );\n\n\t\t}\n\n\t\tif ( shaderNode.once ) {\n\n\t\t\tproperties.onceOutput = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetOutputNode( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.outputNode === null ) {\n\n\t\t\tproperties.outputNode = this.setupOutput( builder );\n\n\t\t}\n\n\t\treturn properties.outputNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\treturn this.getOutputNode( builder );\n\n\t}\n\n\tsetupOutput( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst outputNode = this.getOutputNode( builder );\n\n\t\treturn outputNode.build( builder, output );\n\n\t}\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.jsFunc = jsFunc;\n\t\tthis.layout = null;\n\n\t\tthis.global = true;\n\n\t\tthis.once = false;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tthis.layout = layout;\n\n\t\treturn this;\n\n\t}\n\n\tcall( inputs = null ) {\n\n\t\tnodeObjects( inputs );\n\n\t\treturn nodeObject( new ShaderCallNodeInternal( this, inputs ) );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst safeGetNodeType = ( node ) => {\n\n\ttry {\n\n\t\treturn node.getNodeType();\n\n\t} catch ( _ ) {\n\n\t\treturn undefined;\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObject( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( safeGetNodeType( node ) === type ) return nodeObject( node );\n\t\t\treturn nodeObject( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObject( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\nconst defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nconst getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nfunction ShaderNode( jsFunc, nodeType ) {\n\n\treturn new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );\n\n}\n\nconst nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nconst nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nconst nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nconst nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );\nconst nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );\n\nconst Fn = ( jsFunc, nodeType ) => {\n\n\tconst shaderNode = new ShaderNode( jsFunc, nodeType );\n\n\tconst fn = ( ...params ) => {\n\n\t\tlet inputs;\n\n\t\tnodeObjects( params );\n\n\t\tif ( params[ 0 ] && params[ 0 ].isNode ) {\n\n\t\t\tinputs = [ ...params ];\n\n\t\t} else {\n\n\t\t\tinputs = params[ 0 ];\n\n\t\t}\n\n\t\treturn shaderNode.call( inputs );\n\n\t};\n\n\tfn.shaderNode = shaderNode;\n\n\tfn.setLayout = ( layout ) => {\n\n\t\tshaderNode.setLayout( layout );\n\n\t\treturn fn;\n\n\t};\n\n\tfn.once = () => {\n\n\t\tshaderNode.once = true;\n\n\t\treturn fn;\n\n\t};\n\n\treturn fn;\n\n};\n\n/**\n * @function\n * @deprecated since r168. Use {@link Fn} instead.\n *\n * @param  {...any} params\n * @returns {Function}\n */\nconst tslFn = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ShaderNode: tslFn() has been renamed to Fn().' );\n\treturn Fn( ...params );\n\n};\n\n//\n\naddMethodChaining( 'toGlobal', ( node ) => {\n\n\tnode.global = true;\n\n\treturn node;\n\n} );\n\n//\n\nconst setCurrentStack = ( stack ) => {\n\n\tcurrentStack = stack;\n\n};\n\nconst getCurrentStack = () => currentStack;\n\nconst If = ( ...params ) => currentStack.If( ...params );\n\nfunction append( node ) {\n\n\tif ( currentStack ) currentStack.add( node );\n\n\treturn node;\n\n}\n\naddMethodChaining( 'append', append );\n\n// types\n\nconst color = new ConvertType( 'color' );\n\nconst float = new ConvertType( 'float', cacheMaps.float );\nconst int = new ConvertType( 'int', cacheMaps.ints );\nconst uint = new ConvertType( 'uint', cacheMaps.uint );\nconst bool = new ConvertType( 'bool', cacheMaps.bool );\n\nconst vec2 = new ConvertType( 'vec2' );\nconst ivec2 = new ConvertType( 'ivec2' );\nconst uvec2 = new ConvertType( 'uvec2' );\nconst bvec2 = new ConvertType( 'bvec2' );\n\nconst vec3 = new ConvertType( 'vec3' );\nconst ivec3 = new ConvertType( 'ivec3' );\nconst uvec3 = new ConvertType( 'uvec3' );\nconst bvec3 = new ConvertType( 'bvec3' );\n\nconst vec4 = new ConvertType( 'vec4' );\nconst ivec4 = new ConvertType( 'ivec4' );\nconst uvec4 = new ConvertType( 'uvec4' );\nconst bvec4 = new ConvertType( 'bvec4' );\n\nconst mat2 = new ConvertType( 'mat2' );\nconst mat3 = new ConvertType( 'mat3' );\nconst mat4 = new ConvertType( 'mat4' );\n\nconst string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nconst arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddMethodChaining( 'toColor', color );\naddMethodChaining( 'toFloat', float );\naddMethodChaining( 'toInt', int );\naddMethodChaining( 'toUint', uint );\naddMethodChaining( 'toBool', bool );\naddMethodChaining( 'toVec2', vec2 );\naddMethodChaining( 'toIVec2', ivec2 );\naddMethodChaining( 'toUVec2', uvec2 );\naddMethodChaining( 'toBVec2', bvec2 );\naddMethodChaining( 'toVec3', vec3 );\naddMethodChaining( 'toIVec3', ivec3 );\naddMethodChaining( 'toUVec3', uvec3 );\naddMethodChaining( 'toBVec3', bvec3 );\naddMethodChaining( 'toVec4', vec4 );\naddMethodChaining( 'toIVec4', ivec4 );\naddMethodChaining( 'toUVec4', uvec4 );\naddMethodChaining( 'toBVec4', bvec4 );\naddMethodChaining( 'toMat2', mat2 );\naddMethodChaining( 'toMat3', mat3 );\naddMethodChaining( 'toMat4', mat4 );\n\n// basic nodes\n\nconst element = /*@__PURE__*/ nodeProxy( ArrayElementNode );\nconst convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nconst split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddMethodChaining( 'element', element );\naddMethodChaining( 'convert', convert );\n\n/** @module ArrayNode **/\n\n/**\n * ArrayNode represents a collection of nodes, typically created using the {@link module:TSL~array} function.\n * ```js\n * const colors = array( [\n * \tvec3( 1, 0, 0 ),\n * \tvec3( 0, 1, 0 ),\n * \tvec3( 0, 0, 1 )\n * ] );\n *\n * const redColor = tintColors.element( 0 );\n *\n * @augments Node\n */\nclass ArrayNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ArrayNode';\n\n\t}\n\n\t/**\n\t * Constructs a new array node.\n\t *\n\t * @param {String} [nodeType] - The data type of the elements.\n\t * @param {Number} [count] - Size of the array.\n\t * @param {Array<Node>?} [values=null] - Array default values.\n\t */\n\tconstructor( nodeType, count, values = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * Array size.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * Array default values.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.values = values;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\tthis.nodeType = this.values[ 0 ].getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.generateArray( type, this.count, this.values );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an array node.\n *\n * @function\n * @param {String|Array<Node>} nodeTypeOrValues - A string representing the element type (e.g., 'vec3')\n * or an array containing the default values (e.g., [ vec3() ]).\n * @param {Number?} [count] - Size of the array.\n * @returns {ArrayNode}\n */\nconst array = ( ...params ) => {\n\n\tlet node;\n\n\tif ( params.length === 1 ) {\n\n\t\tconst values = params[ 0 ];\n\n\t\tnode = new ArrayNode( null, values.length, values );\n\n\t} else {\n\n\t\tconst nodeType = params[ 0 ];\n\t\tconst count = params[ 1 ];\n\n\t\tnode = new ArrayNode( nodeType, count );\n\n\t}\n\n\treturn nodeObject( node );\n\n};\n\naddMethodChaining( 'toArray', ( node, count ) => array( Array( count ).fill( node ) ) );\n\n/** @module UniformGroupNode **/\n\n/**\n * This node can be used to group single instances of {@link UniformNode}\n * and manage them as a uniform buffer.\n *\n * In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`\n * will be used when defining the {@link UniformNode#groupNode} property.\n *\n * - `objectGroup`: Uniform buffer per object.\n * - `renderGroup`: Shared uniform buffer, updated once per render call.\n * - `frameGroup`: Shared uniform buffer, updated once per frame.\n *\n * @augments Node\n */\nclass UniformGroupNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'UniformGroupNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform group node.\n\t *\n\t * @param {String} name - The name of the uniform group node.\n\t * @param {Boolean} [shared=false] - Whether this uniform group node is shared or not.\n\t * @param {Number} [order=1] - Influences the internal sorting.\n\t */\n\tconstructor( name, shared = false, order = 1 ) {\n\n\t\tsuper( 'string' );\n\n\t\t/**\n\t\t * The name of the uniform group node.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this uniform group node is shared or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.shared = shared;\n\n\t\t/**\n\t\t * Influences the internal sorting.\n\t\t * TODO: Add details when this property should be changed.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.order = order;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformGroup = true;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.name = this.name;\n\t\tdata.version = this.version;\n\t\tdata.shared = this.shared;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.name = data.name;\n\t\tthis.version = data.version;\n\t\tthis.shared = data.shared;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a uniform group node with the given name.\n *\n * @function\n * @param {String} name - The name of the uniform group node.\n * @returns {UniformGroupNode}\n */\nconst uniformGroup = ( name ) => new UniformGroupNode( name );\n\n/**\n * TSL function for creating a shared uniform group node with the given name and order.\n *\n * @function\n * @param {String} name - The name of the uniform group node.\n * @param {Number} [order=0] - Influences the internal sorting.\n * @returns {UniformGroupNode}\n */\nconst sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per frame.\n *\n * @type {UniformGroupNode}\n */\nconst frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per render.\n *\n * @type {UniformGroupNode}\n */\nconst renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );\n\n/**\n * TSL object that represents a uniform group node which is updated once per object.\n *\n * @type {UniformGroupNode}\n */\nconst objectGroup = /*@__PURE__*/ uniformGroup( 'object' );\n\n/** @module UniformNode **/\n\n/**\n * Class for representing a uniform.\n *\n * @augments InputNode\n */\nclass UniformNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform node.\n\t *\n\t * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n\t * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformNode = true;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The uniform group of this uniform. By default, uniforms are\n\t\t * managed per object but they might belong to a shared group\n\t\t * which is updated per frame or render call.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = objectGroup;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#name} property.\n\t *\n\t * @param {String} name - The name of the uniform.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#groupNode} property.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.groupNode = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the {@link UniformNode#groupNode}.\n\t *\n\t * @return {UniformGroupNode} The uniform group.\n\t */\n\tgetGroup() {\n\n\t\treturn this.groupNode;\n\n\t}\n\n\t/**\n\t * By default, this method returns the result of {@link Node#getHash} but derived\n\t * classes might overwrite this method with a different implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The uniform hash.\n\t */\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tconst self = this.getSelf();\n\n\t\tcallback = callback.bind( self );\n\n\t\treturn super.onUpdate( ( frame ) => {\n\n\t\t\tconst value = callback( frame, self );\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tthis.value = value;\n\n\t\t\t}\n\n\t \t}, updateType );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\n\n\t\tif ( builder.context.label !== undefined ) delete builder.context.label;\n\n\t\treturn builder.format( propertyName, type, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a uniform node.\n *\n * @function\n * @param {Any} arg1 - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n * @param {String?} arg2 - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n * @returns {UniformNode}\n */\nconst uniform = ( arg1, arg2 ) => {\n\n\tconst nodeType = getConstNodeType( arg2 || arg1 );\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tconst value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n\n/** @module PropertyNode **/\n\n/**\n * This class represents a shader property. It can be used\n * to explicitly define a property and assign a value to it.\n *\n * ```js\n * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );\n *```\n * `PropertyNode` is used by the engine to predefined common material properties\n * for TSL code.\n *\n * @augments Node\n */\nclass PropertyNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PropertyNode';\n\n\t}\n\n\t/**\n\t * Constructs a new property node.\n\t *\n\t * @param {String} nodeType - The type of the node.\n\t * @param {String?} [name=null] - The name of the property in the shader.\n\t * @param {Boolean} [varying=false] - Whether this property is a varying or not.\n\t */\n\tconstructor( nodeType, name = null, varying = false ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The name of the property in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this property is a varying or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.varying = varying;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPropertyNode = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\t/**\n\t * The method is overwritten so it always returns `true`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tlet nodeVar;\n\n\t\tif ( this.varying === true ) {\n\n\t\t\tnodeVar = builder.getVaryingFromNode( this, this.name );\n\t\t\tnodeVar.needsInterpolation = true;\n\n\t\t} else {\n\n\t\t\tnodeVar = builder.getVarFromNode( this, this.name );\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVar );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a property node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} [name=null] - The name of the property in the shader.\n * @returns {PropertyNode}\n */\nconst property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );\n\n/**\n * TSL function for creating a varying property node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} [name=null] - The name of the varying in the shader.\n * @returns {PropertyNode}\n */\nconst varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );\n\n/**\n * TSL object that represents the shader variable `DiffuseColor`.\n *\n * @type {PropertyNode<vec4>}\n */\nconst diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );\n\n/**\n * TSL object that represents the shader variable `EmissiveColor`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );\n\n/**\n * TSL object that represents the shader variable `Roughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );\n\n/**\n * TSL object that represents the shader variable `Metalness`.\n *\n * @type {PropertyNode<float>}\n */\nconst metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );\n\n/**\n * TSL object that represents the shader variable `Clearcoat`.\n *\n * @type {PropertyNode<float>}\n */\nconst clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );\n\n/**\n * TSL object that represents the shader variable `ClearcoatRoughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );\n\n/**\n * TSL object that represents the shader variable `Sheen`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );\n\n/**\n * TSL object that represents the shader variable `SheenRoughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );\n\n/**\n * TSL object that represents the shader variable `Iridescence`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );\n\n/**\n * TSL object that represents the shader variable `IridescenceIOR`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );\n\n/**\n * TSL object that represents the shader variable `IridescenceThickness`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );\n\n/**\n * TSL object that represents the shader variable `AlphaT`.\n *\n * @type {PropertyNode<float>}\n */\nconst alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );\n\n/**\n * TSL object that represents the shader variable `Anisotropy`.\n *\n * @type {PropertyNode<float>}\n */\nconst anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyT`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyB`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );\n\n/**\n * TSL object that represents the shader variable `SpecularColor`.\n *\n * @type {PropertyNode<color>}\n */\nconst specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );\n\n/**\n * TSL object that represents the shader variable `SpecularF90`.\n *\n * @type {PropertyNode<float>}\n */\nconst specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );\n\n/**\n * TSL object that represents the shader variable `Shininess`.\n *\n * @type {PropertyNode<float>}\n */\nconst shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );\n\n/**\n * TSL object that represents the shader variable `Output`.\n *\n * @type {PropertyNode<vec4>}\n */\nconst output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );\n\n/**\n * TSL object that represents the shader variable `dashSize`.\n *\n * @type {PropertyNode<float>}\n */\nconst dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );\n\n/**\n * TSL object that represents the shader variable `gapSize`.\n *\n * @type {PropertyNode<float>}\n */\nconst gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );\n\n/**\n * TSL object that represents the shader variable `pointWidth`.\n *\n * @type {PropertyNode<float>}\n */\nconst pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );\n\n/**\n * TSL object that represents the shader variable `IOR`.\n *\n * @type {PropertyNode<float>}\n */\nconst ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );\n\n/**\n * TSL object that represents the shader variable `Transmission`.\n *\n * @type {PropertyNode<float>}\n */\nconst transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );\n\n/**\n * TSL object that represents the shader variable `Thickness`.\n *\n * @type {PropertyNode<float>}\n */\nconst thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );\n\n/**\n * TSL object that represents the shader variable `AttenuationDistance`.\n *\n * @type {PropertyNode<float>}\n */\nconst attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );\n\n/**\n * TSL object that represents the shader variable `AttenuationColor`.\n *\n * @type {PropertyNode<color>}\n */\nconst attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );\n\n/**\n * TSL object that represents the shader variable `Dispersion`.\n *\n * @type {PropertyNode<float>}\n */\nconst dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );\n\n/** @module AssignNode **/\n\n/**\n * These node represents an assign operation. Meaning a node is assigned\n * to another node.\n *\n * @augments TempNode\n */\nclass AssignNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AssignNode';\n\n\t}\n\n\t/**\n\t * Constructs a new assign node.\n\t *\n\t * @param {Node} targetNode - The target node.\n\t * @param {Node} sourceNode - The source type.\n\t */\n\tconstructor( targetNode, sourceNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The target node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t\t/**\n\t\t * The source node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes. This method\n\t * is overwritten since it always returns `false` (assigns are unique).\n\t *\n\t * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.\n\t */\n\thasDependencies() {\n\n\t\treturn false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\treturn output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\t/**\n\t * Whether a split is required when assigning source to target. This can happen when the component length of\n\t * target and source data type does not match.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether a split is required when assigning source to target.\n\t */\n\tneedsSplitAssign( builder ) {\n\n\t\tconst { targetNode } = this;\n\n\t\tif ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {\n\n\t\t\tconst targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );\n\t\t\tconst assignDifferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;\n\n\t\t\treturn assignDifferentVector;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { targetNode, sourceNode } = this;\n\n\t\tconst needsSplitAssign = this.needsSplitAssign( builder );\n\n\t\tconst targetType = targetNode.getNodeType( builder );\n\n\t\tconst target = targetNode.context( { assign: true } ).build( builder );\n\t\tconst source = sourceNode.build( builder, targetType );\n\n\t\tconst sourceType = sourceNode.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t//\n\n\t\tlet snippet;\n\n\t\tif ( nodeData.initialized === true ) {\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else if ( needsSplitAssign ) {\n\n\t\t\tconst sourceVar = builder.getVarFromNode( this, null, targetType );\n\t\t\tconst sourceProperty = builder.getPropertyName( sourceVar );\n\n\t\t\tbuilder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );\n\n\t\t\tconst targetRoot = targetNode.node.context( { assign: true } ).build( builder );\n\n\t\t\tfor ( let i = 0; i < targetNode.components.length; i ++ ) {\n\n\t\t\t\tconst component = targetNode.components[ i ];\n\n\t\t\t\tbuilder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );\n\n\t\t\t}\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = `${ target } = ${ source }`;\n\n\t\t\tif ( output === 'void' || sourceType === 'void' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\t\tsnippet = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeData.initialized = true;\n\n\t\treturn builder.format( snippet, targetType, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an assign node.\n *\n * @function\n * @param {Node} targetNode - The target node.\n * @param {Node} sourceNode - The source type.\n * @returns {AssignNode}\n */\nconst assign = /*@__PURE__*/ nodeProxy( AssignNode );\n\naddMethodChaining( 'assign', assign );\n\n/**\n * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted\n * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate\n * this logic.\n *\n * @augments TempNode\n */\nclass FunctionCallNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionCallNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function call node.\n\t *\n\t * @param {FunctionNode?} functionNode - The function node.\n\t * @param {Object<String, Node>} [parameters={}] - The parameters for the function call.\n\t */\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The function node.\n\t\t *\n\t\t * @type {FunctionNode}\n\t\t * @default null\n\t\t */\n\t\tthis.functionNode = functionNode;\n\n\t\t/**\n\t\t * The parameters of the function call.\n\t\t *\n\t\t * @type {Object<String, Node>}\n\t\t * @default {}\n\t\t */\n\t\tthis.parameters = parameters;\n\n\t}\n\n\t/**\n\t * Sets the parameters of the function call node.\n\t *\n\t * @param {Object<String, Node>} parameters - The parameters to set.\n\t * @return {FunctionCallNode} A reference to this node.\n\t */\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the parameters of the function call node.\n\t *\n\t * @return {Object<String, Node>} The parameters of this node.\n\t */\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tconst generateInput = ( node, inputNode ) => {\n\n\t\t\tconst type = inputNode.type;\n\t\t\tconst pointer = type === 'pointer';\n\n\t\t\tlet output;\n\n\t\t\tif ( pointer ) output = '&' + node.build( builder );\n\t\t\telse output = node.build( builder, type );\n\n\t\t\treturn output;\n\n\t\t};\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tparams.push( generateInput( parameters[ i ], inputs[ i ] ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( generateInput( node, inputNode ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${functionName}( ${params.join( ', ' )} )`;\n\n\t}\n\n}\n\nconst call = ( func, ...params ) => {\n\n\tparams = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );\n\n\treturn nodeObject( new FunctionCallNode( nodeObject( func ), params ) );\n\n};\n\naddMethodChaining( 'call', call );\n\n/** @module OperatorNode **/\n\n/**\n * This node represents basic mathematical and logical operations like addition,\n * subtraction or comparisons (e.g. `equal()`).\n *\n * @augments TempNode\n */\nclass OperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OperatorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new operator node.\n\t *\n\t * @param {String} op - The operator.\n\t * @param {Node} aNode - The first input.\n\t * @param {Node} bNode - The second input.\n\t * @param {...Node} params - Additional input parameters.\n\t */\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalOp = new OperatorNode( op, aNode, bNode );\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new OperatorNode( op, finalOp, params[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = params[ params.length - 1 ];\n\n\t\t}\n\n\t\t/**\n\t\t * The operator.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.op = op;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOperatorNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the operator\n\t * and the input node types.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} output - The current output string.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn 'void';\n\n\t\t} else if ( op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn builder.getIntegerType( typeA );\n\n\t\t} else if ( op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\t// Handle matrix operations\n\t\t\tif ( builder.isMatrix( typeA ) ) {\n\n\t\t\t\tif ( typeB === 'float' ) {\n\n\t\t\t\t\treturn typeA; // matrix * scalar = matrix\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\treturn builder.getVectorFromMatrix( typeA ); // matrix * vector\n\n\t\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\treturn typeA; // matrix * matrix\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\tif ( typeA === 'float' ) {\n\n\t\t\t\t\treturn typeB; // scalar * matrix = matrix\n\n\t\t\t\t} else if ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\treturn builder.getVectorFromMatrix( typeB ); // vector * matrix\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Handle non-matrix cases\n\t\t\tif ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;\n\n\t\t\tif ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else if ( typeA !== typeB ) {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>>' || op === '<<' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.changeComponentType( typeB, 'uint' );\n\n\t\t\t} else if ( builder.isMatrix( typeA ) ) {\n\n\t\t\t\tif ( typeB === 'float' ) {\n\n\t\t\t\t\t// Keep matrix type for typeA, but ensure typeB stays float\n\t\t\t\t\ttypeB = 'float';\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\t// matrix x vector\n\t\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t\t} else if ( builder.isMatrix( typeB ) ) ; else {\n\n\t\t\t\t\ttypeA = typeB = type;\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\tif ( typeA === 'float' ) {\n\n\t\t\t\t\t// Keep matrix type for typeB, but ensure typeA stays float\n\t\t\t\t\ttypeA = 'float';\n\n\t\t\t\t} else if ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\t// vector x matrix\n\t\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = type;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = typeof bNode !== 'undefined' ? bNode.build( builder, typeB ) : null;\n\n\t\tconst outputLength = builder.getTypeLength( output );\n\t\tconst fnOpSnippet = builder.getFunctionOperator( op );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tif ( op === '<' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThan', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } < ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '<=' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThanEqual', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } <= ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThan', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } > ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>=' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThanEqual', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } >= ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '!' || op === '~' ) {\n\n\t\t\t\treturn builder.format( `(${op}${a})`, typeA, output );\n\n\t\t\t} else if ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\t// Handle matrix operations\n\t\t\t\tif ( builder.isMatrix( typeA ) && typeB === 'float' ) {\n\n\t\t\t\t\treturn builder.format( `( ${ b } ${ op } ${ a } )`, type, output );\n\n\t\t\t\t} else if ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\tif ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tif ( builder.isMatrix( typeA ) && typeB === 'float' ) {\n\n\t\t\t\t\treturn builder.format( `${ b } ${ op } ${ a }`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\n/**\n * Returns the addition of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst add = /*@__PURE__*/ nodeProxy( OperatorNode, '+' );\n\n/**\n * Returns the subtraction of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst sub = /*@__PURE__*/ nodeProxy( OperatorNode, '-' );\n\n/**\n * Returns the multiplication of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst mul = /*@__PURE__*/ nodeProxy( OperatorNode, '*' );\n\n/**\n * Returns the division of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst div = /*@__PURE__*/ nodeProxy( OperatorNode, '/' );\n\n/**\n * Computes the remainder of dividing the first node by the second, for integer values.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst modInt = /*@__PURE__*/ nodeProxy( OperatorNode, '%' );\n\n/**\n * Checks if two nodes are equal.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' );\n\n/**\n * Checks if two nodes are not equal.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' );\n\n/**\n * Checks if the first node is less than the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' );\n\n/**\n * Checks if the first node is greater than the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' );\n\n/**\n * Checks if the first node is less than or equal to the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' );\n\n/**\n * Checks if the first node is greater than or equal to the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' );\n\n/**\n * Performs logical AND on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' );\n\n/**\n * Performs logical OR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' );\n\n/**\n * Performs logical NOT on a node.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' );\n\n/**\n * Performs logical XOR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' );\n\n/**\n * Performs bitwise AND on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' );\n\n/**\n * Performs bitwise NOT on a node.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' );\n\n/**\n * Performs bitwise OR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' );\n\n/**\n * Performs bitwise XOR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' );\n\n/**\n * Shifts a node to the left.\n *\n * @function\n * @param {Node} aNode - The node to shift.\n * @param {Node} bNode - The value to shift.\n * @returns {OperatorNode}\n */\nconst shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' );\n\n/**\n * Shifts a node to the right.\n *\n * @function\n * @param {Node} aNode - The node to shift.\n * @param {Node} bNode - The value to shift.\n * @returns {OperatorNode}\n */\nconst shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' );\n\naddMethodChaining( 'add', add );\naddMethodChaining( 'sub', sub );\naddMethodChaining( 'mul', mul );\naddMethodChaining( 'div', div );\naddMethodChaining( 'modInt', modInt );\naddMethodChaining( 'equal', equal );\naddMethodChaining( 'notEqual', notEqual );\naddMethodChaining( 'lessThan', lessThan );\naddMethodChaining( 'greaterThan', greaterThan );\naddMethodChaining( 'lessThanEqual', lessThanEqual );\naddMethodChaining( 'greaterThanEqual', greaterThanEqual );\naddMethodChaining( 'and', and );\naddMethodChaining( 'or', or );\naddMethodChaining( 'not', not );\naddMethodChaining( 'xor', xor );\naddMethodChaining( 'bitAnd', bitAnd );\naddMethodChaining( 'bitNot', bitNot );\naddMethodChaining( 'bitOr', bitOr );\naddMethodChaining( 'bitXor', bitXor );\naddMethodChaining( 'shiftLeft', shiftLeft );\naddMethodChaining( 'shiftRight', shiftRight );\n\n/**\n * @function\n * @deprecated since r168. Use {@link modInt} instead.\n *\n * @param  {...any} params\n * @returns {Function}\n */\nconst remainder = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.OperatorNode: .remainder() has been renamed to .modInt().' );\n\treturn modInt( ...params );\n\n};\n\naddMethodChaining( 'remainder', remainder );\n\n/** @module MathNode **/\n\n/**\n * This node represents a variety of mathematical methods available in shaders.\n * They are divided into three categories:\n *\n * - Methods with one input like `sin`, `cos` or `normalize`.\n * - Methods with two inputs like `dot`, `cross` or `pow`.\n * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.\n *\n * @augments TempNode\n */\nclass MathNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MathNode';\n\n\t}\n\n\t/**\n\t * Constructs a new math node.\n\t *\n\t * @param {String} method - The method name.\n\t * @param {Node} aNode - The first input.\n\t * @param {Node?} [bNode=null] - The second input.\n\t * @param {Node?} [cNode=null] - The third input.\n\t */\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The method name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * The third input.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.cNode = cNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMathNode = true;\n\n\t}\n\n\t/**\n\t * The input type is inferred from the node types of the input nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\t/**\n\t * The selected method as well as the input type determine the node type of this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( method === MathNode.ALL ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( method === MathNode.EQUALS ) {\n\n\t\t\treturn builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );\n\n\t\t} else if ( method === MathNode.MOD ) {\n\n\t\t\treturn this.aNode.getNodeType( builder );\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst coordinateSystem = builder.renderer.coordinateSystem;\n\n\t\tif ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = a;\n\t\t\tlet tB = b;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = vec4( vec3( tB ), 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\ttA = vec4( vec3( tA ), 0.0 );\n\n\t\t\t}\n\n\t\t\tconst mulNode = mul( tA, tB ).xyz;\n\n\t\t\treturn normalize( mulNode ).build( builder, output );\n\n\t\t} else if ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else if ( method === MathNode.ONE_MINUS ) {\n\n\t\t\treturn sub( 1.0, a ).build( builder, output );\n\n\t\t} else if ( method === MathNode.RECIPROCAL ) {\n\n\t\t\treturn div( 1.0, a ).build( builder, output );\n\n\t\t} else if ( method === MathNode.DIFFERENCE ) {\n\n\t\t\treturn abs( sub( a, b ) ).build( builder, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( ( coordinateSystem === WebGLCoordinateSystem && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null ) {\n\n\t\t\t\t\tmethod = 'atan2';\n\n\t\t\t\t}\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\t\t\t\tif ( b !== null ) params.push( b.build( builder, inputType ) );\n\t\t\t\tif ( c !== null ) params.push( c.build( builder, inputType ) );\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\n\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.TRANSPOSE = 'transpose';\n\n// 2 inputs\n\nMathNode.BITCAST = 'bitcast';\nMathNode.EQUALS = 'equals';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\n\n// 1 inputs\n\n/**\n * A small value used to handle floating-point precision errors.\n *\n * @type {Node<float>}\n */\nconst EPSILON = /*@__PURE__*/ float( 1e-6 );\n\n/**\n * Represents infinity.\n *\n * @type {Node<float>}\n */\nconst INFINITY = /*@__PURE__*/ float( 1e6 );\n\n/**\n * Represents PI.\n *\n * @type {Node<float>}\n */\nconst PI = /*@__PURE__*/ float( Math.PI );\n\n/**\n * Represents PI * 2.\n *\n * @type {Node<float>}\n */\nconst PI2 = /*@__PURE__*/ float( Math.PI * 2 );\n\n/**\n * Returns `true` if all components of `x` are `true`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node<bool>}\n */\nconst all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL );\n\n/**\n * Returns `true` if any components of `x` are `true`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node<bool>}\n */\nconst any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY );\n\n/**\n * Converts a quantity in degrees to radians.\n *\n * @function\n * @param {Node | Number} x - The input in degrees.\n * @returns {Node}\n */\nconst radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS );\n\n/**\n * Convert a quantity in radians to degrees.\n *\n * @function\n * @param {Node | Number} x - The input in radians.\n * @returns {Node}\n */\nconst degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES );\n\n/**\n * Returns the natural exponentiation of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst exp = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP );\n\n/**\n * Returns 2 raised to the power of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 );\n\n/**\n * Returns the natural logarithm of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG );\n\n/**\n * Returns the base 2 logarithm of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 );\n\n/**\n * Returns the square root of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT );\n\n/**\n * Returns the inverse of the square root of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT );\n\n/**\n * Finds the nearest integer less than or equal to the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst floor = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR );\n\n/**\n * Finds the nearest integer that is greater than or equal to the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL );\n\n/**\n * Calculates the unit vector in the same direction as the original vector.\n *\n * @function\n * @param {Node} x - The input vector.\n * @returns {Node}\n */\nconst normalize = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE );\n\n/**\n * Computes the fractional part of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst fract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT );\n\n/**\n * Returns the sine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN );\n\n/**\n * Returns the cosine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst cos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS );\n\n/**\n * Returns the tangent of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN );\n\n/**\n * Returns the arcsine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN );\n\n/**\n * Returns the arccosine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS );\n\n/**\n * Returns the arc-tangent of the parameter.\n * If two parameters are provided, the result is `atan2(y/x)`.\n *\n * @function\n * @param {Node | Number} y - The y parameter.\n * @param {(Node | Number)?} x - The x parameter.\n * @returns {Node}\n */\nconst atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN );\n\n/**\n * Returns the absolute value of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst abs = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS );\n\n/**\n * Extracts the sign of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN );\n\n/**\n * Calculates the length of a vector.\n *\n * @function\n * @param {Node} x - The parameter.\n * @returns {Node<float>}\n */\nconst length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH );\n\n/**\n * Negates the value of the parameter (-x).\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE );\n\n/**\n * Return `1` minus the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS );\n\n/**\n * Returns the partial derivative of the parameter with respect to x.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX );\n\n/**\n * Returns the partial derivative of the parameter with respect to y.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY );\n\n/**\n * Rounds the parameter to the nearest integer.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND );\n\n/**\n * Returns the reciprocal of the parameter `(1/x)`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL );\n\n/**\n * Truncates the parameter, removing the fractional part.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC );\n\n/**\n * Returns the sum of the absolute derivatives in x and y.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH );\n\n/**\n * Returns the transpose of a matrix.\n *\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node}\n */\nconst transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE );\n\n// 2 inputs\n\n/**\n * Reinterpret the bit representation of a value in one type as a value in another type.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @param {String} y - The new type.\n * @returns {Node}\n */\nconst bitcast = /*@__PURE__*/ nodeProxy( MathNode, MathNode.BITCAST );\n\n/**\n * Returns `true` if `x` equals `y`.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node<bool>}\n */\nconst equals = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EQUALS );\n\n/**\n * Returns the lesser of two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN );\n\n/**\n * Returns the greater of two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX );\n\n/**\n * Computes the remainder of dividing the first node by the second one.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst mod = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MOD );\n\n/**\n * Generate a step function by comparing two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP );\n\n/**\n * Calculates the reflection direction for an incident vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT );\n\n/**\n * Calculates the distance between two points.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first point.\n * @param {Node<vec2|vec3|vec4>} y - The second point.\n * @returns {Node<float>}\n */\nconst distance = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE );\n\n/**\n * Calculates the absolute difference between two values.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node}\n */\nconst difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE );\n\n/**\n * Calculates the dot product of two vectors.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<float>}\n */\nconst dot = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT );\n\n/**\n * Calculates the cross product of two vectors.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS );\n\n/**\n * Return the value of the first parameter raised to the power of the second one.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node}\n */\nconst pow = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW );\n\n/**\n * Returns the square of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 );\n\n/**\n * Returns the cube of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 );\n\n/**\n * Returns the fourth power of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 );\n\n/**\n * Transforms the direction of a vector by a matrix and then normalizes the result.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} direction - The direction vector.\n * @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.\n * @returns {Node}\n */\nconst transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );\n\n/**\n * Returns the cube root of a number.\n *\n * @function\n * @param {Node | Number} a - The first parameter.\n * @returns {Node}\n */\nconst cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );\n\n/**\n * Calculate the squared length of a vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} a - The vector.\n * @returns {Node<float>}\n */\nconst lengthSq = ( a ) => dot( a, a );\n\n/**\n * Linearly interpolates between two values.\n *\n * @function\n * @param {Node | Number} a - The first parameter.\n * @param {Node | Number} b - The second parameter.\n * @param {Node | Number} t - The interpolation value.\n * @returns {Node}\n */\nconst mix = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX );\n\n/**\n * Constrains a value to lie between two further values.\n *\n * @function\n * @param {Node | Number} value - The value to constrain.\n * @param {Node | Number} [low=0] - The lower bound.\n * @param {Node | Number} [high=1] - The upper bound.\n * @returns {Node}\n */\nconst clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );\n\n/**\n * Constrains a value between `0` and `1`.\n *\n * @function\n * @param {Node | Number} value - The value to constrain.\n * @returns {Node}\n */\nconst saturate = ( value ) => clamp( value );\n\n/**\n * Calculates the refraction direction for an incident vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @param {Node<float>} eta - The the ratio of indices of refraction.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT );\n\n/**\n * Performs a Hermite interpolation between two values.\n *\n * @function\n * @param {Node | Number} low - The value of the lower edge of the Hermite function.\n * @param {Node | Number} high - The value of the upper edge of the Hermite function.\n * @param {Node | Number} x - The source value for interpolation.\n * @returns {Node}\n */\nconst smoothstep = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP );\n\n/**\n * Returns a vector pointing in the same direction as another.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} N - The vector to orient.\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} Nref - The reference vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD );\n\n/**\n * Returns a random value for the given uv.\n *\n * @function\n * @param {Node<vec2>} uv - The uv node.\n * @returns {Node<float>}\n */\nconst rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {\n\n\tconst a = 12.9898, b = 78.233, c = 43758.5453;\n\tconst dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ).mul( c ) );\n\n} );\n\n/**\n * Alias for `mix()` with a different parameter order.\n *\n * @function\n * @param {Node | Number} t - The interpolation value.\n * @param {Node | Number} e1 - The first parameter.\n * @param {Node | Number} e2 - The second parameter.\n * @returns {Node}\n */\nconst mixElement = ( t, e1, e2 ) => mix( e1, e2, t );\n\n/**\n * Alias for `smoothstep()` with a different parameter order.\n *\n * @function\n * @param {Node | Number} x - The source value for interpolation.\n * @param {Node | Number} low - The value of the lower edge of the Hermite function.\n * @param {Node | Number} high - The value of the upper edge of the Hermite function.\n * @returns {Node}\n */\nconst smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );\n\n/**\n * Returns the arc-tangent of the quotient of its parameters.\n *\n * @function\n * @deprecated since r172. Use {@link atan} instead.\n *\n * @param {Node | Number} y - The y parameter.\n * @param {Node | Number} x - The x parameter.\n * @returns {Node}\n */\nconst atan2 = ( y, x ) => { // @deprecated, r172\n\n\tconsole.warn( 'THREE.TSL: \"atan2\" is overloaded. Use \"atan\" instead.' );\n\treturn atan( y, x );\n\n};\n\n// GLSL alias function\n\nconst faceforward = faceForward;\nconst inversesqrt = inverseSqrt;\n\n// Method chaining\n\naddMethodChaining( 'all', all );\naddMethodChaining( 'any', any );\naddMethodChaining( 'equals', equals );\n\naddMethodChaining( 'radians', radians );\naddMethodChaining( 'degrees', degrees );\naddMethodChaining( 'exp', exp );\naddMethodChaining( 'exp2', exp2 );\naddMethodChaining( 'log', log );\naddMethodChaining( 'log2', log2 );\naddMethodChaining( 'sqrt', sqrt );\naddMethodChaining( 'inverseSqrt', inverseSqrt );\naddMethodChaining( 'floor', floor );\naddMethodChaining( 'ceil', ceil );\naddMethodChaining( 'normalize', normalize );\naddMethodChaining( 'fract', fract );\naddMethodChaining( 'sin', sin );\naddMethodChaining( 'cos', cos );\naddMethodChaining( 'tan', tan );\naddMethodChaining( 'asin', asin );\naddMethodChaining( 'acos', acos );\naddMethodChaining( 'atan', atan );\naddMethodChaining( 'abs', abs );\naddMethodChaining( 'sign', sign );\naddMethodChaining( 'length', length );\naddMethodChaining( 'lengthSq', lengthSq );\naddMethodChaining( 'negate', negate );\naddMethodChaining( 'oneMinus', oneMinus );\naddMethodChaining( 'dFdx', dFdx );\naddMethodChaining( 'dFdy', dFdy );\naddMethodChaining( 'round', round );\naddMethodChaining( 'reciprocal', reciprocal );\naddMethodChaining( 'trunc', trunc );\naddMethodChaining( 'fwidth', fwidth );\naddMethodChaining( 'atan2', atan2 );\naddMethodChaining( 'min', min$1 );\naddMethodChaining( 'max', max$1 );\naddMethodChaining( 'mod', mod );\naddMethodChaining( 'step', step );\naddMethodChaining( 'reflect', reflect );\naddMethodChaining( 'distance', distance );\naddMethodChaining( 'dot', dot );\naddMethodChaining( 'cross', cross );\naddMethodChaining( 'pow', pow );\naddMethodChaining( 'pow2', pow2 );\naddMethodChaining( 'pow3', pow3 );\naddMethodChaining( 'pow4', pow4 );\naddMethodChaining( 'transformDirection', transformDirection );\naddMethodChaining( 'mix', mixElement );\naddMethodChaining( 'clamp', clamp );\naddMethodChaining( 'refract', refract );\naddMethodChaining( 'smoothstep', smoothstepElement );\naddMethodChaining( 'faceForward', faceForward );\naddMethodChaining( 'difference', difference );\naddMethodChaining( 'saturate', saturate );\naddMethodChaining( 'cbrt', cbrt );\naddMethodChaining( 'transpose', transpose );\naddMethodChaining( 'rand', rand );\n\n/** @module ConditionalNode **/\n\n/**\n * Represents a logical `if/else` statement. Can be used as an alternative\n * to the `If()`/`Else()` syntax.\n *\n * The corresponding TSL `select()` looks like so:\n * ```js\n * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );\n * ```\n * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`\n * determine the outcome of the entire statement.\n *\n * @augments Node\n */\nclass ConditionalNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConditionalNode';\n\n\t}\n\n\t/**\n\t * Constructs a new conditional node.\n\t *\n\t * @param {Node} condNode - The node that defines the condition.\n\t * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n\t * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n\t */\n\tconstructor( condNode, ifNode, elseNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that defines the condition.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.condNode = condNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `true`.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.ifNode = ifNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `false`.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the if/else\n\t * nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst { ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tif ( ifNode === undefined ) {\n\n\t\t\t// fallback setup\n\n\t\t\tthis.setup( builder );\n\n\t\t\treturn this.getNodeType( builder );\n\n\t\t}\n\n\t\tconst ifType = ifNode.getNodeType( builder );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tconst elseType = elseNode.getNodeType( builder );\n\n\t\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\t\treturn elseType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst condNode = this.condNode.cache();\n\t\tconst ifNode = this.ifNode.cache();\n\t\tconst elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n\t\t//\n\n\t\tconst currentNodeBlock = builder.context.nodeBlock;\n\n\t\tbuilder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;\n\t\tif ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.condNode = condNode;\n\t\tproperties.ifNode = ifNode.context( { nodeBlock: ifNode } );\n\t\tproperties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( nodeData.nodeProperty !== undefined ) {\n\n\t\t\treturn nodeData.nodeProperty;\n\n\t\t}\n\n\t\tconst { condNode, ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tconst needsOutput = output !== 'void';\n\t\tconst nodeProperty = needsOutput ? property( type ).build( builder ) : '';\n\n\t\tnodeData.nodeProperty = nodeProperty;\n\n\t\tconst nodeSnippet = condNode.build( builder, 'bool' );\n\n\t\tbuilder.addFlowCode( `\\n${ builder.tab }if ( ${ nodeSnippet } ) {\\n\\n` ).addFlowTab();\n\n\t\tlet ifSnippet = ifNode.build( builder, type );\n\n\t\tif ( ifSnippet ) {\n\n\t\t\tif ( needsOutput ) {\n\n\t\t\t\tifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n\n\t\t\t} else {\n\n\t\t\t\tifSnippet = 'return ' + ifSnippet + ';';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}' );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tbuilder.addFlowCode( ' else {\\n\\n' ).addFlowTab();\n\n\t\t\tlet elseSnippet = elseNode.build( builder, type );\n\n\t\t\tif ( elseSnippet ) {\n\n\t\t\t\tif ( needsOutput ) {\n\n\t\t\t\t\telseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n\n\t\t\t\t} else {\n\n\t\t\t\t\telseSnippet = 'return ' + elseSnippet + ';';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n' );\n\n\t\t} else {\n\n\t\t\tbuilder.addFlowCode( '\\n\\n' );\n\n\t\t}\n\n\t\treturn builder.format( nodeProperty, type, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a conditional node.\n *\n * @function\n * @param {Node} condNode - The node that defines the condition.\n * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n * @returns {ConditionalNode}\n */\nconst select = /*@__PURE__*/ nodeProxy( ConditionalNode );\n\naddMethodChaining( 'select', select );\n\n// Deprecated\n\n/**\n * @function\n * @deprecated since r168. Use {@link select} instead.\n *\n * @param  {...any} params\n * @returns {ConditionalNode}\n */\nconst cond = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ConditionalNode: cond() has been renamed to select().' );\n\treturn select( ...params );\n\n};\n\naddMethodChaining( 'cond', cond );\n\n/** @module ContextNode **/\n\n/**\n * This node can be used as a context management component for another node.\n * {@link NodeBuilder} performs its node building process in a specific context and\n * this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:\n *\n * ```js\n *node.context( { getUV: () => customCoord } );\n *```\n * @augments Node\n */\nclass ContextNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ContextNode';\n\n\t}\n\n\t/**\n\t * Constructs a new context node.\n\t *\n\t * @param {Node} node - The node whose context should be modified.\n\t * @param {Object} [value={}] - The modified context data.\n\t */\n\tconstructor( node, value = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isContextNode = true;\n\n\t\t/**\n\t\t * The node whose context should be modified.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The modified context data.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default {}\n\t\t */\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the reference to {@link module:ContextNode~ContextNode#node}.\n\t *\n\t * @return {Node} A reference to {@link module:ContextNode~ContextNode#node}.\n\t */\n\tgetScope() {\n\n\t\treturn this.node.getScope();\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the type of {@link module:ContextNode~ContextNode#node}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.node.build( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst node = this.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn node;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a context node.\n *\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {Object} [value={}] - The modified context data.\n * @returns {ContextNode}\n */\nconst context = /*@__PURE__*/ nodeProxy( ContextNode );\n\n/**\n * TSL function for defining a label context value for a given node.\n *\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {String} name - The name/label to set.\n * @returns {ContextNode}\n */\nconst label = ( node, name ) => context( node, { label: name } );\n\naddMethodChaining( 'context', context );\naddMethodChaining( 'label', label );\n\n/** @module VarNode **/\n\n/**\n * Class for representing shader variables as nodes. Variables are created from\n * existing nodes like the following:\n *\n * ```js\n * const depth = sampleDepth( uvNode ).toVar( 'depth' );\n * ```\n *\n * @augments Node\n */\nclass VarNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VarNode';\n\n\t}\n\n\t/**\n\t * Constructs a new variable node.\n\t *\n\t * @param {Node} node - The node for which a variable should be created.\n\t * @param {String?} name - The name of the variable in the shader.\n\t * @param {Boolean?} readOnly - The read-only flag.\n\t */\n\tconstructor( node, name = null, readOnly = false ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a variable should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the variable in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * `VarNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVarNode = true;\n\n\t\t/**\n\t\t *\n\t\t * The read-only flag.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.readOnly = readOnly;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.node.getMemberType( builder, name );\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { node, name, readOnly } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst isWebGPUBackend = renderer.backend.isWebGPUBackend === true;\n\n\t\tlet isDeterministic = false;\n\t\tlet shouldTreatAsReadOnly = false;\n\n\t\tif ( readOnly ) {\n\n\t\t\tisDeterministic = builder.isDeterministic( node );\n\n\t\t\tshouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;\n\n\t\t}\n\n\t\tconst vectorType = builder.getVectorType( this.getNodeType( builder ) );\n\t\tconst snippet = node.build( builder, vectorType );\n\n\t\tconst nodeVar = builder.getVarFromNode( this, name, vectorType, undefined, shouldTreatAsReadOnly );\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tlet declarationPrefix = propertyName;\n\n\t\tif ( shouldTreatAsReadOnly ) {\n\n\t\t\tif ( isWebGPUBackend ) {\n\n\t\t\t\tdeclarationPrefix = isDeterministic\n\t\t\t\t\t? `const ${ propertyName }`\n\t\t\t\t\t: `let ${ propertyName }`;\n\n\t\t\t} else {\n\n\t\t\t\tconst count = builder.getArrayCount( node );\n\n\t\t\t\tdeclarationPrefix = `const ${ builder.getVar( nodeVar.type, propertyName, count ) }`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.addLineFlowCode( `${ declarationPrefix } = ${ snippet }`, this );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a var node.\n *\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {String?} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst createVar = /*@__PURE__*/ nodeProxy( VarNode );\n\n/**\n * TSL function for creating a var node.\n *\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {String?} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst Var = ( node, name = null ) => createVar( node, name ).append();\n\n/**\n * TSL function for creating a const node.\n *\n * @function\n * @param {Node} node - The node for which a constant should be created.\n * @param {String?} name - The name of the constant in the shader.\n * @returns {VarNode}\n */\nconst Const = ( node, name = null ) => createVar( node, name, true ).append();\n\n// Method chaining\n\naddMethodChaining( 'toVar', Var );\naddMethodChaining( 'toConst', Const );\n\n// Deprecated\n\n/**\n * @function\n * @deprecated since r170. Use `Var( node )` or `node.toVar()` instead.\n *\n * @param {Any} node\n * @returns {VarNode}\n */\nconst temp = ( node ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: \"temp( node )\" is deprecated. Use \"Var( node )\" or \"node.toVar()\" instead.' );\n\n\treturn createVar( node );\n\n};\n\naddMethodChaining( 'temp', temp );\n\n/** @module VaryingNode **/\n\n/**\n * Class for representing shader varyings as nodes. Varyings are create from\n * existing nodes like the following:\n *\n * ```js\n * const positionLocal = positionGeometry.toVarying( 'vPositionLocal' );\n * ```\n *\n * @augments Node\n */\nclass VaryingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VaryingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new varying node.\n\t *\n\t * @param {Node} node - The node for which a varying should be created.\n\t * @param {String?} name - The name of the varying in the shader.\n\t */\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a varying should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the varying in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVaryingNode = true;\n\n\t}\n\n\t/**\n\t * The method is overwritten so it always returns `true`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryingNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method performs the setup of a varying node with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeVarying} The node varying from the node builder.\n\t */\n\tsetupVarying( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet varying = properties.varying;\n\n\t\tif ( varying === undefined ) {\n\n\t\t\tconst name = this.name;\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tproperties.varying = varying = builder.getVaryingFromNode( this, name, type );\n\t\t\tproperties.node = this.node;\n\n\t\t}\n\n\t\t// this property can be used to check if the varying can be optimized for a variable\n\t\tvarying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );\n\n\t\treturn varying;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\treturn this.node.analyze( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst varying = this.setupVarying( builder );\n\n\t\tconst needsReassign = builder.shaderStage === 'fragment' && properties.reassignPosition === true && builder.context.needsPositionReassign;\n\n\t\tif ( properties.propertyName === undefined || needsReassign ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );\n\n\t\t\t// force node run in vertex stage\n\t\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node, type, propertyName );\n\n\t\t\tproperties.propertyName = propertyName;\n\n\t\t\tif ( needsReassign ) {\n\n\t\t\t\t// once reassign varying in fragment stage\n\t\t\t\tproperties.reassignPosition = false;\n\n\t\t\t} else if ( properties.reassignPosition === undefined && builder.context.isPositionNodeInput ) {\n\n\t\t\t\tproperties.reassignPosition = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn builder.getPropertyName( varying );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a varying node.\n *\n * @function\n * @param {Node} node - The node for which a varying should be created.\n * @param {String?} name - The name of the varying in the shader.\n * @returns {VaryingNode}\n */\nconst varying = /*@__PURE__*/ nodeProxy( VaryingNode );\n\n/**\n * Computes a node in the vertex stage.\n *\n * @function\n * @param {Node} node - The node which should be executed in the vertex stage.\n * @returns {VaryingNode}\n */\nconst vertexStage = ( node ) => varying( node );\n\naddMethodChaining( 'toVarying', varying );\naddMethodChaining( 'toVertexStage', vertexStage );\n\n// Deprecated\n\naddMethodChaining( 'varying', ( ...params ) => { // @deprecated, r173\n\n\tconsole.warn( 'TSL.VaryingNode: .varying() has been renamed to .toVarying().' );\n\treturn varying( ...params );\n\n} );\n\naddMethodChaining( 'vertexStage', ( ...params ) => { // @deprecated, r173\n\n\tconsole.warn( 'TSL.VaryingNode: .vertexStage() has been renamed to .toVertexStage().' );\n\treturn varying( ...params );\n\n} );\n\n/** @module ColorSpaceFunctions **/\n\n/**\n * Converts the given color value from sRGB to linear-sRGB color space.\n *\n * @method\n * @param {Node<vec3>} color - The sRGB color.\n * @return {Node<vec3>} The linear-sRGB color.\n */\nconst sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );\n\tconst b = color.mul( 0.0773993808 );\n\tconst factor = color.lessThanEqual( 0.04045 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferEOTF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\n/**\n * Converts the given color value from linear-sRGB to sRGB color space.\n *\n * @method\n * @param {Node<vec3>} color - The linear-sRGB color.\n * @return {Node<vec3>} The sRGB color.\n */\nconst sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );\n\tconst b = color.mul( 12.92 );\n\tconst factor = color.lessThanEqual( 0.0031308 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferOETF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\n/** @module ColorSpaceNode **/\n\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\n\n/**\n * This node represents a color space conversion. Meaning it converts\n * a color value from a source to a target color space.\n *\n * @augments TempNode\n */\nclass ColorSpaceNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ColorSpaceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new color space node.\n\t *\n\t * @param {Node} colorNode - Represents the color to convert.\n\t * @param {String} source - The source color space.\n\t * @param {String} target - The target color space.\n\t */\n\tconstructor( colorNode, source, target ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * Represents the color to convert.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * The source color space.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.source = source;\n\n\t\t/**\n\t\t * The target color space.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.target = target;\n\n\t}\n\n\t/**\n\t * This method resolves the constants `WORKING_COLOR_SPACE` and\n\t * `OUTPUT_COLOR_SPACE` based on the current configuration of the\n\t * color management and renderer.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} colorSpace - The color space to resolve.\n\t * @return {String} The resolved color space.\n\t */\n\tresolveColorSpace( builder, colorSpace ) {\n\n\t\tif ( colorSpace === WORKING_COLOR_SPACE ) {\n\n\t\t\treturn ColorManagement.workingColorSpace;\n\n\t\t} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {\n\n\t\t\treturn builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode } = this;\n\n\t\tconst source = this.resolveColorSpace( builder, this.source );\n\t\tconst target = this.resolveColorSpace( builder, this.target );\n\n\t\tlet outputNode = colorNode;\n\n\t\tif ( ColorManagement.enabled === false || source === target || ! source || ! target ) {\n\n\t\t\treturn outputNode;\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\tif ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {\n\n\t\t\toutputNode = vec4(\n\t\t\t\tmat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),\n\t\t\t\toutputNode.a\n\t\t\t);\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for converting a given color node to the current output color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @returns {ColorSpaceNode}\n */\nconst toOutputColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE ) );\n\n/**\n * TSL function for converting a given color node to the current working color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @returns {ColorSpaceNode}\n */\nconst toWorkingColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE ) );\n\n/**\n * TSL function for converting a given color node from the current working color space to the given color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} colorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nconst workingToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, colorSpace ) );\n\n/**\n * TSL function for converting a given color node from the given color space to the current working color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} colorSpace - The source color space.\n * @returns {ColorSpaceNode}\n */\nconst colorSpaceToWorking = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), colorSpace, WORKING_COLOR_SPACE ) );\n\n/**\n * TSL function for converting a given color node from one color space to another one.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} sourceColorSpace - The source color space.\n * @param {String} targetColorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nconst convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );\n\naddMethodChaining( 'toOutputColorSpace', toOutputColorSpace );\naddMethodChaining( 'toWorkingColorSpace', toWorkingColorSpace );\n\naddMethodChaining( 'workingToColorSpace', workingToColorSpace );\naddMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/** @module ReferenceBaseNode **/\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nlet ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {ReferenceBaseNode?} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link module:ReferenceBaseNode~ReferenceBaseNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {ReferenceBaseNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @return {String} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n};\n\n/**\n * Base class for nodes which establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference base node.\n\t *\n\t * @param {String} property - The name of the property the node refers to.\n\t * @param {String} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {Object?} [object=null] - The object the property belongs to.\n\t * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<String>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceBaseNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {String} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tconst node = uniform( null, uniformType ).getSelf();\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tthis.node = node;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {Any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link module:ReferenceBaseNode~ReferenceBaseNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference base node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceBaseNode}\n */\nconst reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );\n\n/** @module RendererReferenceNode **/\n\n/**\n * This node is a special type of reference node which is intended\n * for linking renderer properties with node values.\n * ```js\n * const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );\n * ```\n * When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will\n * automatically be updated.\n *\n * @augments ReferenceBaseNode\n */\nclass RendererReferenceNode extends ReferenceBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'RendererReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new renderer reference node.\n\t *\n\t * @param {String} property - The name of the property the node refers to.\n\t * @param {String} inputType - The uniform type that should be used to represent the property value.\n\t * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n\t * the node refers to the renderer of the current state.\n\t */\n\tconstructor( property, inputType, renderer = null ) {\n\n\t\tsuper( property, inputType, renderer );\n\n\t\t/**\n\t\t * The renderer the property belongs to. When no renderer is set,\n\t\t * the node refers to the renderer of the current state.\n\t\t *\n\t\t * @type {Renderer?}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\tthis.setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Updates the reference based on the given state. The state is only evaluated\n\t * {@link module:RendererReferenceNode~RendererReferenceNode#renderer} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.renderer !== null ? this.renderer : state.renderer;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a renderer reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n * the node refers to the renderer of the current state.\n * @returns {RendererReferenceNode}\n */\nconst rendererReference = ( name, type, renderer = null ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );\n\n/** @module ToneMappingNode **/\n\n/**\n * This node represents a tone mapping operation.\n *\n * @augments TempNode\n */\nclass ToneMappingNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToneMappingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new tone mapping node.\n\t *\n\t * @param {Number} toneMapping - The tone mapping type.\n\t * @param {Node} exposureNode - The tone mapping exposure.\n\t * @param {Node} [colorNode=null] - The color node to process.\n\t */\n\tconstructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * The tone mapping type.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.toneMapping = toneMapping;\n\n\t\t/**\n\t\t * The tone mapping exposure.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.exposureNode = exposureNode;\n\n\t\t/**\n\t\t * Represents the color to process.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t}\n\n\t/**\n\t * Overwrites the default `customCacheKey()` implementation by including the tone\n\t * mapping type into the cache key.\n\t *\n\t * @return {Number} The hash.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn hash$1( this.toneMapping );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst colorNode = this.colorNode || builder.context.color;\n\t\tconst toneMapping = this.toneMapping;\n\n\t\tif ( toneMapping === NoToneMapping ) return colorNode;\n\n\t\tlet outputNode = null;\n\n\t\tconst toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );\n\n\t\tif ( toneMappingFn !== null ) {\n\n\t\t\toutputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );\n\n\t\t\toutputNode = colorNode;\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a tone mapping node.\n *\n * @function\n * @param {Number} mapping - The tone mapping type.\n * @param {Node<float> | Number} exposure - The tone mapping exposure.\n * @param {Node<vec3> | Color} color - The color node to process.\n * @returns {ToneMappingNode<vec3>}\n */\nconst toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );\n\n/**\n * TSL object that represents the global tone mapping exposure of the renderer.\n *\n * @type {RendererReferenceNode<vec3>}\n */\nconst toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );\n\naddMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );\n\n/** @module BufferAttributeNode **/\n\n/**\n * In earlier `three.js` versions it was only possible to define attribute data\n * on geometry level. With `BufferAttributeNode`, it is also possible to do this\n * on the node level.\n * ```js\n * const geometry = new THREE.PlaneGeometry();\n * const positionAttribute = geometry.getAttribute( 'position' );\n *\n * const colors = [];\n * for ( let i = 0; i < position.count; i ++ ) {\n * \tcolors.push( 1, 0, 0 );\n * }\n *\n * material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );\n * ```\n * This new approach is especially interesting when geometry data are generated via\n * compute shaders. The below line converts a storage buffer into an attribute node.\n * ```js\n * material.positionNode = positionBuffer.toAttribute();\n * ```\n * @augments InputNode\n */\nclass BufferAttributeNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferAttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer attribute node.\n\t *\n\t * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.\n\t * @param {String?} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {Number} [bufferStride=0] - The buffer stride.\n\t * @param {Number} [bufferOffset=0] - The buffer offset.\n\t */\n\tconstructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The buffer type (e.g. `'vec3'`).\n\t\t *\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The buffer stride.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferStride = bufferStride;\n\n\t\t/**\n\t\t * The buffer offset.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferOffset = bufferOffset;\n\n\t\t/**\n\t\t * The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,\n\t\t * if you are planning to update the attribute data per frame.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default StaticDrawUsage\n\t\t */\n\t\tthis.usage = StaticDrawUsage;\n\n\t\t/**\n\t\t * Whether the attribute is instanced or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.instanced = false;\n\n\t\t/**\n\t\t * A reference to the buffer attribute.\n\t\t *\n\t\t * @type {BufferAttribute?}\n\t\t * @default null\n\t\t */\n\t\tthis.attribute = null;\n\n\t\t/**\n\t\t * `BufferAttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value && value.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute = value;\n\t\t\tthis.usage = value.usage;\n\t\t\tthis.instanced = value.isInstancedBufferAttribute;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the attribute data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferStride === 0 && this.bufferOffset === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the buffer attribute.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.bufferType === null ) {\n\n\t\t\tthis.bufferType = builder.getTypeFromAttribute( this.attribute );\n\n\t\t}\n\n\t\treturn this.bufferType;\n\n\t}\n\n\t/**\n\t * Depending on which value was passed to the node, `setup()` behaves\n\t * differently. If no instance of `BufferAttribute` was passed, the method\n\t * creates an internal attribute and configures it respectively.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.attribute !== null ) return;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst array = this.value;\n\t\tconst itemSize = builder.getTypeLength( type );\n\t\tconst stride = this.bufferStride || itemSize;\n\t\tconst offset = this.bufferOffset;\n\n\t\tconst buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );\n\t\tconst bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );\n\n\t\tbuffer.setUsage( this.usage );\n\n\t\tthis.attribute = bufferAttribute;\n\t\tthis.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the buffer attribute node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tconst nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeAttribute );\n\n\t\tlet output = null;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\tthis.name = propertyName;\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'bufferAttribute';\n\n\t}\n\n\t/**\n\t * Sets the `usage` property to the given value.\n\t *\n\t * @param {Number} value - The usage to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\tif ( this.attribute && this.attribute.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute.usage = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the `instanced` property to the given value.\n\t *\n\t * @param {Boolean} value - The value to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetInstanced( value ) {\n\n\t\tthis.instanced = value;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a buffer attribute node.\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst bufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage.\n * Use this function if attribute data are updated per frame.\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst dynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );\n\n/**\n * TSL function for creating a buffer attribute node but with enabled instancing\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst instancedBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst instancedDynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );\n\naddMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );\n\n/** @module ComputeNode **/\n\n/**\n * TODO\n *\n * @augments Node\n */\nclass ComputeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new compute node.\n\t *\n\t * @param {Node} computeNode - TODO\n\t * @param {Number} count - TODO.\n\t * @param {Array<Number>} [workgroupSize=[64]] - TODO.\n\t */\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isComputeNode = true;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.computeNode = computeNode;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Array<Number>}\n\t\t * @default [64]\n\t\t */\n\t\tthis.workgroupSize = workgroupSize;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.dispatchCount = 0;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = 1;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since {@link ComputeNode#updateBefore}\n\t\t * is executed once per object by default.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.onInitFunction = null;\n\n\t\tthis.updateDispatchCount();\n\n\t}\n\n\t/**\n\t * Executes the `dispose` event for this node.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Sets the {@link ComputeNode#name} property.\n\t *\n\t * @param {String} name - The name of the uniform.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * TODO\n\t */\n\tupdateDispatchCount() {\n\n\t\tconst { count, workgroupSize } = this;\n\n\t\tlet size = workgroupSize[ 0 ];\n\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\tsize *= workgroupSize[ i ];\n\n\t\tthis.dispatchCount = Math.ceil( count / size );\n\n\t}\n\n\t/**\n\t * TODO\n\t *\n\t * @param {Function} callback - TODO.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tonInit( callback ) {\n\n\t\tthis.onInitFunction = callback;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The method execute the compute for this node.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a compute node.\n *\n * @function\n * @param {Node} node - TODO\n * @param {Number} count - TODO.\n * @param {Array<Number>} [workgroupSize=[64]] - TODO.\n * @returns {AtomicFunctionNode}\n */\nconst compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );\n\naddMethodChaining( 'compute', compute );\n\n/** @module CacheNode **/\n\n/**\n * This node can be used as a cache management component for another node.\n * Caching is in general used by default in {@link NodeBuilder} but this node\n * allows the usage of a shared parent cache during the build process.\n *\n * @augments Node\n */\nclass CacheNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CacheNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cache node.\n\t *\n\t * @param {Node} node - The node that should be cached.\n\t * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n\t */\n\tconstructor( node, parent = true ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be cached.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * Whether this node refers to a shared parent cache or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCacheNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst nodeType = this.node.getNodeType( builder );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn nodeType;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cache node.\n *\n * @function\n * @param {Node} node - The node that should be cached.\n * @param {Boolean} parent - Whether this node refers to a shared parent cache or not.\n * @returns {CacheNode}\n */\nconst cache = ( node, parent ) => nodeObject( new CacheNode( nodeObject( node ), parent ) );\n\naddMethodChaining( 'cache', cache );\n\n/** @module BypassNode **/\n\n/**\n * The class generates the code of a given node but returns another node in the output.\n * This can be used to call a method or node that does not return a value, i.e.\n * type `void` on an input where returning a value is required. Example:\n *\n * ```js\n * material.colorNode = myColor.bypass( runVoidFn() )\n *```\n *\n * @augments Node\n */\nclass BypassNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BypassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bypass node.\n\t *\n\t * @param {Node} outputNode - The output node.\n\t * @param {Node} callNode - The call node.\n\t */\n\tconstructor( outputNode, callNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBypassNode = true;\n\n\t\t/**\n\t\t * The output node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.outputNode = outputNode;\n\n\t\t/**\n\t\t * The call node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.callNode = callNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = this.callNode.build( builder, 'void' );\n\n\t\tif ( snippet !== '' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t}\n\n\t\treturn this.outputNode.build( builder );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a bypass node.\n *\n * @function\n * @param {Node} outputNode - The output node.\n * @param {Node} callNode - The call node.\n * @returns {BypassNode}\n */\nconst bypass = /*@__PURE__*/ nodeProxy( BypassNode );\n\naddMethodChaining( 'bypass', bypass );\n\n/** @module RemapNode **/\n\n/**\n * This node allows to remap a node value from one range into another. E.g a value of\n * `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.\n * `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.\n *\n * @augments Node\n */\nclass RemapNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RemapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new remap node.\n\t *\n\t * @param {Node} node - The node that should be remapped.\n\t * @param {Node} inLowNode - The source or current lower bound of the range.\n\t * @param {Node} inHighNode - The source or current upper bound of the range.\n\t * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n\t * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n\t */\n\tconstructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be remapped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The source or current lower bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inLowNode = inLowNode;\n\n\t\t/**\n\t\t * The source or current upper bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inHighNode = inHighNode;\n\n\t\t/**\n\t\t * The target lower bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default float(0)\n\t\t */\n\t\tthis.outLowNode = outLowNode;\n\n\t\t/**\n\t\t * The target upper bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default float(1)\n\t\t */\n\t\tthis.outHighNode = outHighNode;\n\n\t\t/**\n\t\t * Whether the node value should be clamped before\n\t\t * remapping it to the target range.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.doClamp = true;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;\n\n\t\tlet t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );\n\n\t\tif ( doClamp === true ) t = t.clamp();\n\n\t\treturn t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a remap node.\n *\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nconst remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } );\n\n/**\n * TSL function for creating a remap node, but with enabled clamping.\n *\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nconst remapClamp = /*@__PURE__*/ nodeProxy( RemapNode );\n\naddMethodChaining( 'remap', remap );\naddMethodChaining( 'remapClamp', remapClamp );\n\n/** @module ExpressionNode **/\n\n/**\n * This class can be used to implement basic expressions in shader code.\n * Basic examples for that are `return`, `continue` or `discard` statements.\n *\n * @augments Node\n */\nclass ExpressionNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ExpressionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new expression node.\n\t *\n\t * @param {String} [snippet=''] - The native code snippet.\n\t * @param {String} [nodeType='void'] - The node type.\n\t */\n\tconstructor( snippet = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The native code snippet.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.snippet = snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snippet = this.snippet;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t} else {\n\n\t\t\treturn builder.format( `( ${ snippet } )`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an expression node.\n *\n * @function\n * @param {String} [snippet=''] - The native code snippet.\n * @param {String} [nodeType='void'] - The node type.\n * @returns {ExpressionNode}\n */\nconst expression = /*@__PURE__*/ nodeProxy( ExpressionNode );\n\n/** @module Discard **/\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @method\n * @param {ConditionalNode?} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.\n * @return {Node} The `discard` expression.\n */\nconst Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).append();\n\n/**\n * Represents a `return` shader operation in TSL.\n *\n * @method\n * @return {ExpressionNode} The `return` expression.\n */\nconst Return = () => expression( 'return' ).append();\n\naddMethodChaining( 'discard', Discard );\n\n/** @module RenderOutputNode **/\n\n/**\n * Normally, tone mapping and color conversion happens automatically\n * before outputting pixel too the default (screen) framebuffer. In certain\n * post processing setups this happens to late because certain effects\n * require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used\n * to apply tone mapping and color space conversion at an arbitrary point\n * in the effect chain.\n *\n * When applying tone mapping and color space conversion manually with this node,\n * you have to set {@link PostProcessing#outputColorTransform} to `false`.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n * postProcessing.outputColorTransform = false;\n *\n * const scenePass = pass( scene, camera );\n * const outputPass = renderOutput( scenePass );\n *\n * postProcessing.outputNode = outputPass;\n * ```\n *\n * @augments TempNode\n */\nclass RenderOutputNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RenderOutputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new render output node.\n\t *\n\t * @param {Node} colorNode - The color node to process.\n\t * @param {Number} toneMapping - The tone mapping type.\n\t * @param {String} outputColorSpace - The output color space.\n\t */\n\tconstructor( colorNode, toneMapping, outputColorSpace ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The color node to process.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * The tone mapping type.\n\t\t *\n\t\t * @type {Number?}\n\t\t */\n\t\tthis.toneMapping = toneMapping;\n\n\t\t/**\n\t\t * The output color space.\n\t\t *\n\t\t * @type {String?}\n\t\t */\n\t\tthis.outputColorSpace = outputColorSpace;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderOutputNode = true;\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tlet outputNode = this.colorNode || context.color;\n\n\t\t// tone mapping\n\n\t\tconst toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;\n\t\tconst outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;\n\n\t\tif ( toneMapping !== NoToneMapping ) {\n\n\t\t\toutputNode = outputNode.toneMapping( toneMapping );\n\n\t\t}\n\n\t\t// working to output color space\n\n\t\tif ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {\n\n\t\t\toutputNode = outputNode.workingToColorSpace( outputColorSpace );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a posterize node.\n *\n * @function\n * @param {Node} color - The color node to process.\n * @param {Number?} [toneMapping=null] - The tone mapping type.\n * @param {String?} [outputColorSpace=null] - The output color space.\n * @returns {RenderOutputNode}\n */\nconst renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );\n\naddMethodChaining( 'renderOutput', renderOutput );\n\n// Non-PURE exports list, side-effects are required here.\n// TSL Base Syntax\n\n\nfunction addNodeElement( name/*, nodeElement*/ ) {\n\n\tconsole.warn( 'THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name );\n\n}\n\n/** @module AttributeNode **/\n\n/**\n * Base class for representing shader attributes as nodes.\n *\n * @augments Node\n */\nclass AttributeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new attribute node.\n\t *\n\t * @param {String} attributeName - The name of the attribute.\n\t * @param {String?} nodeType - The node type.\n\t */\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * `AttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = this.nodeType;\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Sets the attribute name to the given value. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {String} attributeName - The name of the attribute.\n\t * @return {AttributeNode} A reference to this node.\n\t */\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the attribute name of this node. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The attribute name.\n\t */\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._attributeName = this._attributeName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._attributeName = data._attributeName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an attribute node.\n *\n * @function\n * @param {String} name - The name of the attribute.\n * @param {String?} nodeType - The node type.\n * @returns {AttributeNode}\n */\nconst attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );\n\n/** @module UV **/\n\n/**\n * TSL function for creating an uv attribute node with the given index.\n *\n * @function\n * @param {Number} [index=0] - The uv index.\n * @return {AttributeNode<vec2>} The uv attribute node.\n */\nconst uv = ( index = 0 ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );\n\n/** @module TextureSizeNode **/\n\n/**\n * A node that represents the dimensions of a texture. The texture size is\n * retrieved in the shader via built-in shader functions like `textureDimensions()`\n * or `textureSize()`.\n *\n * @augments Node\n */\nclass TextureSizeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TextureSizeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new texture size node.\n\t *\n\t * @param {TextureNode} textureNode - A texture node which size should be retrieved.\n\t * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.\n\t */\n\tconstructor( textureNode, levelNode = null ) {\n\n\t\tsuper( 'uvec2' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTextureSizeNode = true;\n\n\t\t/**\n\t\t * A texture node which size should be retrieved.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * A level node which defines the requested mip.\n\t\t *\n\t\t * @type {Node<int>}\n\t\t * @default null\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst textureProperty = this.textureNode.build( builder, 'property' );\n\t\tconst level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );\n\n\t\treturn builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a texture size node.\n *\n * @function\n * @param {TextureNode} textureNode - A texture node which size should be retrieved.\n * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.\n * @returns {TextureSizeNode}\n */\nconst textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode );\n\n/** @module MatcapUVNode **/\n\n/**\n * A special type of uniform node that computes the\n * maximum mipmap level for a given texture node.\n *\n * ```js\n * const level = maxMipLevel( textureNode );\n * ```\n *\n * @augments module:UniformNode~UniformNode\n */\nclass MaxMipLevelNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaxMipLevelNode';\n\n\t}\n\n\t/**\n\t * Constructs a new max mip level node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node to compute the max mip level for.\n\t */\n\tconstructor( textureNode ) {\n\n\t\tsuper( 0 );\n\n\t\t/**\n\t\t * The texture node to compute the max mip level for.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * the texture once per frame in its {@link MaxMipLevelNode#update} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * The texture node to compute the max mip level for.\n\t *\n\t * @readonly\n\t * @type {TextureNode}\n\t */\n\tget textureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * The texture.\n\t *\n\t * @readonly\n\t * @type {Texture}\n\t */\n\tget texture() {\n\n\t\treturn this._textureNode.value;\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.texture;\n\t\tconst images = texture.images;\n\t\tconst image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;\n\n\t\tif ( image && image.width !== undefined ) {\n\n\t\t\tconst { width, height } = image;\n\n\t\t\tthis.value = Math.log2( Math.max( width, height ) );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a max mip level node.\n *\n * @function\n * @param {TextureNode} textureNode - The texture node to compute the max mip level for.\n * @returns {MaxMipLevelNode}\n */\nconst maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode );\n\n/** @module TextureNode **/\n\n/**\n * This type of uniform node represents a 2D texture.\n *\n * @augments module:UniformNode~UniformNode\n */\nclass TextureNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'TextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new texture node.\n\t *\n\t * @param {Texture} value - The texture.\n\t * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n\t * @param {Node<int>?} [levelNode=null] - The level node.\n\t * @param {Node<float>?} [biasNode=null] - The bias node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTextureNode = true;\n\n\t\t/**\n\t\t * Represents the texture coordinates.\n\t\t *\n\t\t * @type {Node<vec2|vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t * Represents the mip level that should be selected.\n\t\t *\n\t\t * @type {Node<int>?}\n\t\t * @default null\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t\t/**\n\t\t * Represents the bias to be applied during level-of-detail computation.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.biasNode = biasNode;\n\n\t\t/**\n\t\t * Represents a reference value a texture sample is compared to.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.compareNode = null;\n\n\t\t/**\n\t\t * When using texture arrays, the depth node defines the layer to select.\n\t\t *\n\t\t * @type {Node<int>?}\n\t\t * @default null\n\t\t */\n\t\tthis.depthNode = null;\n\n\t\t/**\n\t\t * When defined, a texture is sampled using explicit gradients.\n\t\t *\n\t\t * @type {Array<Node<vec2>>?}\n\t\t * @default null\n\t\t */\n\t\tthis.gradNode = null;\n\n\t\t/**\n\t\t * Whether texture values should be sampled or fetched.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sampler = true;\n\n\t\t/**\n\t\t * Whether the uv transformation matrix should be\n\t\t * automatically updated or not. Use `setUpdateMatrix()`\n\t\t * if you want to change the value of the property.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.updateMatrix = false;\n\n\t\t/**\n\t\t * By default the `update()` method is not executed. `setUpdateMatrix()`\n\t\t * sets the value to `frame` when the uv transformation matrix should\n\t\t * automatically be updated.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The reference node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = null;\n\n\t\t/**\n\t\t * The texture value is stored in a private property.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture}\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * The uniform node that represents the uv transformation matrix.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat3>?}\n\t\t */\n\t\tthis._matrixUniform = null;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tset value( value ) {\n\n\t\tif ( this.referenceNode ) {\n\n\t\t\tthis.referenceNode.value = value;\n\n\t\t} else {\n\n\t\t\tthis._value = value;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The texture value.\n\t *\n\t * @type {Texture}\n\t */\n\tget value() {\n\n\t\treturn this.referenceNode ? this.referenceNode.value : this._value;\n\n\t}\n\n\t/**\n\t * Overwritten since the uniform hash is defined by the texture's UUID.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The uniform hash.\n\t */\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the texture type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\tif ( this.value.type === UnsignedIntType ) {\n\n\t\t\treturn 'uvec4';\n\n\t\t} else if ( this.value.type === IntType ) {\n\n\t\t\treturn 'ivec4';\n\n\t\t}\n\n\t\treturn 'vec4';\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'texture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\t/**\n\t * Returns a default uvs based on the current texture's channel.\n\t *\n\t * @return {AttributeNode<vec2>} The default uvs.\n\t */\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\t/**\n\t * Overwritten to always return the texture reference of the node.\n\t *\n\t * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {Texture} The texture reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\t/**\n\t * Transforms the given uv node with the texture transformation matrix.\n\t *\n\t * @param {Node} uvNode - The uv node to transform.\n\t * @return {Node} The transformed uv node.\n\t */\n\tgetTransformedUV( uvNode ) {\n\n\t\tif ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );\n\n\t\treturn this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\t/**\n\t * Defines whether the uv transformation matrix should automatically be updated or not.\n\t *\n\t * @param {Boolean} value - The update toggle.\n\t * @return {TextureNode} A reference to this node.\n\t */\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.RENDER : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary\n\t * to modify the uv node for correct sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The updated uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = uvNode.flipY();\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\t/**\n\t * Setups texture node by preparing the internal nodes for code generation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.referenceNode = this.referenceNode;\n\n\t\t//\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().' );\n\n\t\t}\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.biasNode = this.biasNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.gradNode = this.gradNode;\n\t\tproperties.depthNode = this.depthNode;\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to generate code for.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\t/**\n\t * Generates the snippet for the texture sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} textureProperty - The texture property.\n\t * @param {String} uvSnippet - The uv snippet.\n\t * @param {String?} levelSnippet - The level snippet.\n\t * @param {String?} biasSnippet - The bias snippet.\n\t * @param {String?} depthSnippet - The depth snippet.\n\t * @param {String?} compareSnippet - The compare snippet.\n\t * @param {Array<String>?} gradSnippet - The grad snippet.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );\n\n\t\t} else if ( biasSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );\n\n\t\t} else if ( gradSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the texture node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} output - The current output.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst texture = this.value;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\t\t\t\tconst gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsToWorkingColorSpace( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the sampler value.\n\t *\n\t * @param {Boolean} value - The sampler value to set.\n\t * @return {TextureNode} A reference to this texture node.\n\t */\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the sampler value.\n\t *\n\t * @return {Boolean} The sampler value.\n\t */\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\t/**\n\t * @function\n\t * @deprecated since r172. Use {@link TextureNode#sample} instead.\n\t *\n\t * @param {Node} uvNode - The uv node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tuv( uvNode ) { // @deprecated, r172\n\n\t\tconsole.warn( 'THREE.TextureNode: .uv() has been renamed. Use .sample() instead.' );\n\n\t\treturn this.sample( uvNode );\n\n\t}\n\n\t/**\n\t * Samples the texture with the given uv node.\n\t *\n\t * @param {Node} uvNode - The uv node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tsample( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = nodeObject( uvNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples a blurred version of the texture by defining an internal bias.\n\t *\n\t * @param {Node<float>} amountNode - How blurred the texture should be.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tblur( amountNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples a specific mip of the texture.\n\t *\n\t * @param {Node<int>} levelNode - The mip level to sample.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = nodeObject( levelNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Returns the texture size of the requested level.\n\t *\n\t * @param {Node<int>} levelNode - The level to compute the size for.\n\t * @return {TextureSizeNode} The texture size.\n\t */\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\t/**\n\t * Samples the texture with the given bias.\n\t *\n\t * @param {Node<float>} biasNode - The bias node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tbias( biasNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( biasNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture by executing a compare operation.\n\t *\n\t * @param {Node<float>} compareNode - The node that defines the compare value.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture using an explicit gradient.\n\t *\n\t * @param {Node<vec2>} gradNodeX - The gradX node.\n\t * @param {Node<vec2>} gradNodeY - The gradY node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tgrad( gradNodeX, gradNodeY ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture by defining a depth node.\n\t *\n\t * @param {Node<int>} depthNode - The depth node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\t\tdata.sampler = this.sampler;\n\t\tdata.updateMatrix = this.updateMatrix;\n\t\tdata.updateType = this.updateType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\t\tthis.sampler = data.sampler;\n\t\tthis.updateMatrix = data.updateMatrix;\n\t\tthis.updateType = data.updateType;\n\n\t}\n\n\t/**\n\t * The update is used to implement the update of the uv transformation matrix.\n\t */\n\tupdate() {\n\n\t\tconst texture = this.value;\n\t\tconst matrixUniform = this._matrixUniform;\n\n\t\tif ( matrixUniform !== null ) matrixUniform.value = texture.matrix;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Clones the texture node.\n\t *\n\t * @return {TextureNode} The cloned texture node.\n\t */\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );\n\t\tnewNode.sampler = this.sampler;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a texture node.\n *\n * @function\n * @param {Texture} value - The texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst texture = /*@__PURE__*/ nodeProxy( TextureNode );\n\n/**\n * TSL function for creating a texture node that fetches/loads texels without interpolation.\n *\n * @function\n * @param {Texture} value - The texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\n/**\n * Converts a texture or texture node to a sampler.\n *\n * @function\n * @param {TextureNode|Texture} aTexture - The texture or texture node to convert.\n * @returns {Node}\n */\nconst sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );\n\n/** @module BufferNode **/\n\n/**\n * A special type of uniform node which represents array-like data\n * as uniform buffers. The access usually happens via `element()`\n * which returns an instance of {@link ArrayElementNode}. For example:\n *\n * ```js\n * const bufferNode = buffer( array, 'mat4', count );\n * const matrixNode = bufferNode.element( index ); // access a matrix from the buffer\n * ```\n * In general, it is recommended to use the more managed {@link UniformArrayNode}\n * since it handles more input types and automatically cares about buffer paddings.\n *\n * @augments module:UniformNode~UniformNode\n */\nclass BufferNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {Array<Number>} value - Array-like buffer data.\n\t * @param {String} bufferType - The data type of the buffer.\n\t * @param {Number} [bufferCount=0] - The count of buffer elements.\n\t */\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The data type of the buffer.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\t/**\n\t * The data type of the buffer elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The element type.\n\t */\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'buffer'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\n/**\n * TSL function for creating a buffer node.\n *\n * @function\n * @param {Array} value - Array-like buffer data.\n * @param {String} type - The data type of a buffer element.\n * @param {Number} count - The count of buffer elements.\n * @returns {BufferNode}\n */\nconst buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );\n\n/** @module UniformArrayNode **/\n\n/**\n * Represents the element access on uniform array nodes.\n *\n * @augments ArrayElementNode\n */\nclass UniformArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.\n\t * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.\n\t */\n\tconstructor( uniformArrayNode, indexNode ) {\n\n\t\tsuper( uniformArrayNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferElementNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst type = this.getNodeType();\n\t\tconst paddedType = this.node.getPaddedType();\n\n\t\treturn builder.format( snippet, paddedType, type );\n\n\t}\n\n}\n\n/**\n * Similar to {@link module:BufferNode~BufferNode} this module represents array-like data as\n * uniform buffers. Unlike {@link module:BufferNode~BufferNode}, it can handle more common\n * data types in the array (e.g `three.js` primitives) and automatically\n * manage buffer padding. It should be the first choice when working with\n * uniforms buffers.\n * ```js\n * const tintColors = uniformArray( [\n * \tnew Color( 1, 0, 0 ),\n * \tnew Color( 0, 1, 0 ),\n * \tnew Color( 0, 0, 1 )\n * ], 'color' );\n *\n * const redColor = tintColors.element( 0 );\n *\n * @augments module:BufferNode~BufferNode\n */\nclass UniformArrayNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform array node.\n\t *\n\t * @param {Array<Any>} value - Array holding the buffer data.\n\t * @param {String?} [elementType=null] - The data type of a buffer element.\n\t */\n\tconstructor( value, elementType = null ) {\n\n\t\tsuper( null );\n\n\t\t/**\n\t\t * Array holding the buffer data. Unlike {@link module:BufferNode~BufferNode}, the array can\n\t\t * hold number primitives as well as three.js objects like vectors, matrices\n\t\t * or colors.\n\t\t *\n\t\t * @type {Array<Any>}\n\t\t */\n\t\tthis.array = value;\n\n\t\t/**\n\t\t * The data type of an array element.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.elementType = elementType === null ? getValueType( value[ 0 ] ) : elementType;\n\n\t\t/**\n\t\t * The padded type. Uniform buffers must conform to a certain buffer layout\n\t\t * so a separate type is computed to ensure correct buffer size.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.paddedType = this.getPaddedType();\n\n\t\t/**\n\t\t * Overwritten since uniform array nodes are updated per render.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the\n\t * {@link module:UniformArrayNode~UniformArrayNode#paddedType}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.paddedType;\n\n\t}\n\n\t/**\n\t * The data type of the array elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The element type.\n\t */\n\tgetElementType() {\n\n\t\treturn this.elementType;\n\n\t}\n\n\t/**\n\t * Returns the padded type based on the element type.\n\t *\n\t * @return {String} The padded type.\n\t */\n\tgetPaddedType() {\n\n\t\tconst elementType = this.elementType;\n\n\t\tlet paddedType = 'vec4';\n\n\t\tif ( elementType === 'mat2' ) {\n\n\t\t\tpaddedType = 'mat2';\n\n\t\t} else if ( /mat/.test( elementType ) === true ) {\n\n\t\t\tpaddedType = 'mat4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'i' ) {\n\n\t\t\tpaddedType = 'ivec4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'u' ) {\n\n\t\t\tpaddedType = 'uvec4';\n\n\t\t}\n\n\t\treturn paddedType;\n\n\t}\n\n\t/**\n\t * The update makes sure to correctly transfer the data from the (complex) objects\n\t * in the array to the internal, correctly padded value buffer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { array, value } = this;\n\n\t\tconst elementType = this.elementType;\n\n\t\tif ( elementType === 'float' || elementType === 'int' || elementType === 'uint' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\n\t\t\t\tvalue[ index ] = array[ i ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'color' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.r;\n\t\t\t\tvalue[ index + 1 ] = vector.g;\n\t\t\t\tvalue[ index + 2 ] = vector.b || 0;\n\t\t\t\t//value[ index + 3 ] = vector.a || 0;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat2' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\t\t\t\tvalue[ index + 3 ] = matrix.elements[ 3 ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat3' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\n\t\t\t\tvalue[ index + 4 ] = matrix.elements[ 3 ];\n\t\t\t\tvalue[ index + 5 ] = matrix.elements[ 4 ];\n\t\t\t\tvalue[ index + 6 ] = matrix.elements[ 5 ];\n\n\t\t\t\tvalue[ index + 8 ] = matrix.elements[ 6 ];\n\t\t\t\tvalue[ index + 9 ] = matrix.elements[ 7 ];\n\t\t\t\tvalue[ index + 10 ] = matrix.elements[ 8 ];\n\n\t\t\t\tvalue[ index + 15 ] = 1;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat4' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tfor ( let i = 0; i < matrix.elements.length; i ++ ) {\n\n\t\t\t\t\tvalue[ index + i ] = matrix.elements[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.x;\n\t\t\t\tvalue[ index + 1 ] = vector.y;\n\t\t\t\tvalue[ index + 2 ] = vector.z || 0;\n\t\t\t\tvalue[ index + 3 ] = vector.w || 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Implement the value buffer creation based on the array data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {null}\n\t */\n\tsetup( builder ) {\n\n\t\tconst length = this.array.length;\n\t\tconst elementType = this.elementType;\n\n\t\tlet arrayType = Float32Array;\n\n\t\tconst paddedType = this.paddedType;\n\t\tconst paddedElementLength = builder.getTypeLength( paddedType );\n\n\t\tif ( elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;\n\t\tif ( elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;\n\n\t\tthis.value = new arrayType( length * paddedElementLength );\n\t\tthis.bufferCount = length;\n\t\tthis.bufferType = paddedType;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default `element()` method to provide element access\n\t * based on {@link module:UniformArrayNode~UniformArrayNode}.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {UniformArrayElementNode}\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an uniform array node.\n *\n * @function\n * @param {Array<Any>} values - Array-like data.\n * @param {String?} nodeType - The data type of the array elements.\n * @returns {UniformArrayNode}\n */\nconst uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );\n\n/**\n * @function\n * @deprecated since r168. Use {@link uniformArray} instead.\n *\n * @param {Array<Any>} values - Array-like data.\n * @param {String} nodeType - The data type of the array elements.\n * @returns {UniformArrayNode}\n */\nconst uniforms = ( values, nodeType ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().' );\n\treturn nodeObject( new UniformArrayNode( values, nodeType ) );\n\n};\n\n/** @module Camera **/\n\n/**\n * TSL object that represents the current `index` value of the camera if used ArrayCamera.\n *\n * @type {UniformNode<uint>}\n */\nconst cameraIndex = /*@__PURE__*/ uniform( 0, 'uint' ).setGroup( sharedUniformGroup( 'cameraIndex' ) ).toVarying( 'v_cameraIndex' );\n\n/**\n * TSL object that represents the `near` value of the camera used for the current render.\n *\n * @type {UniformNode<float>}\n */\nconst cameraNear = /*@__PURE__*/ uniform( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );\n\n/**\n * TSL object that represents the `far` value of the camera used for the current render.\n *\n * @type {UniformNode<float>}\n */\nconst cameraFar = /*@__PURE__*/ uniform( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );\n\n/**\n * TSL object that represents the projection matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraProjectionMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraProjectionMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.projectionMatrix );\n\n\t\t}\n\n\t\tconst cameraProjectionMatrices = uniformArray( matrices ).setGroup( renderGroup ).label( 'cameraProjectionMatrices' );\n\n\t\tcameraProjectionMatrix = cameraProjectionMatrices.element( cameraIndex ).toVar( 'cameraProjectionMatrix' );\n\n\t} else {\n\n\t\tcameraProjectionMatrix = uniform( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );\n\n\t}\n\n\treturn cameraProjectionMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the inverse projection matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraProjectionMatrixInverse = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );\n\n/**\n * TSL object that represents the view matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraViewMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraViewMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.matrixWorldInverse );\n\n\t\t}\n\n\t\tconst cameraViewMatrices = uniformArray( matrices ).setGroup( renderGroup ).label( 'cameraViewMatrices' );\n\n\t\tcameraViewMatrix = cameraViewMatrices.element( cameraIndex ).toVar( 'cameraViewMatrix' );\n\n\t} else {\n\n\t\tcameraViewMatrix = uniform( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );\n\n\t}\n\n\treturn cameraViewMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the world matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraWorldMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );\n\n/**\n * TSL object that represents the normal matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat3>}\n */\nconst cameraNormalMatrix = /*@__PURE__*/ uniform( 'mat3' ).label( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );\n\n/**\n * TSL object that represents the position in world space of the camera used for the current render.\n *\n * @type {UniformNode<vec3>}\n */\nconst cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );\n\n/** @module Object3DNode **/\n\n/**\n * This node can be used to access transformation related metrics of 3D objects.\n * Depending on the selected scope, a different metric is represented as a uniform\n * in the shader. The following scopes are supported:\n *\n * - `POSITION`: The object's position in world space.\n * - `VIEW_POSITION`: The object's position in view/camera space.\n * - `DIRECTION`: The object's direction in world space.\n * - `SCALE`: The object's scale in world space.\n * - `WORLD_MATRIX`: The object's matrix in world space.\n *\n * @augments Node\n */\nclass Object3DNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'Object3DNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object 3D node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t * @param {Object3D?} [object3d=null] - The 3D object.\n\t */\n\tconstructor( scope, object3d = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node reports a different type of transformation depending on the scope.\n\t\t *\n\t\t * @type {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D?}\n\t\t * @default null\n\t\t */\n\t\tthis.object3d = object3d;\n\n\t\t/**\n\t\t * Overwritten since this type of node is updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Holds the value of the node as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._uniformNode = new UniformNode( null );\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the scope.\n\t *\n\t * @return {String} The node type.\n\t */\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\treturn 'vec3';\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.SCALE ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixScale( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.DIRECTION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tobject.getWorldDirection( uniformNode.value );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tconst camera = frame.camera;\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the uniform node. The node type of the uniform\n\t * node also depends on the selected scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\tthis._uniformNode.nodeType = 'vec3';\n\n\t\t}\n\n\t\treturn this._uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\n\n/**\n * TSL function for creating an object 3D node that represents the object's direction in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION );\n\n/**\n * TSL function for creating an object 3D node that represents the object's world matrix.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<mat4>}\n */\nconst objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION );\n\n/**\n * TSL function for creating an object 3D node that represents the object's scale in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE );\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in view/camera space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );\n\n/** @module ModelNode **/\n\n/**\n * This type of node is a specialized version of `Object3DNode`\n * with larger set of model related metrics. Unlike `Object3DNode`,\n * `ModelNode` extracts the reference to the 3D object from the\n * current node frame state.\n *\n * @augments module:Object3DNode~Object3DNode\n */\nclass ModelNode extends Object3DNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object model node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\t/**\n\t * Extracts the model reference from the frame state and then\n\t * updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tthis.object3d = frame.object;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\n/**\n * TSL object that represents the object's direction in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );\n\n/**\n * TSL object that represents the object's world matrix.\n *\n * @type {ModelNode<mat4>}\n */\nconst modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\n\n/**\n * TSL object that represents the object's position in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );\n\n/**\n * TSL object that represents the object's scale in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );\n\n/**\n * TSL object that represents the object's position in view/camera space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\n\n/**\n * TSL object that represents the object's normal matrix.\n *\n * @type {UniformNode<mat3>}\n */\nconst modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );\n\n/**\n * TSL object that represents the object's inverse world matrix.\n *\n * @type {UniformNode<mat4>}\n */\nconst modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );\n\n/**\n * TSL object that represents the object's model view matrix.\n *\n * @type {Node<mat4>}\n */\nconst modelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.renderer.nodes.modelViewMatrix || mediumpModelViewMatrix;\n\n} ).once() )().toVar( 'modelViewMatrix' );\n\n// GPU Precision\n\n/**\n * TSL object that represents the object's model view in `mediump` precision.\n *\n * @type {Node<mat4>}\n */\nconst mediumpModelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix );\n\n// CPU Precision\n\n/**\n * TSL object that represents the object's model view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @type {Node<mat4>}\n */\nconst highpModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tbuilder.context.isHighPrecisionModelViewMatrix = true;\n\n\treturn uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\treturn object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelViewMatrix' );\n\n/**\n * TSL object that represents the object's model normal view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @type {Node<mat3>}\n */\nconst highpModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tconst isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n\n\treturn uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\tif ( isHighPrecisionModelViewMatrix !== true ) {\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t}\n\n\t\treturn object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelNormalViewMatrix' );\n\n/** @module Position **/\n\n/**\n * TSL object that represents the position attribute of the current rendered object.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );\n\n/**\n * TSL object that represents the vertex position in local space of the current rendered object.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionLocal = /*@__PURE__*/ positionGeometry.toVarying( 'positionLocal' );\n\n/**\n * TSL object that represents the previous vertex position in local space of the current rendered object.\n * Used in context of {@link module:VelocityNode~VelocityNode} for rendering motion vectors.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionPrevious = /*@__PURE__*/ positionGeometry.toVarying( 'positionPrevious' );\n\n/**\n * TSL object that represents the vertex position in world space of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionWorld = /*@__PURE__*/ modelWorldMatrix.mul( positionLocal ).xyz.toVarying( 'v_positionWorld' ).context( { needsPositionReassign: true } );\n\n/**\n * TSL object that represents the position world direction of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst positionWorldDirection = /*@__PURE__*/ positionLocal.transformDirection( modelWorldMatrix ).toVarying( 'v_positionWorldDirection' ).normalize().toVar( 'positionWorldDirection' ).context( { needsPositionReassign: true } );\n\n/**\n * TSL object that represents the vertex position in view space of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupPositionView();\n\n}, 'vec3' ).once() )().toVarying( 'v_positionView' ).context( { needsPositionReassign: true } );\n\n/**\n * TSL object that represents the position view direction of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionViewDirection = /*@__PURE__*/ positionView.negate().toVarying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );\n\n/** @module FrontFacingNode **/\n\n/**\n * This node can be used to evaluate whether a primitive is front or back facing.\n *\n * @augments Node\n */\nclass FrontFacingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FrontFacingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new front facing node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'bool' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isFrontFacingNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { renderer, material } = builder;\n\n\t\tif ( renderer.coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\treturn 'false';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn builder.getFrontFacing();\n\n\t}\n\n}\n\n/**\n * TSL object that represents whether a primitive is front or back facing\n *\n * @type {FrontFacingNode<bool>}\n */\nconst frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );\n\n/**\n * TSL object that represents the front facing status as a number instead of a bool.\n * `1` means front facing, `-1` means back facing.\n *\n * @type {Node<float>}\n */\nconst faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );\n\n/** @module Normal **/\n\n/**\n * TSL object that represents the normal attribute of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );\n\n/**\n * TSL object that represents the vertex normal in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\tconsole.warn( 'TSL.NormalNode: Vertex attribute \"normal\" not found on geometry.' );\n\n\t\treturn vec3( 0, 1, 0 );\n\n\t}\n\n\treturn normalGeometry;\n\n}, 'vec3' ).once() )().toVar( 'normalLocal' );\n\n/**\n * TSL object that represents the flat vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );\n\n/**\n * TSL object that represents the vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tlet node;\n\n\tif ( builder.material.flatShading === true ) {\n\n\t\tnode = normalFlat;\n\n\t} else {\n\n\t\tnode = varying( transformNormalToView( normalLocal ), 'v_normalView' ).normalize();\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once() )().toVar( 'normalView' );\n\n/**\n * TSL object that represents the vertex normal in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalWorld = /*@__PURE__*/ varying( normalView.transformDirection( cameraViewMatrix ), 'v_normalWorld' ).normalize().toVar( 'normalWorld' );\n\n/**\n * TSL object that represents the transformed vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\t// Use getUV context to avoid side effects from nodes overwriting getUV in the context (e.g. EnvironmentNode)\n\n\treturn builder.context.setupNormal().context( { getUV: null } );\n\n}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedNormalView' );\n\n/**\n * TSL object that represents the transformed vertex normal in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedNormalWorld = /*@__PURE__*/ transformedNormalView.transformDirection( cameraViewMatrix ).toVar( 'transformedNormalWorld' );\n\n/**\n * TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedClearcoatNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\t// Use getUV context to avoid side effects from nodes overwriting getUV in the context (e.g. EnvironmentNode)\n\n\treturn builder.context.setupClearcoatNormal().context( { getUV: null } );\n\n}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedClearcoatNormalView' );\n\n/**\n * Transforms the normal with the given matrix.\n *\n * @function\n * @param {Node<vec3>} normal - The normal.\n * @param {Node<mat3>} [matrix=modelWorldMatrix] - The matrix.\n * @return {Node<vec3>} The transformed normal.\n */\nconst transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {\n\n\tconst m = mat3( matrix );\n\n\tconst transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );\n\n\treturn m.mul( transformedNormal ).xyz;\n\n} );\n\n/**\n * Transforms the given normal from local to view space.\n *\n * @function\n * @param {Node<vec3>} normal - The normal.\n * @param {NodeBuilder} builder - The current node builder.\n * @return {Node<vec3>} The transformed normal.\n */\nconst transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {\n\n\tconst modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;\n\n\tif ( modelNormalViewMatrix !== null ) {\n\n\t\treturn modelNormalViewMatrix.transformDirection( normal );\n\n\t}\n\n\t//\n\n\tconst transformedNormal = modelNormalMatrix.mul( normal );\n\n\treturn cameraViewMatrix.transformDirection( transformedNormal );\n\n} );\n\n/** @module MaterialProperties **/\n\n/**\n * TSL object that represents the refraction ratio of the material used for rendering the current object.\n *\n * @type {UniformNode<float>}\n */\nconst materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onRenderUpdate( ( { material } ) => material.refractionRatio );\n\n/** @module ReflectVector **/\n\n/**\n * The reflect vector in view space.\n *\n * @type {Node<vec3>}\n */\nconst reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( transformedNormalView );\n\n/**\n * The refract vector in view space.\n *\n * @type {Node<vec3>}\n */\nconst refractView = /*@__PURE__*/ positionViewDirection.negate().refract( transformedNormalView, materialRefractionRatio );\n\n/**\n * Used for sampling cube maps when using cube reflection mapping.\n *\n * @type {Node<vec3>}\n */\nconst reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\n\n/**\n * Used for sampling cube maps when using cube refraction mapping.\n *\n * @type {Node<vec3>}\n */\nconst refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\n\n/** @module CubeTextureNode **/\n\n/**\n * This type of uniform node represents a cube texture.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass CubeTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cube texture node.\n\t *\n\t * @param {CubeTexture} value - The cube texture.\n\t * @param {Node<vec3>?} [uvNode=null] - The uv node.\n\t * @param {Node<int>?} [levelNode=null] - The level node.\n\t * @param {Node<float>?} [biasNode=null] - The bias node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode, biasNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCubeTextureNode = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'cubeTexture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'cubeTexture';\n\n\t}\n\n\t/**\n\t * Returns a default uvs based on the mapping type of the cube texture.\n\t *\n\t * @return {Node<vec3>} The default uv attribute.\n\t */\n\tgetDefaultUV() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.mapping === CubeReflectionMapping ) {\n\n\t\t\treturn reflectVector;\n\n\t\t} else if ( texture.mapping === CubeRefractionMapping ) {\n\n\t\t\treturn refractVector;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.CubeTextureNode: Mapping \"%s\" not supported.', texture.mapping );\n\n\t\t\treturn vec3( 0, 0, 0 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten with an empty implementation since the `updateMatrix` flag is ignored\n\t * for cube textures. The uv transformation matrix is not applied to cube textures.\n\t *\n\t * @param {Boolean} value - The update toggle.\n\t */\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode\n\n\t/**\n\t * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary\n\t * to modify the uv node for correct sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The updated uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {\n\n\t\t\treturn vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t} else {\n\n\t\t\treturn uvNode;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} cubeUV - The uv node to generate code for.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerateUV( builder, cubeUV ) {\n\n\t\treturn cubeUV.build( builder, 'vec3' );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cube texture node.\n *\n * @function\n * @param {CubeTexture} value - The cube texture.\n * @param {Node<vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {CubeTextureNode}\n */\nconst cubeTexture = /*@__PURE__*/ nodeProxy( CubeTextureNode );\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/** @module ReferenceNode **/\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nclass ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {ReferenceNode?} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link module:ReferenceNode~ReferenceNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {ReferenceNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @return {String} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n}\n\n/**\n * This type of node establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference node.\n\t *\n\t * @param {String} property - The name of the property the node refers to.\n\t * @param {String} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {Object?} [object=null] - The object the property belongs to.\n\t * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<String>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * An optional label of the internal uniform node.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.name = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the label for the internal uniform.\n\t *\n\t * @param {String} name - The label to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {String} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.count !== null ) {\n\n\t\t\tnode = buffer( null, uniformType, this.count );\n\n\t\t} else if ( Array.isArray( this.getValueFromReference() ) ) {\n\n\t\t\tnode = uniformArray( null, uniformType );\n\n\t\t} else if ( uniformType === 'texture' ) {\n\n\t\t\tnode = texture( null );\n\n\t\t} else if ( uniformType === 'cubeTexture' ) {\n\n\t\t\tnode = cubeTexture( null );\n\n\t\t} else {\n\n\t\t\tnode = uniform( null, uniformType );\n\n\t\t}\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tif ( this.name !== null ) node.label( this.name );\n\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {Any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link module:ReferenceNode~ReferenceNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceNode}\n */\nconst reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );\n\n/**\n * TSL function for creating a reference node. Use this function if you want need a reference\n * to an array-like property that should be represented as a uniform buffer.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Number} count - The number of value inside the array-like object.\n * @param {Object} object - An array-like object the property belongs to.\n * @returns {ReferenceNode}\n */\nconst referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );\n\n/** @module MaterialReferenceNode **/\n\n/**\n * This node is a special type of reference node which is intended\n * for linking material properties with node values.\n * ```js\n * const opacityNode = materialReference( 'opacity', 'float', material );\n * ```\n * When changing `material.opacity`, the node value of `opacityNode` will\n * automatically be updated.\n *\n * @augments module:ReferenceNode~ReferenceNode\n */\nclass MaterialReferenceNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new material reference node.\n\t *\n\t * @param {String} property - The name of the property the node refers to.\n\t * @param {String} inputType - The uniform type that should be used to represent the property value.\n\t * @param {Material?} [material=null] - The material the property belongs to. When no material is set,\n\t * the node refers to the material of the current rendered object.\n\t */\n\tconstructor( property, inputType, material = null ) {\n\n\t\tsuper( property, inputType, material );\n\n\t\t/**\n\t\t * The material the property belongs to. When no material is set,\n\t\t * the node refers to the material of the current rendered object.\n\t\t *\n\t\t * @type {Material?}\n\t\t * @default null\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMaterialReferenceNode = true;\n\n\t}\n\n\t/**\n\t * Updates the reference based on the given state. The state is only evaluated\n\t * {@link module:MaterialReferenceNode~MaterialReferenceNode#material} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.material !== null ? this.material : state.material;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a material reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Material?} [material=null] - The material the property belongs to.\n * When no material is set, the node refers to the material of the current rendered object.\n * @returns {MaterialReferenceNode}\n */\nconst materialReference = ( name, type, material = null ) => nodeObject( new MaterialReferenceNode( name, type, material ) );\n\n/** @module Tangent **/\n\n/**\n * TSL object that represents the tangent attribute of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'tangent' ) === false ) {\n\n\t\tbuilder.geometry.computeTangents();\n\n\t}\n\n\treturn attribute( 'tangent', 'vec4' );\n\n} )();\n\n/**\n * TSL object that represents the vertex tangent in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );\n\n/**\n * TSL object that represents the vertex tangent in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentView = /*@__PURE__*/ modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.toVarying( 'v_tangentView' ).normalize().toVar( 'tangentView' );\n\n/**\n * TSL object that represents the vertex tangent in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentWorld = /*@__PURE__*/ tangentView.transformDirection( cameraViewMatrix ).toVarying( 'v_tangentWorld' ).normalize().toVar( 'tangentWorld' );\n\n/**\n * TSL object that represents the transformed vertex tangent in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedTangentView = /*@__PURE__*/ tangentView.toVar( 'transformedTangentView' );\n\n/**\n * TSL object that represents the transformed vertex tangent in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedTangentWorld = /*@__PURE__*/ transformedTangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedTangentWorld' );\n\n/** @module Bitangent **/\n\nconst getBitangent = ( crossNormalTangent ) => crossNormalTangent.mul( tangentGeometry.w ).xyz;\n\n/**\n * TSL object that represents the bitangent attribute of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst bitangentGeometry = /*@__PURE__*/ varying( getBitangent( normalGeometry.cross( tangentGeometry ) ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );\n\n/**\n * TSL object that represents the vertex bitangent in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst bitangentLocal = /*@__PURE__*/ varying( getBitangent( normalLocal.cross( tangentLocal ) ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );\n\n/**\n * TSL object that represents the vertex bitangent in view space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst bitangentView = /*@__PURE__*/ varying( getBitangent( normalView.cross( tangentView ) ), 'v_bitangentView' ).normalize().toVar( 'bitangentView' );\n\n/**\n * TSL object that represents the vertex bitangent in world space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst bitangentWorld = /*@__PURE__*/ varying( getBitangent( normalWorld.cross( tangentWorld ) ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );\n\n/**\n * TSL object that represents the transformed vertex bitangent in view space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst transformedBitangentView = /*@__PURE__*/ getBitangent( transformedNormalView.cross( transformedTangentView ) ).normalize().toVar( 'transformedBitangentView' );\n\n/**\n * TSL object that represents the transformed vertex bitangent in world space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst transformedBitangentWorld = /*@__PURE__*/ transformedBitangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedBitangentWorld' );\n\n/** @module AccessorsUtils **/\n\n/**\n * TSL object that represents the TBN matrix in view space.\n *\n * @type {Node<mat3>}\n */\nconst TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView );\n\n/**\n * TSL object that represents the parallax direction.\n *\n * @type {Node<mat3>}\n */\nconst parallaxDirection = /*@__PURE__*/ positionViewDirection.mul( TBNViewMatrix )/*.normalize()*/;\n\n/**\n * TSL function for computing parallax uv coordinates.\n *\n * @function\n * @param {Node<vec2>} uv - A uv node.\n * @param {Node<vec2>} scale - A scale node.\n * @returns {Node<vec2>} Parallax uv coordinates.\n */\nconst parallaxUV = ( uv, scale ) => uv.sub( parallaxDirection.mul( scale ) );\n\n/**\n * TSL function for computing bent normals.\n *\n * @function\n * @returns {Node<vec3>} Bent normals.\n */\nconst transformedBentNormalView = /*@__PURE__*/ ( () => {\n\n\t// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n\n\tlet bentNormal = anisotropyB.cross( positionViewDirection );\n\tbentNormal = bentNormal.cross( anisotropyB ).normalize();\n\tbentNormal = mix( bentNormal, transformedNormalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();\n\n\treturn bentNormal;\n\n\n} )();\n\n/** @module NormalMapNode **/\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2Arb = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { eye_pos, surf_norm, mapN, uv } = inputs;\n\n\tconst q0 = eye_pos.dFdx();\n\tconst q1 = eye_pos.dFdy();\n\tconst st0 = uv.dFdx();\n\tconst st1 = uv.dFdy();\n\n\tconst N = surf_norm; // normalized\n\n\tconst q1perp = q1.cross( N );\n\tconst q0perp = N.cross( q0 );\n\n\tconst T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );\n\tconst B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );\n\n\tconst det = T.dot( T ).max( B.dot( B ) );\n\tconst scale = faceDirection.mul( det.inverseSqrt() );\n\n\treturn add( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();\n\n} );\n\n/**\n * This class can be used for applying normals maps to materials.\n *\n * ```js\n * material.normalNode = normalMap( texture( normalTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass NormalMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'NormalMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new normal map node.\n\t *\n\t * @param {Node<vec3>} node - Represents the normal map data.\n\t * @param {Node<vec2>?} [scaleNode=null] - Controls the intensity of the effect.\n\t */\n\tconstructor( node, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Represents the normal map data.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * Controls the intensity of the effect.\n\t\t *\n\t\t * @type {Node<vec2>?}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t\t/**\n\t\t * The normal map type.\n\t\t *\n\t\t * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}\n\t\t * @default TangentSpaceNormalMap\n\t\t */\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { normalMapType, scaleNode } = this;\n\n\t\tlet normalMap = this.node.mul( 2.0 ).sub( 1.0 );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tnormalMap = vec3( normalMap.xy.mul( scaleNode ), normalMap.z );\n\n\t\t}\n\n\t\tlet outputNode = null;\n\n\t\tif ( normalMapType === ObjectSpaceNormalMap ) {\n\n\t\t\toutputNode = transformNormalToView( normalMap );\n\n\t\t} else if ( normalMapType === TangentSpaceNormalMap ) {\n\n\t\t\tconst tangent = builder.hasGeometryAttribute( 'tangent' );\n\n\t\t\tif ( tangent === true ) {\n\n\t\t\t\toutputNode = TBNViewMatrix.mul( normalMap ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\toutputNode = perturbNormal2Arb( {\n\t\t\t\t\teye_pos: positionView,\n\t\t\t\t\tsurf_norm: normalView,\n\t\t\t\t\tmapN: normalMap,\n\t\t\t\t\tuv: uv()\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a normal map node.\n *\n * @function\n * @param {Node<vec3>} node - Represents the normal map data.\n * @param {Node<vec2>?} [scaleNode=null] - Controls the intensity of the effect.\n * @returns {NormalMapNode}\n */\nconst normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode );\n\n/** @module BumpMapNode **/\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {\n\n\t// It's used to preserve the same TextureNode instance\n\tconst sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv() ), forceUVContext: true } );\n\n\tconst Hll = float( sampleTexture( ( uvNode ) => uvNode ) );\n\n\treturn vec2(\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )\n\t).mul( bumpScale );\n\n} );\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = Fn( ( inputs ) => {\n\n\tconst { surf_pos, surf_norm, dHdxy } = inputs;\n\n\t// normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n\tconst vSigmaX = surf_pos.dFdx().normalize();\n\tconst vSigmaY = surf_pos.dFdy().normalize();\n\tconst vN = surf_norm; // normalized\n\n\tconst R1 = vSigmaY.cross( vN );\n\tconst R2 = vN.cross( vSigmaX );\n\n\tconst fDet = vSigmaX.dot( R1 ).mul( faceDirection );\n\n\tconst vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );\n\n\treturn fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();\n\n} );\n\n/**\n * This class can be used for applying bump maps to materials.\n *\n * ```js\n * material.normalNode = bumpMap( texture( bumpTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass BumpMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'BumpMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bump map node.\n\t *\n\t * @param {Node<float>} textureNode - Represents the bump map data.\n\t * @param {Node<float>?} [scaleNode=null] - Controls the intensity of the bump effect.\n\t */\n\tconstructor( textureNode, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Represents the bump map data.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * Controls the intensity of the bump effect.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n\t\tconst dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );\n\n\t\treturn perturbNormalArb( {\n\t\t\tsurf_pos: positionView,\n\t\t\tsurf_norm: normalView,\n\t\t\tdHdxy\n\t\t} );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a bump map node.\n *\n * @function\n * @param {Node<float>} textureNode - Represents the bump map data.\n * @param {Node<float>?} [scaleNode=null] - Controls the intensity of the bump effect.\n * @returns {BumpMapNode}\n */\nconst bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode );\n\n/** @module MaterialNode **/\n\nconst _propertyCache = new Map();\n\n/**\n * This class should simplify the node access to material properties.\n * It internal uses reference nodes to make sure  changes to material\n * properties are automatically reflected to predefined TSL objects\n * like e.g. `materialColor`.\n *\n * @augments Node\n */\nclass MaterialNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialNode';\n\n\t}\n\n\t/**\n\t * Constructs a new material node.\n\t *\n\t * @param {String} scope - The scope defines what kind of material property is referred by the node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scope defines what material property is referred by the node.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Returns a cached reference node for the given property and type.\n\t *\n\t * @param {String} property - The name of the material property.\n\t * @param {String} type - The uniform type of the property.\n\t * @return {MaterialReferenceNode} A material reference node representing the property access.\n\t */\n\tgetCache( property, type ) {\n\n\t\tlet node = _propertyCache.get( property );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = materialReference( property, type );\n\n\t\t\t_propertyCache.set( property, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Returns a float-typed material reference node for the given property name.\n\t *\n\t * @param {String} property - The name of the material property.\n\t * @return {MaterialReferenceNode<float>} A material reference node representing the property access.\n\t */\n\tgetFloat( property ) {\n\n\t\treturn this.getCache( property, 'float' );\n\n\t}\n\n\t/**\n\t * Returns a color-typed material reference node for the given property name.\n\t *\n\t * @param {String} property - The name of the material property.\n\t * @return {MaterialReferenceNode<color>} A material reference node representing the property access.\n\t */\n\tgetColor( property ) {\n\n\t\treturn this.getCache( property, 'color' );\n\n\t}\n\n\t/**\n\t * Returns a texture-typed material reference node for the given property name.\n\t *\n\t * @param {String} property - The name of the material property.\n\t * @return {MaterialReferenceNode} A material reference node representing the property access.\n\t */\n\tgetTexture( property ) {\n\n\t\treturn this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );\n\n\t}\n\n\t/**\n\t * The node setup is done depending on the selected scope. Multiple material properties\n\t * might be grouped into a single node composition if they logically belong together.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The node representing the selected scope.\n\t */\n\tsetup( builder ) {\n\n\t\tconst material = builder.context.material;\n\t\tconst scope = this.scope;\n\n\t\tlet node = null;\n\n\t\tif ( scope === MaterialNode.COLOR ) {\n\n\t\t\tconst colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();\n\n\t\t\tif ( material.map && material.map.isTexture === true ) {\n\n\t\t\t\tnode = colorNode.mul( this.getTexture( 'map' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = colorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\tconst opacityNode = this.getFloat( scope );\n\n\t\t\tif ( material.alphaMap && material.alphaMap.isTexture === true ) {\n\n\t\t\t\tnode = opacityNode.mul( this.getTexture( 'alpha' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = opacityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {\n\n\t\t\tif ( material.specularMap && material.specularMap.isTexture === true ) {\n\n\t\t\t\tnode = this.getTexture( 'specular' ).r;\n\n\t\t\t} else {\n\n\t\t\t\tnode = float( 1 );\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {\n\n\t\t\tconst specularIntensityNode = this.getFloat( scope );\n\n\t\t\tif ( material.specularIntensityMap && material.specularIntensityMap.isTexture === true ) {\n\n\t\t\t\tnode = specularIntensityNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularIntensityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_COLOR ) {\n\n\t\t\tconst specularColorNode = this.getColor( scope );\n\n\t\t\tif ( material.specularColorMap && material.specularColorMap.isTexture === true ) {\n\n\t\t\t\tnode = specularColorNode.mul( this.getTexture( scope ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularColorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches\n\n\t\t\tconst roughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.roughnessMap && material.roughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = roughnessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = roughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.METALNESS ) {\n\n\t\t\tconst metalnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.metalnessMap && material.metalnessMap.isTexture === true ) {\n\n\t\t\t\tnode = metalnessNode.mul( this.getTexture( scope ).b );\n\n\t\t\t} else {\n\n\t\t\t\tnode = metalnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\n\n\t\t\tconst emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );\n\t\t\tconst emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );\n\n\t\t\tif ( material.emissiveMap && material.emissiveMap.isTexture === true ) {\n\n\t\t\t\tnode = emissiveNode.mul( this.getTexture( scope ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = emissiveNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.NORMAL ) {\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );\n\t\t\t\tnode.normalMapType = material.normalMapType;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tnode = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT ) {\n\n\t\t\tconst clearcoatNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {\n\n\t\t\tconst clearcoatRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatRoughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN ) {\n\n\t\t\tconst sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU\n\n\t\t\tif ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {\n\n\t\t\tconst sheenRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenRoughnessNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenRoughnessNode;\n\n\t\t\t}\n\n\t\t\tnode = node.clamp( 0.07, 1.0 );\n\n\t\t} else if ( scope === MaterialNode.ANISOTROPY ) {\n\n\t\t\tif ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {\n\n\t\t\t\tconst anisotropyPolar = this.getTexture( scope );\n\t\t\t\tconst anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );\n\n\t\t\t\tnode = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = materialAnisotropyVector;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {\n\n\t\t\tconst iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tconst iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );\n\n\t\t\t\tnode = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );\n\n\t\t\t} else {\n\n\t\t\t\tnode = iridescenceThicknessMaximum;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.TRANSMISSION ) {\n\n\t\t\tconst transmissionNode = this.getFloat( scope );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tnode = transmissionNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = transmissionNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.THICKNESS ) {\n\n\t\t\tconst thicknessNode = this.getFloat( scope );\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tnode = thicknessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = thicknessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IOR ) {\n\n\t\t\tnode = this.getFloat( scope );\n\n\t\t} else if ( scope === MaterialNode.LIGHT_MAP ) {\n\n\t\t\tnode = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );\n\n\t\t} else if ( scope === MaterialNode.AO ) {\n\n\t\t\tnode = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );\n\n\t\t} else {\n\n\t\t\tconst outputType = this.getNodeType( builder );\n\n\t\t\tnode = this.getCache( scope, outputType );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_SIZE = 'size';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO = 'ao';\n\n/**\n * TSL object that represents alpha test of the current material.\n *\n * @type {Node<float>}\n */\nconst materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\n\n/**\n * TSL object that represents the diffuse color of the current material.\n * The value is composed via `color` * `map`.\n *\n * @type {Node<vec3>}\n */\nconst materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );\n\n/**\n * TSL object that represents the shininess of the current material.\n *\n * @type {Node<float>}\n */\nconst materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );\n\n/**\n * TSL object that represents the emissive color of the current material.\n * The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.\n *\n * @type {Node<vec3>}\n */\nconst materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );\n\n/**\n * TSL object that represents the opacity of the current material.\n * The value is composed via `opacity` * `alphaMap`.\n *\n * @type {Node<float>}\n */\nconst materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );\n\n/**\n * TSL object that represents the specular of the current material.\n *\n * @type {Node<vec3>}\n */\nconst materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\n\n/**\n * TSL object that represents the specular intensity of the current material.\n * The value is composed via `specularIntensity` * `specularMap.a`.\n *\n * @type {Node<float>}\n */\nconst materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );\n\n/**\n * TSL object that represents the specular color of the current material.\n * The value is composed via `specularColor` * `specularMap.rgb`.\n *\n * @type {Node<vec3>}\n */\nconst materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );\n\n/**\n * TSL object that represents the specular strength of the current material.\n * The value is composed via `specularMap.r`.\n *\n * @type {Node<float>}\n */\nconst materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );\n\n/**\n * TSL object that represents the reflectivity of the current material.\n *\n * @type {Node<float>}\n */\nconst materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );\n\n/**\n * TSL object that represents the roughness of the current material.\n * The value is composed via `roughness` * `roughnessMap.g`.\n *\n * @type {Node<float>}\n */\nconst materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\n\n/**\n * TSL object that represents the metalness of the current material.\n * The value is composed via `metalness` * `metalnessMap.b`.\n *\n * @type {Node<float>}\n */\nconst materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );\n\n/**\n * TSL object that represents the normal of the current material.\n * The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.\n *\n * @type {Node<vec3>}\n */\nconst materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL );\n\n/**\n * TSL object that represents the clearcoat of the current material.\n * The value is composed via `clearcoat` * `clearcoatMap.r`\n *\n * @type {Node<float>}\n */\nconst materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );\n\n/**\n * TSL object that represents the clearcoat roughness of the current material.\n * The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`.\n *\n * @type {Node<float>}\n */\nconst materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );\n\n/**\n * TSL object that represents the clearcoat normal of the current material.\n * The value will be either `clearcoatNormalMap` or `normalView`.\n *\n * @type {Node<vec3>}\n */\nconst materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL );\n\n/**\n * TSL object that represents the rotation of the current sprite material.\n *\n * @type {Node<float>}\n */\nconst materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );\n\n/**\n * TSL object that represents the sheen color of the current material.\n * The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.\n *\n * @type {Node<vec3>}\n */\nconst materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );\n\n/**\n * TSL object that represents the sheen roughness of the current material.\n * The value is composed via `sheenRoughness` * `sheenRoughnessMap.a`.\n *\n * @type {Node<float>}\n */\nconst materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );\n\n/**\n * TSL object that represents the anisotropy of the current material.\n *\n * @type {Node<vec2>}\n */\nconst materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );\n\n/**\n * TSL object that represents the iridescence of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );\n\n/**\n * TSL object that represents the iridescence IOR of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );\n\n/**\n * TSL object that represents the iridescence thickness of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );\n\n/**\n * TSL object that represents the transmission of the current material.\n * The value is composed via `transmission` * `transmissionMap.r`.\n *\n * @type {Node<float>}\n */\nconst materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );\n\n/**\n * TSL object that represents the thickness of the current material.\n * The value is composed via `thickness` * `thicknessMap.g`.\n *\n * @type {Node<float>}\n */\nconst materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );\n\n/**\n * TSL object that represents the IOR of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );\n\n/**\n * TSL object that represents the attenuation distance of the current material.\n *\n * @type {Node<float>}\n */\nconst materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );\n\n/**\n * TSL object that represents the attenuation color of the current material.\n *\n * @type {Node<vec3>}\n */\nconst materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );\n\n/**\n * TSL object that represents the scale of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );\n\n/**\n * TSL object that represents the dash size of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );\n\n/**\n * TSL object that represents the gap size of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );\n\n/**\n * TSL object that represents the line width of the current line material.\n *\n * @type {Node<float>}\n */\nconst materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );\n\n/**\n * TSL object that represents the dash offset of the current line material.\n *\n * @type {Node<float>}\n */\nconst materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );\n\n/**\n * TSL object that represents the point size of the current points material.\n *\n * @type {Node<float>}\n */\nconst materialPointSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_SIZE );\n\n/**\n * TSL object that represents the dispersion of the current material.\n *\n * @type {Node<float>}\n */\nconst materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );\n\n/**\n * TSL object that represents the light map of the current material.\n * The value is composed via `lightMapIntensity` * `lightMap.rgb`.\n *\n * @type {Node<vec3>}\n */\nconst materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );\n\n/**\n * TSL object that represents the ambient occlusion map of the current material.\n * The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.\n *\n * @type {Node<float>}\n */\nconst materialAO = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO );\n\n/**\n * TSL object that represents the anisotropy vector of the current material.\n *\n * @type {Node<vec2>}\n */\nconst materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {\n\n\treturn frame.material;\n\n} ).onRenderUpdate( function ( { material } ) {\n\n\tthis.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n} );\n\n/** @module ModelViewProjectionNode **/\n\n/**\n * TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.\n *\n * @type {VaryingNode<vec4>}\n */\nconst modelViewProjection = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupModelViewProjection();\n\n}, 'vec4' ).once() )().toVarying( 'v_modelViewProjection' );\n\n/** @module IndexNode **/\n\n/**\n * This class represents shader indices of different types. The following predefined node\n * objects cover frequent use cases:\n *\n * - `vertexIndex`: The index of a vertex within a mesh.\n * - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.\n * - `drawIndex`: The index of a draw call.\n * - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.\n * - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.\n * - `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.\n *\n * @augments Node\n */\nclass IndexNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'IndexNode';\n\n\t}\n\n\t/**\n\t * Constructs a new index node.\n\t *\n\t * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( 'uint' );\n\n\t\t/**\n\t\t * The scope of the index node.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isIndexNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst scope = this.scope;\n\n\t\tlet propertyName;\n\n\t\tif ( scope === IndexNode.VERTEX ) {\n\n\t\t\tpropertyName = builder.getVertexIndex();\n\n\t\t} else if ( scope === IndexNode.INSTANCE ) {\n\n\t\t\tpropertyName = builder.getInstanceIndex();\n\n\t\t} else if ( scope === IndexNode.DRAW ) {\n\n\t\t\tpropertyName = builder.getDrawIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_LOCAL ) {\n\n\t\t\tpropertyName = builder.getInvocationLocalIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {\n\n\t\t\tpropertyName = builder.getInvocationSubgroupIndex();\n\n\t\t} else if ( scope === IndexNode.SUBGROUP ) {\n\n\t\t\tpropertyName = builder.getSubgroupIndex();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.IndexNode: Unknown scope: ' + scope );\n\n\t\t}\n\n\t\tlet output;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\n\n/**\n * TSL object that represents the index of a vertex within a mesh.\n *\n * @type {IndexNode}\n */\nconst vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );\n\n/**\n * TSL object that represents the index of either a mesh instance or an invocation of a compute shader.\n *\n * @type {IndexNode}\n */\nconst instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );\n\n/**\n * TSL object that represents the index of the subgroup the current compute invocation belongs to.\n *\n * @type {IndexNode}\n */\nconst subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a subgroup.\n *\n * @type {IndexNode}\n */\nconst invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a workgroup load.\n *\n * @type {IndexNode}\n */\nconst invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );\n\n/**\n * TSL object that represents the index of a draw call.\n *\n * @type {IndexNode}\n */\nconst drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );\n\n/** @module InstanceNode **/\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via instancing. The code makes sure\n * vertex positions, normals and colors can be modified via instanced\n * data.\n *\n * @augments Node\n */\nclass InstanceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InstanceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new instance node.\n\t *\n\t * @param {Number} count - The number of instances.\n\t * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n\t * @param {InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n\t */\n\tconstructor( count, instanceMatrix, instanceColor ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The number of instances.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * Instanced buffer attribute representing the transformation of instances.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceMatrix = instanceMatrix;\n\n\t\t/**\n\t\t * Instanced buffer attribute representing the color of instances.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceColor = instanceColor;\n\n\t\t/**\n\t\t * The node that represents the instance matrix data.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.instanceMatrixNode = null;\n\n\t\t/**\n\t\t * The node that represents the instance color data.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.instanceColorNode = null;\n\n\t\t/**\n\t\t * The update type is set to `frame` since an update\n\t\t * of instanced buffer data must be checked per frame.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A reference to a buffer that is used by `instanceMatrixNode`.\n\t\t *\n\t\t * @type {InstancedInterleavedBuffer}\n\t\t */\n\t\tthis.buffer = null;\n\n\t\t/**\n\t\t * A reference to a buffer that is used by `instanceColorNode`.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.bufferColor = null;\n\n\t}\n\n\t/**\n\t * Setups the internal buffers and nodes and assigns the transformed vertex data\n\t * to predefined node variables for accumulation. That follows the same patterns\n\t * like with morph and skinning nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = this;\n\n\t\tlet { instanceMatrixNode, instanceColorNode } = this;\n\n\t\tif ( instanceMatrixNode === null ) {\n\n\t\t\t// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n\t\t\tif ( count <= 1000 ) {\n\n\t\t\t\tinstanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );\n\n\t\t\t} else {\n\n\t\t\t\tconst buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );\n\n\t\t\t\tthis.buffer = buffer;\n\n\t\t\t\tconst bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\t\tconst instanceBuffers = [\n\t\t\t\t\t// F.Signature -> bufferAttribute( array, type, stride, offset )\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 0 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 4 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 8 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 12 )\n\t\t\t\t];\n\n\t\t\t\tinstanceMatrixNode = mat4( ...instanceBuffers );\n\n\t\t\t}\n\n\t\t\tthis.instanceMatrixNode = instanceMatrixNode;\n\n\t\t}\n\n\t\tif ( instanceColor && instanceColorNode === null ) {\n\n\t\t\tconst buffer = new InstancedBufferAttribute( instanceColor.array, 3 );\n\n\t\t\tconst bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\tthis.bufferColor = buffer;\n\n\t\t\tinstanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );\n\n\t\t\tthis.instanceColorNode = instanceColorNode;\n\n\t\t}\n\n\t\t// POSITION\n\n\t\tconst instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;\n\t\tpositionLocal.assign( instancePosition );\n\n\t\t// NORMAL\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst instanceNormal = transformNormal( normalLocal, instanceMatrixNode );\n\n\t\t\t// ASSIGNS\n\n\t\t\tnormalLocal.assign( instanceNormal );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tif ( this.instanceColorNode !== null ) {\n\n\t\t\tvaryingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if the internal buffers required an update.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tif ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version ) {\n\n\t\t\tthis.buffer.version = this.instanceMatrix.version;\n\n\t\t}\n\n\t\tif ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version ) {\n\n\t\t\tthis.bufferColor.version = this.instanceColor.version;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance node.\n *\n * @function\n * @param {Number} count - The number of instances.\n * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n * @param {InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n * @returns {InstanceNode}\n */\nconst instance = /*@__PURE__*/ nodeProxy( InstanceNode );\n\n/** @module InstancedMeshNode **/\n\n/**\n * This is a special version of `InstanceNode` which requires the usage of {@link InstancedMesh}.\n * It allows an easier setup of the instance node.\n *\n * @augments module:InstanceNode~InstanceNode\n */\nclass InstancedMeshNode extends InstanceNode {\n\n\tstatic get type() {\n\n\t\treturn 'InstancedMeshNode';\n\n\t}\n\n\t/**\n\t * Constructs a new instanced mesh node.\n\t *\n\t * @param {InstancedMesh} instancedMesh - The instanced mesh.\n\t */\n\tconstructor( instancedMesh ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = instancedMesh;\n\n\t\tsuper( count, instanceMatrix, instanceColor );\n\n\t\t/**\n\t\t * A reference to the instanced mesh.\n\t\t *\n\t\t * @type {InstancedMesh}\n\t\t */\n\t\tthis.instancedMesh = instancedMesh;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instanced mesh node.\n *\n * @function\n * @param {InstancedMesh} instancedMesh - The instancedMesh.\n * @returns {InstancedMeshNode}\n */\nconst instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode );\n\n/** @module BatchNode **/\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via batching. `BatchNode` must be used\n * with instances of {@link BatchedMesh}.\n *\n * @augments Node\n */\nclass BatchNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BatchNode';\n\n\t}\n\n\t/**\n\t * Constructs a new batch node.\n\t *\n\t * @param {BatchedMesh} batchMesh - A reference to batched mesh.\n\t */\n\tconstructor( batchMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * A reference to batched mesh.\n\t\t *\n\t\t * @type {BatchedMesh}\n\t\t */\n\t\tthis.batchMesh = batchMesh;\n\n\t\t/**\n\t\t * The batching index node.\n\t\t *\n\t\t * @type {IndexNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.batchingIdNode = null;\n\n\t}\n\n\t/**\n\t * Setups the internal buffers and nodes and assigns the transformed vertex data\n\t * to predefined node variables for accumulation. That follows the same patterns\n\t * like with morph and skinning nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.batchingIdNode === null ) {\n\n\t\t\tif ( builder.getDrawIndex() === null ) {\n\n\t\t\t\tthis.batchingIdNode = instanceIndex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.batchingIdNode = drawIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getIndirectIndex = Fn( ( [ id ] ) => {\n\n\t\t\tconst size = int( textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 ) );\n\t\t\tconst x = int( id ).modInt( size );\n\t\t\tconst y = int( id ).div( size );\n\t\t\treturn textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;\n\n\t\t} ).setLayout( {\n\t\t\tname: 'getIndirectIndex',\n\t\t\ttype: 'uint',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t]\n\t\t} );\n\n\t\tconst indirectId = getIndirectIndex( int( this.batchingIdNode ) );\n\n\t\tconst matricesTexture = this.batchMesh._matricesTexture;\n\n\t\tconst size = textureSize( textureLoad( matricesTexture ), 0 );\n\t\tconst j = float( indirectId ).mul( 4 ).toInt().toVar();\n\n\t\tconst x = j.modInt( size );\n\t\tconst y = j.div( int( size ) );\n\t\tconst batchingMatrix = mat4(\n\t\t\ttextureLoad( matricesTexture, ivec2( x, y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )\n\t\t);\n\n\n\t\tconst colorsTexture = this.batchMesh._colorsTexture;\n\n\t\tif ( colorsTexture !== null ) {\n\n\t\t\tconst getBatchingColor = Fn( ( [ id ] ) => {\n\n\t\t\t\tconst size = textureSize( textureLoad( colorsTexture ), 0 ).x;\n\t\t\t\tconst j = id;\n\t\t\t\tconst x = j.modInt( size );\n\t\t\t\tconst y = j.div( size );\n\t\t\t\treturn textureLoad( colorsTexture, ivec2( x, y ) ).rgb;\n\n\t\t\t} ).setLayout( {\n\t\t\t\tname: 'getBatchingColor',\n\t\t\t\ttype: 'vec3',\n\t\t\t\tinputs: [\n\t\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t\t]\n\t\t\t} );\n\n\t\t\tconst color = getBatchingColor( indirectId );\n\n\t\t\tvaryingProperty( 'vec3', 'vBatchColor' ).assign( color );\n\n\t\t}\n\n\t\tconst bm = mat3( batchingMatrix );\n\n\t\tpositionLocal.assign( batchingMatrix.mul( positionLocal ) );\n\n\t\tconst transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );\n\n\t\tconst batchingNormal = bm.mul( transformedNormal ).xyz;\n\n\t\tnormalLocal.assign( batchingNormal );\n\n\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\ttangentLocal.mulAssign( bm );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a batch node.\n *\n * @function\n * @param {BatchedMesh} batchMesh - A reference to batched mesh.\n * @returns {BatchNode}\n */\nconst batch = /*@__PURE__*/ nodeProxy( BatchNode );\n\n/** @module SkinningNode **/\n\nconst _frameId = new WeakMap();\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for skinning/skeletal animation.\n *\n * @augments Node\n */\nclass SkinningNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SkinningNode';\n\n\t}\n\n\t/**\n\t * Constructs a new skinning node.\n\t *\n\t * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n\t * @param {Boolean} [useReference=false] - Whether to use reference nodes for internal skinned mesh related data or not.\n\t */\n\tconstructor( skinnedMesh, useReference = false ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The skinned mesh.\n\t\t *\n\t\t * @type {SkinnedMesh}\n\t\t */\n\t\tthis.skinnedMesh = skinnedMesh;\n\n\t\t/**\n\t\t * Whether to use reference nodes for internal skinned mesh related data or not.\n\t\t * TODO: Explain the purpose of the property.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.useReference = useReference;\n\n\t\t/**\n\t\t * The update type overwritten since skinning nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t//\n\n\t\t/**\n\t\t * The skin index attribute.\n\t\t *\n\t\t * @type {AttributeNode}\n\t\t */\n\t\tthis.skinIndexNode = attribute( 'skinIndex', 'uvec4' );\n\n\t\t/**\n\t\t * The skin weight attribute.\n\t\t *\n\t\t * @type {AttributeNode}\n\t\t */\n\t\tthis.skinWeightNode = attribute( 'skinWeight', 'vec4' );\n\n\t\tlet bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;\n\n\t\tif ( useReference ) {\n\n\t\t\tbindMatrixNode = reference( 'bindMatrix', 'mat4' );\n\t\t\tbindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );\n\t\t\tboneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t} else {\n\n\t\t\tbindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );\n\t\t\tbindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );\n\t\t\tboneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\t/**\n\t\t * The bind matrix node.\n\t\t *\n\t\t * @type {Node<mat4>}\n\t\t */\n\t\tthis.bindMatrixNode = bindMatrixNode;\n\n\t\t/**\n\t\t * The bind matrix inverse node.\n\t\t *\n\t\t * @type {Node<mat4>}\n\t\t */\n\t\tthis.bindMatrixInverseNode = bindMatrixInverseNode;\n\n\t\t/**\n\t\t * The bind matrices as a uniform buffer node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.boneMatricesNode = boneMatricesNode;\n\n\t\t/**\n\t\t * The previous bind matrices as a uniform buffer node.\n\t\t * Required for computing motion vectors.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.previousBoneMatricesNode = null;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex position via skinning.\n\t *\n\t * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n\t * @param {Node<vec3>} [position=positionLocal] - The vertex position in local space.\n\t * @return {Node<vec3>} The transformed vertex position.\n\t */\n\tgetSkinnedPosition( boneMatrices = this.boneMatricesNode, position = positionLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// POSITION\n\n\t\tconst skinVertex = bindMatrixNode.mul( position );\n\n\t\tconst skinned = add(\n\t\t\tboneMatX.mul( skinWeightNode.x ).mul( skinVertex ),\n\t\t\tboneMatY.mul( skinWeightNode.y ).mul( skinVertex ),\n\t\t\tboneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),\n\t\t\tboneMatW.mul( skinWeightNode.w ).mul( skinVertex )\n\t\t);\n\n\t\treturn bindMatrixInverseNode.mul( skinned ).xyz;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex normal via skinning.\n\t *\n\t * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n\t * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.\n\t * @return {Node<vec3>} The transformed vertex normal.\n\t */\n\tgetSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// NORMAL\n\n\t\tlet skinMatrix = add(\n\t\t\tskinWeightNode.x.mul( boneMatX ),\n\t\t\tskinWeightNode.y.mul( boneMatY ),\n\t\t\tskinWeightNode.z.mul( boneMatZ ),\n\t\t\tskinWeightNode.w.mul( boneMatW )\n\t\t);\n\n\t\tskinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );\n\n\t\treturn skinMatrix.transformDirection( normal ).xyz;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex normal via skinning.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The skinned position from the previous frame.\n\t */\n\tgetPreviousSkinnedPosition( builder ) {\n\n\t\tconst skinnedMesh = builder.object;\n\n\t\tif ( this.previousBoneMatricesNode === null ) {\n\n\t\t\tskinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );\n\n\t\t\tthis.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\treturn this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );\n\n\t}\n\n\t/**\n\t * Returns `true` if bone matrices from the previous frame are required.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether bone matrices from the previous frame are required or not.\n\t */\n\tneedsPreviousBoneMatrices( builder ) {\n\n\t\tconst mrt = builder.renderer.getMRT();\n\n\t\treturn ( mrt && mrt.has( 'velocity' ) ) || getDataFromObject( builder.object ).useVelocity === true;\n\n\t}\n\n\t/**\n\t * Setups the skinning node by assigning the transformed vertex data to predefined node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.needsPreviousBoneMatrices( builder ) ) {\n\n\t\t\tpositionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );\n\n\t\t}\n\n\t\tconst skinPosition = this.getSkinnedPosition();\n\n\n\t\tpositionLocal.assign( skinPosition );\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst skinNormal = this.getSkinnedNormal();\n\n\t\t\tnormalLocal.assign( skinNormal );\n\n\t\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\t\ttangentLocal.assign( skinNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the skinning node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} output - The current output.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\treturn positionLocal.build( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the state of the skinned mesh by updating the skeleton once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst object = this.useReference ? frame.object : this.skinnedMesh;\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( _frameId.get( skeleton ) === frame.frameId ) return;\n\n\t\t_frameId.set( skeleton, frame.frameId );\n\n\t\tif ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );\n\n\t\tskeleton.update();\n\n\t}\n\n}\n\n/**\n * TSL function for creating a skinning node.\n *\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @returns {SkinningNode}\n */\nconst skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );\n\n/**\n * TSL function for creating a skinning node with reference usage.\n *\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @returns {SkinningNode}\n */\nconst skinningReference = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh, true ) );\n\n/** @module LoopNode **/\n\n/**\n * This module offers a variety of ways to implement loops in TSL. In it's basic form it's:\n * ```js\n * Loop( count, ( { i } ) => {\n *\n * } );\n * ```\n * However, it is also possible to define a start and end ranges, data types and loop conditions:\n * ```js\n * Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {\n *\n * } );\n *```\n * Nested loops can be defined in a compacted form:\n * ```js\n * Loop( 10, 5, ( { i, j } ) => {\n *\n * } );\n * ```\n * Loops that should run backwards can be defined like so:\n * ```js\n * Loop( { start: 10 }, () => {} );\n * ```\n * The module also provides `Break()` and `Continue()` TSL expression for loop control.\n * @augments Node\n */\nclass LoopNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LoopNode';\n\n\t}\n\n\t/**\n\t * Constructs a new loop node.\n\t *\n\t * @param {Array<Any>} params - Depending on the loop type, array holds different parameterization values for the loop.\n\t */\n\tconstructor( params = [] ) {\n\n\t\tsuper();\n\n\t\tthis.params = params;\n\n\t}\n\n\t/**\n\t * Returns a loop variable name based on an index. The pattern is\n\t * `0` = `i`, `1`= `j`, `2`= `k` and so on.\n\t *\n\t * @param {Number} index - The index.\n\t * @return {String} The loop variable name.\n\t */\n\tgetVarName( index ) {\n\n\t\treturn String.fromCharCode( 'i'.charCodeAt( 0 ) + index );\n\n\t}\n\n\t/**\n\t * Returns properties about this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Object} The node properties.\n\t */\n\tgetProperties( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.stackNode !== undefined ) return properties;\n\n\t\t//\n\n\t\tconst inputs = {};\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = this.params[ i ];\n\n\t\t\tconst name = ( param.isNode !== true && param.name ) || this.getVarName( i );\n\t\t\tconst type = ( param.isNode !== true && param.type ) || 'int';\n\n\t\t\tinputs[ name ] = expression( name, type );\n\n\t\t}\n\n\t\tconst stack = builder.addStack(); // TODO: cache() it\n\n\t\tproperties.returnsNode = this.params[ this.params.length - 1 ]( inputs, stack, builder );\n\t\tproperties.stackNode = stack;\n\n\t\tbuilder.removeStack();\n\n\t\treturn properties;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred based on the loop configuration.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst { returnsNode } = this.getProperties( builder );\n\n\t\treturn returnsNode ? returnsNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// setup properties\n\n\t\tthis.getProperties( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = this.getProperties( builder );\n\n\t\tconst params = this.params;\n\t\tconst stackNode = properties.stackNode;\n\n\t\tfor ( let i = 0, l = params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = params[ i ];\n\n\t\t\tlet start = null, end = null, name = null, type = null, condition = null, update = null;\n\n\t\t\tif ( param.isNode ) {\n\n\t\t\t\ttype = 'int';\n\t\t\t\tname = this.getVarName( i );\n\t\t\t\tstart = '0';\n\t\t\t\tend = param.build( builder, type );\n\t\t\t\tcondition = '<';\n\n\t\t\t} else {\n\n\t\t\t\ttype = param.type || 'int';\n\t\t\t\tname = param.name || this.getVarName( i );\n\t\t\t\tstart = param.start;\n\t\t\t\tend = param.end;\n\t\t\t\tcondition = param.condition;\n\t\t\t\tupdate = param.update;\n\n\t\t\t\tif ( typeof start === 'number' ) start = builder.generateConst( type, start );\n\t\t\t\telse if ( start && start.isNode ) start = start.build( builder, type );\n\n\t\t\t\tif ( typeof end === 'number' ) end = builder.generateConst( type, end );\n\t\t\t\telse if ( end && end.isNode ) end = end.build( builder, type );\n\n\t\t\t\tif ( start !== undefined && end === undefined ) {\n\n\t\t\t\t\tstart = start + ' - 1';\n\t\t\t\t\tend = '0';\n\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t} else if ( end !== undefined && start === undefined ) {\n\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t\tif ( condition === undefined ) {\n\n\t\t\t\t\tif ( Number( start ) > Number( end ) ) {\n\n\t\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcondition = '<';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst internalParam = { start, end, condition };\n\n\t\t\t//\n\n\t\t\tconst startSnippet = internalParam.start;\n\t\t\tconst endSnippet = internalParam.end;\n\n\t\t\tlet declarationSnippet = '';\n\t\t\tlet conditionalSnippet = '';\n\t\t\tlet updateSnippet = '';\n\n\t\t\tif ( ! update ) {\n\n\t\t\t\tif ( type === 'int' || type === 'uint' ) {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '++';\n\t\t\t\t\telse update = '--';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '+= 1.';\n\t\t\t\t\telse update = '-= 1.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdeclarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;\n\n\t\t\tconditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n\t\t\tupdateSnippet += name + ' ' + update;\n\n\t\t\tconst forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '\\n' : '' ) + builder.tab + forSnippet + ' {\\n\\n' ).addFlowTab();\n\n\t\t}\n\n\t\tconst stackSnippet = stackNode.build( builder, 'void' );\n\n\t\tconst returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';\n\n\t\tbuilder.removeFlowTab().addFlowCode( '\\n' + builder.tab + stackSnippet );\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\\n\\n' ).removeFlowTab();\n\n\t\t}\n\n\t\tbuilder.addFlowTab();\n\n\t\treturn returnsSnippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a loop node.\n *\n * @function\n * @param {...Any} params - A list of parameters.\n * @returns {LoopNode}\n */\nconst Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();\n\n/**\n * TSL function for creating a `Continue()` expression.\n *\n * @function\n * @returns {ExpressionNode}\n */\nconst Continue = () => expression( 'continue' ).append();\n\n/**\n * TSL function for creating a `Break()` expression.\n *\n * @function\n * @returns {ExpressionNode}\n */\nconst Break = () => expression( 'break' ).append();\n\n// Deprecated\n\n/**\n * @function\n * @deprecated since r168. Use {@link Loop} instead.\n *\n * @param  {...any} params\n * @returns {LoopNode}\n */\nconst loop = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.LoopNode: loop() has been renamed to Loop().' );\n\treturn Loop( ...params );\n\n};\n\n/** @module MorphNode **/\n\nconst _morphTextures = /*@__PURE__*/ new WeakMap();\nconst _morphVec4 = /*@__PURE__*/ new Vector4();\n\nconst getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {\n\n\tconst texelIndex = int( vertexIndex ).mul( stride ).add( offset );\n\n\tconst y = texelIndex.div( width );\n\tconst x = texelIndex.sub( y.mul( width ) );\n\n\tconst bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );\n\n\treturn bufferAttrib.mul( influence );\n\n} );\n\nfunction getEntry( geometry ) {\n\n\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t// into an array of data textures. Each layer represents a single morph target.\n\n\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\tlet entry = _morphTextures.get( geometry );\n\n\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\tlet vertexDataCount = 0;\n\n\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\tlet height = 1;\n\n\t\tconst maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n\t\tif ( width > maxTextureSize ) {\n\n\t\t\theight = Math.ceil( width / maxTextureSize );\n\t\t\twidth = maxTextureSize;\n\n\t\t}\n\n\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\tconst bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\tbufferTexture.type = FloatType;\n\t\tbufferTexture.needsUpdate = true;\n\n\t\t// fill buffer\n\n\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 0 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 1 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 2 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 4 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 5 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 6 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 8 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 9 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 10 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tentry = {\n\t\t\tcount: morphTargetsCount,\n\t\t\ttexture: bufferTexture,\n\t\t\tstride: vertexDataCount,\n\t\t\tsize: new Vector2( width, height )\n\t\t};\n\n\t\t_morphTextures.set( geometry, entry );\n\n\t\tfunction disposeTexture() {\n\n\t\t\tbufferTexture.dispose();\n\n\t\t\t_morphTextures.delete( geometry );\n\n\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t}\n\n\treturn entry;\n\n}\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for morph target animation.\n *\n * @augments Node\n */\nclass MorphNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MorphNode';\n\n\t}\n\n\t/**\n\t * Constructs a new morph node.\n\t *\n\t * @param {Mesh} mesh - The mesh holding the morph targets.\n\t */\n\tconstructor( mesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The mesh holding the morph targets.\n\t\t *\n\t\t * @type {Mesh}\n\t\t */\n\t\tthis.mesh = mesh;\n\n\t\t/**\n\t\t * A uniform node which represents the morph base influence value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.morphBaseInfluence = uniform( 1 );\n\n\t\t/**\n\t\t * The update type overwritten since morph nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Setups the morph node by assigning the transformed vertex data to predefined node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { geometry } = builder;\n\n\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\tconst hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t// nodes\n\n\t\tconst { texture: bufferMap, stride, size } = getEntry( geometry );\n\n\t\tif ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );\n\t\tif ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );\n\n\t\tconst width = int( size.width );\n\n\t\tLoop( morphTargetsCount, ( { i } ) => {\n\n\t\t\tconst influence = float( 0 ).toVar();\n\n\t\t\tif ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {\n\n\t\t\t\tinfluence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );\n\n\t\t\t} else {\n\n\t\t\t\tinfluence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\tpositionLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth: i,\n\t\t\t\t\toffset: int( 0 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\tnormalLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth: i,\n\t\t\t\t\toffset: int( 1 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Updates the state of the morphed mesh by updating the base influence.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst morphBaseInfluence = this.morphBaseInfluence;\n\n\t\tif ( this.mesh.geometry.morphTargetsRelative ) {\n\n\t\t\tmorphBaseInfluence.value = 1;\n\n\t\t} else {\n\n\t\t\tmorphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a morph node.\n *\n * @function\n * @param {Mesh} mesh - The mesh holding the morph targets.\n * @returns {MorphNode}\n */\nconst morphReference = /*@__PURE__*/ nodeProxy( MorphNode );\n\n/**\n * Base class for lighting nodes.\n *\n * @augments Node\n */\nclass LightingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lighting node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLightingNode = true;\n\n\t}\n\n}\n\n/**\n * A generic class that can be used by nodes which contribute\n * ambient occlusion to the scene. E.g. an ambient occlusion map\n * node can be used as input for this module. Used in {@link NodeMaterial}.\n *\n * @augments LightingNode\n */\nclass AONode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AONode';\n\n\t}\n\n\t/**\n\t * Constructs a new AO node.\n\t *\n\t * @param {Node<float>?} [aoNode=null] - The ambient occlusion node.\n\t */\n\tconstructor( aoNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The ambient occlusion node.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.aoNode = aoNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.ambientOcclusion.mulAssign( this.aoNode );\n\n\t}\n\n}\n\n/**\n * `LightingContextNode` represents an extension of the {@link module:ContextNode~ContextNode} module\n * by adding lighting specific context data. It represents the runtime context of\n * {@link LightsNode}.\n *\n * @augments ContextNode\n */\nclass LightingContextNode extends ContextNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightingContextNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lighting context node.\n\t *\n\t * @param {LightsNode} node - The lights node.\n\t * @param {LightingModel?} [lightingModel=null] - The current lighting model.\n\t * @param {Node<vec3>?} [backdropNode=null] - A backdrop node.\n\t * @param {Node<float>?} [backdropAlphaNode=null] - A backdrop alpha node.\n\t */\n\tconstructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {\n\n\t\tsuper( node );\n\n\t\t/**\n\t\t * The current lighting model.\n\t\t *\n\t\t * @type {LightingModel?}\n\t\t * @default null\n\t\t */\n\t\tthis.lightingModel = lightingModel;\n\n\t\t/**\n\t\t * A backdrop node.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropNode = backdropNode;\n\n\t\t/**\n\t\t * A backdrop alpha node.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropAlphaNode = backdropAlphaNode;\n\n\t\tthis._value = null;\n\n\t}\n\n\t/**\n\t * Returns a lighting context object.\n\t *\n\t * @return {{\n\t * radiance: Node<vec3>,\n\t * irradiance: Node<vec3>,\n\t * iblIrradiance: Node<vec3>,\n\t * ambientOcclusion: Node<float>,\n\t * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},\n\t * backdrop: Node<vec3>,\n\t * backdropAlpha: Node<float>\n\t * }} The lighting context object.\n\t */\n\tgetContext() {\n\n\t\tconst { backdropNode, backdropAlphaNode } = this;\n\n\t\tconst directDiffuse = vec3().toVar( 'directDiffuse' ),\n\t\t\tdirectSpecular = vec3().toVar( 'directSpecular' ),\n\t\t\tindirectDiffuse = vec3().toVar( 'indirectDiffuse' ),\n\t\t\tindirectSpecular = vec3().toVar( 'indirectSpecular' );\n\n\t\tconst reflectedLight = {\n\t\t\tdirectDiffuse,\n\t\t\tdirectSpecular,\n\t\t\tindirectDiffuse,\n\t\t\tindirectSpecular\n\t\t};\n\n\t\tconst context = {\n\t\t\tradiance: vec3().toVar( 'radiance' ),\n\t\t\tirradiance: vec3().toVar( 'irradiance' ),\n\t\t\tiblIrradiance: vec3().toVar( 'iblIrradiance' ),\n\t\t\tambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),\n\t\t\treflectedLight,\n\t\t\tbackdrop: backdropNode,\n\t\t\tbackdropAlpha: backdropAlphaNode\n\t\t};\n\n\t\treturn context;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.value = this._value || ( this._value = this.getContext() );\n\t\tthis.value.lightingModel = this.lightingModel || builder.context.lightingModel;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\nconst lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );\n\n/**\n * A generic class that can be used by nodes which contribute\n * irradiance to the scene. E.g. a light map node can be used\n * as input for this module. Used in {@link NodeMaterial}.\n *\n * @augments LightingNode\n */\nclass IrradianceNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'IrradianceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new irradiance node.\n\t *\n\t * @param {Node<vec3>} node - A node contributing irradiance.\n\t */\n\tconstructor( node ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node contributing irradiance.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.node = node;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.irradiance.addAssign( this.node );\n\n\t}\n\n}\n\n/** @module ScreenNode **/\n\nlet screenSizeVec, viewportVec;\n\n/**\n * This node provides a collection of screen related metrics.\n * Depending on {@link module:ScreenNode~ScreenNode#scope}, the nodes can represent\n * resolution or viewport data as well as fragment or uv coordinates.\n *\n * @augments Node\n */\nclass ScreenNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScreenNode';\n\n\t}\n\n\t/**\n\t * Constructs a new screen node.\n\t *\n\t * @param {('coordinate'|'viewport'|'size'|'uv')} scope - The node's scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node represents different metric depending on which scope is selected.\n\t\t *\n\t\t * - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.\n\t\t * - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.\n\t\t * - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.\n\t\t * - `ScreenNode.UV`: Normalized coordinates.\n\t\t *\n\t\t * @type {('coordinate'|'viewport'|'size'|'uv')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isViewportNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type depends on the selected scope.\n\t *\n\t * @return {('vec2'|'vec4')} The node type.\n\t */\n\tgetNodeType() {\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';\n\t\telse return 'vec2';\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node's update type depends on the selected scope.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\tlet updateType = NodeUpdateType.NONE;\n\n\t\tif ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tupdateType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t\tthis.updateType = updateType;\n\n\t\treturn updateType;\n\n\t}\n\n\t/**\n\t * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information\n\t * from the current renderer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { renderer } ) {\n\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tviewportVec.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getViewport( viewportVec );\n\n\t\t\t\tviewportVec.multiplyScalar( renderer.getPixelRatio() );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tscreenSizeVec.width = renderTarget.width;\n\t\t\t\tscreenSizeVec.height = renderTarget.height;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getDrawingBufferSize( screenSizeVec );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet output = null;\n\n\t\tif ( scope === ScreenNode.SIZE ) {\n\n\t\t\toutput = uniform( screenSizeVec || ( screenSizeVec = new Vector2() ) );\n\n\t\t} else if ( scope === ScreenNode.VIEWPORT ) {\n\n\t\t\toutput = uniform( viewportVec || ( viewportVec = new Vector4() ) );\n\n\t\t} else {\n\n\t\t\toutput = vec2( screenCoordinate.div( screenSize ) );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.scope === ScreenNode.COORDINATE ) {\n\n\t\t\tlet coord = builder.getFragCoord();\n\n\t\t\tif ( builder.isFlipY() ) {\n\n\t\t\t\t// follow webgpu standards\n\n\t\t\t\tconst size = builder.getNodeProperties( screenSize ).outputNode.build( builder );\n\n\t\t\t\tcoord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;\n\n\t\t\t}\n\n\t\t\treturn coord;\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\n\n// Screen\n\n/**\n * TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );\n\n/**\n * TSL object that represents the screen resolution in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );\n\n// Viewport\n\n/**\n * TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.\n *\n * @type {ScreenNode<vec4>}\n */\nconst viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );\n\n/**\n * TSL object that represents the viewport resolution in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportSize = viewport.zw;\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );\n\n/**\n * TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );\n\n// Deprecated\n\n/**\n * @deprecated since r169. Use {@link screenSize} instead.\n */\nconst viewportResolution = /*@__PURE__*/ ( Fn( () => { // @deprecated, r169\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.' );\n\n\treturn screenSize;\n\n}, 'vec2' ).once() )();\n\n/**\n * @deprecated since r168. Use {@link screenUV} instead.\n */\nconst viewportTopLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportTopLeft\" is deprecated. Use \"screenUV\" instead.' );\n\n\treturn screenUV;\n\n}, 'vec2' ).once() )();\n\n/**\n * @deprecated since r168. Use `screenUV.flipY()` instead.\n */\nconst viewportBottomLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportBottomLeft\" is deprecated. Use \"screenUV.flipY()\" instead.' );\n\n\treturn screenUV.flipY();\n\n}, 'vec2' ).once() )();\n\n/** @module ViewportTextureNode **/\n\nconst _size$4 = /*@__PURE__*/ new Vector2();\n\n/**\n * A special type of texture node which represents the data of the current viewport\n * as a texture. The module extracts data from the current bound framebuffer with\n * a copy operation so no extra render pass is required to produce the texture data\n * (which is good for performance). `ViewportTextureNode` can be used as an input for a\n * variety of effects like refractive or transmissive materials.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass ViewportTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {Node?} [levelNode=null] - The level node.\n\t * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {\n\n\t\tif ( framebufferTexture === null ) {\n\n\t\t\tframebufferTexture = new FramebufferTexture();\n\t\t\tframebufferTexture.minFilter = LinearMipmapLinearFilter;\n\n\t\t}\n\n\t\tsuper( framebufferTexture, uvNode, levelNode );\n\n\t\t/**\n\t\t * Whether to generate mipmaps or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.generateMipmaps = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputTextureNode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n\t\t * scene once per frame in its {@link ViewportTextureNode#updateBefore} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst renderer = frame.renderer;\n\t\trenderer.getDrawingBufferSize( _size$4 );\n\n\t\t//\n\n\t\tconst framebufferTexture = this.value;\n\n\t\tif ( framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height ) {\n\n\t\t\tframebufferTexture.image.width = _size$4.width;\n\t\t\tframebufferTexture.image.height = _size$4.height;\n\t\t\tframebufferTexture.needsUpdate = true;\n\n\t\t}\n\n\t\t//\n\n\t\tconst currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n\t\tframebufferTexture.generateMipmaps = this.generateMipmaps;\n\n\t\trenderer.copyFramebufferToTexture( framebufferTexture );\n\n\t\tframebufferTexture.generateMipmaps = currentGenerateMipmaps;\n\n\t}\n\n\tclone() {\n\n\t\tconst viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );\n\t\tviewportTextureNode.generateMipmaps = this.generateMipmaps;\n\n\t\treturn viewportTextureNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a viewport texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nconst viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode );\n\n/**\n * TSL function for creating a viewport texture node with enabled mipmap generation.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nconst viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );\n\n/** @module ViewportDepthTextureNode **/\n\nlet sharedDepthbuffer = null;\n\n/**\n * Represents the depth of the current viewport as a texture. This module\n * can be used in combination with viewport texture to achieve effects\n * that require depth evaluation.\n *\n * @augments module:ViewportTextureNode~ViewportTextureNode\n */\nclass ViewportDepthTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport depth texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {Node?} [levelNode=null] - The level node.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( sharedDepthbuffer === null ) {\n\n\t\t\tsharedDepthbuffer = new DepthTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, sharedDepthbuffer );\n\n\t}\n\n}\n\n/**\n * TSL function for a viewport depth texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @returns {ViewportDepthTextureNode}\n */\nconst viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode );\n\n/** @module ViewportDepthNode **/\n\n/**\n * This node offers a collection of features in context of the depth logic in the fragment shader.\n * Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current\n * fragment or for depth evaluation purposes.\n *\n * @augments Node\n */\nclass ViewportDepthNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport depth node.\n\t *\n\t * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.\n\t * @param {Node?} [valueNode=null] - The value node.\n\t */\n\tconstructor( scope, valueNode = null ) {\n\n\t\tsuper( 'float' );\n\n\t\t/**\n\t\t * The node behaves differently depending on which scope is selected.\n\t\t *\n\t\t * - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.\n\t\t * - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).\n\t\t * - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.\n\t\t * If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.\n\t\t *\n\t\t * @type {('depth'|'depthBase'|'linearDepth')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * Can be used to define a custom depth value.\n\t\t * The property is ignored in the `ViewportDepthNode.DEPTH` scope.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isViewportDepthNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\treturn builder.getFragDepth();\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n\tsetup( { camera } ) {\n\n\t\tconst { scope } = this;\n\t\tconst value = this.valueNode;\n\n\t\tlet node = null;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\tif ( value !== null ) {\n\n \t\t\t\tnode = depthBase().assign( value );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.DEPTH ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tnode = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tconst viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );\n\n\t\t\t\t\tnode = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = value;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n/**\n * TSL function for converting a viewZ value to an orthographic depth value.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );\n\n/**\n * TSL function for converting an orthographic depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The orthographic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );\n\n/**\n * TSL function for converting a viewZ value to a perspective depth value.\n *\n * Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );\n\n/**\n * TSL function for converting a perspective depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The perspective depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );\n\n/**\n * TSL function for converting a viewZ value to a logarithmic depth value.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToLogarithmicDepth = ( viewZ, near, far ) => {\n\n\t// NOTE: viewZ must be negative--see explanation at the end of this comment block.\n\t// The final logarithmic depth formula used here is adapted from one described in an\n\t// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n\t// which was an improvement upon an earlier formula one described in an\n\t// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n\t// Ulrich's formula is the following:\n\t//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n\t//     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n\t// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n\t// opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n\t// Outerra states: \"Notice that the 'C' variant doesn’t use a near plane distance, it has it\n\t// set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n\t// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n\t// It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n\t// be used, and ultimately Ulrich's \"near plane\" version was chosen.\n\t// Outerra eventually made another improvement to their original \"C-constant\" variant,\n\t// but it still does not incorporate the camera near plane (for this version,\n\t// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n\t// Here we make 4 changes to Ulrich's formula:\n\t// 1. Clamp the camera near plane so we don't divide by 0.\n\t// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n\t// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n\t// 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n\t//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n\t//    so we do the same here, hence the 'viewZ.negate()' call.\n\t// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n\tnear = near.max( 1e-6 ).toVar();\n\tconst numerator = log2( viewZ.negate().div( near ) );\n\tconst denominator = log2( far.div( near ) );\n\treturn numerator.div( denominator );\n\n};\n\n/**\n * TSL function for converting a logarithmic depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The logarithmic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst logarithmicDepthToViewZ = ( depth, near, far ) => {\n\n\t// NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n\t// the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n\t// a negative viewZ).\n\tconst exponent = depth.mul( log( far.div( near ) ) );\n\treturn float( Math.E ).pow( exponent ).mul( near ).negate();\n\n};\n\n/**\n * TSL function for defining a value for the current fragment's depth.\n *\n * @function\n * @param {Node<float>} value - The depth value to set.\n * @returns {ViewportDepthNode<float>}\n */\nconst depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );\n\n/**\n * TSL object that represents the depth value for the current fragment.\n *\n * @type {ViewportDepthNode}\n */\nconst depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );\n\n/**\n * TSL function for converting a perspective depth value to linear depth.\n *\n * @function\n * @param {Node<float>} value - The perspective depth.\n * @returns {ViewportDepthNode<float>}\n */\nconst linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH );\n\n/**\n * TSL object that represents the linear (orthographic) depth value of the current fragment\n *\n * @type {ViewportDepthNode}\n */\nconst viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );\n\ndepth.assign = ( value ) => depthBase( value );\n\n/** @module BuiltinNode **/\n\n/**\n * The node allows to set values for built-in shader variables. That is\n * required for features like hardware-accelerated vertex clipping.\n *\n * @augments Node\n */\nclass BuiltinNode extends Node {\n\n\t/**\n\t * Constructs a new builtin node.\n\t *\n\t * @param {String} name - The name of the built-in shader variable.\n\t */\n\tconstructor( name ) {\n\n\t\tsuper( 'float' );\n\n\t\t/**\n\t\t * The name of the built-in shader variable.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBuiltinNode = true;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the builtin node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( /* builder */ ) {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a builtin node.\n *\n * @function\n * @param {String} name - The name of the built-in shader variable.\n * @returns {BuiltinNode}\n */\nconst builtin = nodeProxy( BuiltinNode );\n\n/** @module ClippingNode **/\n\n/**\n * ```\n * This node is used in {@link NodeMaterial} to setup the clipping\n * which can happen hardware-accelerated (if supported) and optionally\n * use alpha-to-coverage for anti-aliasing clipped edges.\n * ```\n * @augments Node\n */\nclass ClippingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ClippingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new clipping node.\n\t *\n\t * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,\n\t * the selected scope influences the behavior of the node and what type of code is generated.\n\t */\n\tconstructor( scope = ClippingNode.DEFAULT ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node's scope. Similar to other nodes, the selected scope influences\n\t\t * the behavior of the node and what type of code is generated.\n\t\t *\n\t\t * @type {('default'|'hardware'|'alphaToCoverage')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Setups the node depending on the selected scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The result node.\n\t */\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst clippingContext = builder.clippingContext;\n\t\tconst { intersectionPlanes, unionPlanes } = clippingContext;\n\n\t\tthis.hardwareClipping = builder.material.hardwareClipping;\n\n\t\tif ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {\n\n\t\t\treturn this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );\n\n\t\t} else if ( this.scope === ClippingNode.HARDWARE ) {\n\n\t\t\treturn this.setupHardwareClipping( unionPlanes, builder );\n\n\t\t} else {\n\n\t\t\treturn this.setupDefault( intersectionPlanes, unionPlanes );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups alpha to coverage.\n\t *\n\t * @param {Array<Vector4>} intersectionPlanes - The intersection planes.\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @return {Node} The result node.\n\t */\n\tsetupAlphaToCoverage( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst distanceToPlane = float().toVar( 'distanceToPlane' );\n\t\t\tconst distanceGradient = float().toVar( 'distanceToGradient' );\n\n\t\t\tconst clipOpacity = float( 1 ).toVar( 'clipOpacity' );\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( this.hardwareClipping === false && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tclipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes );\n\t\t\t\tconst intersectionClipOpacity = float( 1 ).toVar( 'intersectionClipOpacity' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tintersectionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );\n\n\t\t\t\t} );\n\n\t\t\t\tclipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );\n\n\t\t\t}\n\n\t\t\tdiffuseColor.a.mulAssign( clipOpacity );\n\n\t\t\tdiffuseColor.a.equal( 0.0 ).discard();\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Setups the default clipping.\n\t *\n\t * @param {Array<Vector4>} intersectionPlanes - The intersection planes.\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @return {Node} The result node.\n\t */\n\tsetupDefault( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( this.hardwareClipping === false && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tpositionView.dot( plane.xyz ).greaterThan( plane.w ).discard();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes );\n\t\t\t\tconst clipped = bool( true ).toVar( 'clipped' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tclipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );\n\n\t\t\t\t} );\n\n\t\t\t\tclipped.discard();\n\n\t\t\t}\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Setups hardware clipping.\n\t *\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The result node.\n\t */\n\tsetupHardwareClipping( unionPlanes, builder ) {\n\n\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\tbuilder.enableHardwareClipping( numUnionPlanes );\n\n\t\treturn Fn( () => {\n\n\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\t\t\tconst hw_clip_distances = builtin( builder.getClipDistance() );\n\n\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\tconst distance = positionView.dot( plane.xyz ).sub( plane.w ).negate();\n\t\t\t\thw_clip_distances.element( i ).assign( distance );\n\n\t\t\t} );\n\n\t\t} )();\n\n\t}\n\n}\n\nClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';\nClippingNode.DEFAULT = 'default';\nClippingNode.HARDWARE = 'hardware';\n\n/**\n * TSL function for setting up the default clipping logic.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst clipping = () => nodeObject( new ClippingNode() );\n\n/**\n * TSL function for setting up alpha to coverage.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );\n\n/**\n * TSL function for setting up hardware-based clipping.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );\n\n// See: https://casual-effects.com/research/Wyman2017Hashed/index.html\n\nconst ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.\n\nconst hash2D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn fract( mul( 1.0e4, sin( mul( 17.0, value.x ).add( mul( 0.1, value.y ) ) ) ).mul( add( 0.1, abs( sin( mul( 13.0, value.y ).add( value.x ) ) ) ) ) );\n\n} );\n\nconst hash3D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\n} );\n\nconst getAlphaHashThreshold = /*@__PURE__*/ Fn( ( [ position ] ) => {\n\n\t// Find the discretized derivatives of our coordinates\n\tconst maxDeriv = max$1(\n\t\tlength( dFdx( position.xyz ) ),\n\t\tlength( dFdy( position.xyz ) )\n\t);\n\n\tconst pixScale = float( 1 ).div( float( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );\n\n\t// Find two nearest log-discretized noise scales\n\tconst pixScales = vec2(\n\t\texp2( floor( log2( pixScale ) ) ),\n\t\texp2( ceil( log2( pixScale ) ) )\n\t);\n\n\t// Compute alpha thresholds at our two noise scales\n\tconst alpha = vec2(\n\t\thash3D( floor( pixScales.x.mul( position.xyz ) ) ),\n\t\thash3D( floor( pixScales.y.mul( position.xyz ) ) ),\n\t);\n\n\t// Factor to interpolate lerp with\n\tconst lerpFactor = fract( log2( pixScale ) );\n\n\t// Interpolate alpha threshold from noise at two scales\n\tconst x = add( mul( lerpFactor.oneMinus(), alpha.x ), mul( lerpFactor, alpha.y ) );\n\n\t// Pass into CDF to compute uniformly distrib threshold\n\tconst a = min$1( lerpFactor, lerpFactor.oneMinus() );\n\tconst cases = vec3(\n\t\tx.mul( x ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ),\n\t\tx.sub( mul( 0.5, a ) ).div( sub( 1.0, a ) ),\n\t\tsub( 1.0, sub( 1.0, x ).mul( sub( 1.0, x ) ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ) ) );\n\n\t// Find our final, uniformly distributed alpha threshold (ατ)\n\tconst threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );\n\n\t// Avoids ατ == 0. Could also do ατ =1-ατ\n\treturn clamp( threshold, 1.0e-6, 1.0 );\n\n} ).setLayout( {\n\tname: 'getAlphaHashThreshold',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec3' }\n\t]\n} );\n\n/**\n * Base class for all node materials.\n *\n * @augments Material\n */\nclass NodeMaterial extends Material {\n\n\tstatic get type() {\n\n\t\treturn 'NodeMaterial';\n\n\t}\n\n\t/**\n\t * Represents the type of the node material.\n\t *\n\t * @type {String}\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\tset type( _value ) { /* */ }\n\n\t/**\n\t * Constructs a new node material.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeMaterial = true;\n\n\t\t/**\n\t\t * Whether this material is affected by fog or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.fog = true;\n\n\t\t/**\n\t\t * Whether this material is affected by lights or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.lights = false;\n\n\t\t/**\n\t\t * Whether this material uses hardware clipping or not.\n\t\t * This property is managed by the engine and should not be\n\t\t * modified by apps.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.hardwareClipping = false;\n\n\t\t/**\n\t\t * Node materials which set their `lights` property to `true`\n\t\t * are affected by all lights of the scene. Sometimes selective\n\t\t * lighting is wanted which means only _some_ lights in the scene\n\t\t * affect a material. This can be achieved by creating an instance\n\t\t * of {@link module:LightsNode~LightsNode} with a list of selective\n\t\t * lights and assign the node to this property.\n\t\t *\n\t\t * ```js\n\t\t * const customLightsNode = lights( [ light1, light2 ] );\n\t\t * material.lightsNode = customLightsNode;\n\t\t * ```\n\t\t *\n\t\t * @type {LightsNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.lightsNode = null;\n\n\t\t/**\n\t\t * The environment of node materials can be defined by an environment\n\t\t * map assigned to the `envMap` property or by `Scene.environment`\n\t\t * if the node material is a PBR material. This node property allows to overwrite\n\t\t * the default behavior and define the environment with a custom node.\n\t\t *\n\t\t * ```js\n\t\t * material.envNode = pmremTexture( renderTarget.texture );\n\t\t * ```\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = null;\n\n\t\t/**\n\t\t * The lighting of node materials might be influenced by ambient occlusion.\n\t\t * The default AO is inferred from an ambient occlusion map assigned to `aoMap`\n\t\t * and the respective `aoMapIntensity`. This node property allows to overwrite\n\t\t * the default and define the ambient occlusion with a custom node instead.\n\t\t *\n\t\t * If you don't want to overwrite the diffuse color but modify the existing\n\t\t * values instead, use {@link module:MaterialNode.materialAO}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.aoNode = null;\n\n\t\t/**\n\t\t * The diffuse color of node materials is by default inferred from the\n\t\t * `color` and `map` properties. This node property allows to overwrite the default\n\t\t * and define the diffuse color with a node instead.\n\t\t *\n\t\t * ```js\n\t\t * material.colorNode = color( 0xff0000 ); // define red color\n\t\t * ```\n\t\t *\n\t\t * If you don't want to overwrite the diffuse color but modify the existing\n\t\t * values instead, use {@link module:MaterialNode.materialColor}.\n\t\t *\n\t\t * ```js\n\t\t * material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint\n\t\t * ```\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.colorNode = null;\n\n\t\t/**\n\t\t * The normals of node materials are by default inferred from the `normalMap`/`normalScale`\n\t\t * or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default\n\t\t * and define the normals with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the normals but modify the existing values instead,\n\t\t * use {@link module:MaterialNode.materialNormal}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.normalNode = null;\n\n\t\t/**\n\t\t * The opacity of node materials is by default inferred from the `opacity`\n\t\t * and `alphaMap` properties. This node property allows to overwrite the default\n\t\t * and define the opacity with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the normals but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialOpacity}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.opacityNode = null;\n\n\t\t/**\n\t\t * This node can be used to to implement a variety of filter-like effects. The idea is\n\t\t * to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it\n\t\t * to create an arbitrary effect and then assign the node composition to this property.\n\t\t * Everything behind the object using this material will now be affected by a filter.\n\t\t *\n\t\t * ```js\n\t\t * const material = new NodeMaterial()\n\t\t * material.transparent = true;\n\t\t *\n\t\t * // everything behind the object will be monochromatic\n\t\t * material.backdropNode = saturation( viewportSharedTexture().rgb, 0 );\n\t\t * ```\n\t\t *\n\t\t * Backdrop computations are part of the lighting so only lit materials can use this property.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropNode = null;\n\n\t\t/**\n\t\t * This node allows to modulate the influence of `backdropNode` to the outgoing light.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropAlphaNode = null;\n\n\t\t/**\n\t\t * The alpha test of node materials is by default inferred from the `alphaTest`\n\t\t * property. This node property allows to overwrite the default and define the\n\t\t * alpha test with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the alpha test but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialAlphaTest}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.alphaTestNode = null;\n\n\t\t/**\n\t\t * The local vertex positions are computed based on multiple factors like the\n\t\t * attribute data, morphing or skinning. This node property allows to overwrite\n\t\t * the default and define local vertex positions with nodes instead.\n\t\t *\n\t\t * If you don't want to overwrite the vertex positions but modify the existing\n\t\t * values instead, use {@link module:Position.positionLocal}.\n\t\t *\n\t\t *```js\n\t\t * material.positionNode = positionLocal.add( displace );\n\t\t * ```\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.positionNode = null;\n\n\t\t/**\n\t\t * This node property is intended for logic which modifies geometry data once or per animation step.\n\t\t * Apps usually place such logic randomly in initialization routines or in the animation loop.\n\t\t * `geometryNode` is intended as a dedicated API so there is an intended spot where geometry modifications\n\t\t * can be implemented.\n\t\t *\n\t\t * The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example\n\t\t * would be a GPU based particle system that provides a node material for usage on app level. The particle\n\t\t * simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is\n\t\t * eventually assigned to `geometryNode`.\n\t\t *\n\t\t * @type {Function}\n\t\t * @default null\n\t\t */\n\t\tthis.geometryNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite depth values in the fragment shader.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.depthNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite the position used for shadow map rendering which\n\t\t * is by default {@link module:Position.positionWorld}, the vertex position\n\t\t * in world space.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.shadowPositionNode = null;\n\n\t\t/**\n\t\t * This node can be used to influence how an object using this node material\n\t\t * receive shadows.\n\t\t *\n\t\t * ```js\n\t\t * const totalShadows = float( 1 ).toVar();\n\t\t * material.receivedShadowNode = Fn( ( [ shadow ] ) => {\n\t\t * \ttotalShadows.mulAssign( shadow );\n\t\t * \t//return float( 1 ); // bypass received shadows\n\t\t * \treturn shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color\n\t\t * } );\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.receivedShadowNode = null;\n\n\t\t/**\n\t\t * This node can be used to influence how an object using this node material\n\t\t * casts shadows. To apply a color to shadows, you can simply do:\n\t\t *\n\t\t * ```js\n\t\t * material.castShadowNode = vec4( 1, 0, 0, 1 );\n\t\t * ```\n\t\t *\n\t\t * Which can be nice to fake colored shadows of semi-transparent objects. It\n\t\t * is also common to use the property with `Fn` function so checks are performed\n\t\t * per fragment.\n\t\t *\n\t\t * ```js\n\t\t * materialCustomShadow.castShadowNode = Fn( () => {\n\t\t * \thash( vertexIndex ).greaterThan( 0.5 ).discard();\n\t\t * \treturn materialColor;\n\t\t * } )();\n\t\t *  ```\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.castShadowNode = null;\n\n\t\t/**\n\t\t * This node can be used to define the final output of the material.\n\t\t *\n\t\t * TODO: Explain the differences to `fragmentNode`.\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.outputNode = null;\n\n\t\t/**\n\t\t * MRT configuration is done on renderer or pass level. This node allows to\n\t\t * overwrite what values are written into MRT targets on material level. This\n\t\t * can be useful for implementing selective FX features that should only affect\n\t\t * specific objects.\n\t\t *\n\t\t * @type {MRTNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.mrtNode = null;\n\n\t\t/**\n\t\t * This node property can be used if you need complete freedom in implementing\n\t\t * the fragment shader. Assigning a node will replace the built-in material\n\t\t * logic used in the fragment stage.\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.fragmentNode = null;\n\n\t\t/**\n\t\t * This node property can be used if you need complete freedom in implementing\n\t\t * the vertex shader. Assigning a node will replace the built-in material logic\n\t\t * used in the vertex stage.\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.vertexNode = null;\n\n\t}\n\n\t/**\n\t * Allows to define a custom cache key that influence the material key computation\n\t * for render objects.\n\t *\n\t * @return {String} The custom cache key.\n\t */\n\tcustomProgramCacheKey() {\n\n\t\treturn this.type + getCacheKey$1( this );\n\n\t}\n\n\t/**\n\t * Builds this material with the given node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\t/**\n\t * Setups a node material observer with the given builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeMaterialObserver} The node material observer.\n\t */\n\tsetupObserver( builder ) {\n\n\t\treturn new NodeMaterialObserver( builder );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupNormal = () => this.setupNormal( builder );\n\t\tbuilder.context.setupPositionView = () => this.setupPositionView( builder );\n\t\tbuilder.context.setupModelViewProjection = () => this.setupModelViewProjection( builder );\n\n\t\tconst renderer = builder.renderer;\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tconst vertexNode = this.vertexNode || this.setupVertex( builder );\n\n\t\tbuilder.stack.outputNode = vertexNode;\n\n\t\tthis.setupHardwareClipping( builder );\n\n\t\tif ( this.geometryNode !== null ) {\n\n\t\t\tbuilder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );\n\n\t\t}\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet resultNode;\n\n\t\tconst clippingNode = this.setupClipping( builder );\n\n\t\tif ( this.depthWrite === true || this.depthTest === true ) {\n\n\t\t\t// only write depth if depth buffer is configured\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tif ( renderTarget.depthBuffer === true ) this.setupDepth( builder );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderer.depth === true ) this.setupDepth( builder );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.fragmentNode === null ) {\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\tif ( clippingNode !== null ) builder.stack.add( clippingNode );\n\n\t\t\t// force unsigned floats - useful for RenderTargets\n\n\t\t\tconst basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );\n\n\t\t\tresultNode = this.setupOutput( builder, basicOutput );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\toutput.assign( resultNode );\n\n\t\t\t//\n\n\t\t\tif ( this.outputNode !== null ) resultNode = this.outputNode;\n\n\t\t\t// MRT\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tconst mrt = renderer.getMRT();\n\t\t\t\tconst materialMRT = this.mrtNode;\n\n\t\t\t\tif ( mrt !== null ) {\n\n\t\t\t\t\tresultNode = mrt;\n\n\t\t\t\t\tif ( materialMRT !== null ) {\n\n\t\t\t\t\t\tresultNode = mrt.merge( materialMRT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialMRT !== null ) {\n\n\t\t\t\t\tresultNode = materialMRT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tlet fragmentNode = this.fragmentNode;\n\n\t\t\tif ( fragmentNode.isOutputStructNode !== true ) {\n\n\t\t\t\tfragmentNode = vec4( fragmentNode );\n\n\t\t\t}\n\n\t\t\tresultNode = this.setupOutput( builder, fragmentNode );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = resultNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t\t// < OBSERVER >\n\n\t\tbuilder.observer = this.setupObserver( builder );\n\n\t}\n\n\t/**\n\t * Setups the clipping node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ClippingNode} The clipping node.\n\t */\n\tsetupClipping( builder ) {\n\n\t\tif ( builder.clippingContext === null ) return null;\n\n\t\tconst { unionPlanes, intersectionPlanes } = builder.clippingContext;\n\n\t\tlet result = null;\n\n\t\tif ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {\n\n\t\t\tconst samples = builder.renderer.samples;\n\n\t\t\tif ( this.alphaToCoverage && samples > 1 ) {\n\n\t\t\t\t// to be added to flow when the color/alpha value has been determined\n\t\t\t\tresult = clippingAlpha();\n\n\t\t\t} else {\n\n\t\t\t\tbuilder.stack.add( clipping() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Setups the hardware clipping if available on the current device.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupHardwareClipping( builder ) {\n\n\t\tthis.hardwareClipping = false;\n\n\t\tif ( builder.clippingContext === null ) return;\n\n\t\tconst candidateCount = builder.clippingContext.unionPlanes.length;\n\n\t\t// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n\t\tif ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {\n\n\t\t\tbuilder.stack.add( hardwareClipping() );\n\n\t\t\tthis.hardwareClipping = true;\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t/**\n\t * Setups the depth of this material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupDepth( builder ) {\n\n\t\tconst { renderer, camera } = builder;\n\n\t\t// Depth\n\n\t\tlet depthNode = this.depthNode;\n\n\t\tif ( depthNode === null ) {\n\n\t\t\tconst mrt = renderer.getMRT();\n\n\t\t\tif ( mrt && mrt.has( 'depth' ) ) {\n\n\t\t\t\tdepthNode = mrt.get( 'depth' );\n\n\t\t\t} else if ( renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tdepthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdepthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( depthNode !== null ) {\n\n\t\t\tdepth.assign( depthNode ).append();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups the position node in view space. This method exists\n\t * so derived node materials can modify the implementation e.g. sprite materials.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in view space.\n\t */\n\tsetupPositionView( /*builder*/ ) {\n\n\t\treturn modelViewMatrix.mul( positionLocal ).xyz;\n\n\t}\n\n\t/**\n\t * Setups the position in clip space.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The position in view space.\n\t */\n\tsetupModelViewProjection( /*builder*/ ) {\n\n\t\treturn cameraProjectionMatrix.mul( positionView );\n\n\t}\n\n\t/**\n\t * Setups the logic for the vertex stage.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The position in clip space.\n\t */\n\tsetupVertex( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tthis.setupPosition( builder );\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\n\t\treturn modelViewProjection;\n\n\t}\n\n\t/**\n\t * Setups the computation of the position in local space.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in local space.\n\t */\n\tsetupPosition( builder ) {\n\n\t\tconst { object, geometry } = builder;\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tmorphReference( object ).append();\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tskinningReference( object ).append();\n\n\t\t}\n\n\t\tif ( this.displacementMap ) {\n\n\t\t\tconst displacementMap = materialReference( 'displacementMap', 'texture' );\n\t\t\tconst displacementScale = materialReference( 'displacementScale', 'float' );\n\t\t\tconst displacementBias = materialReference( 'displacementBias', 'float' );\n\n\t\t\tpositionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tbatch( object ).append();\n\n\t\t}\n\n\t\tif ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {\n\n\t\t\tinstancedMesh( object ).append();\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tpositionLocal.assign( this.positionNode.context( { isPositionNodeInput: true } ) );\n\n\t\t}\n\n\t\treturn positionLocal;\n\n\t}\n\n\t/**\n\t * Setups the computation of the material's diffuse color.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {BufferGeometry} geometry - The geometry.\n\t */\n\tsetupDiffuseColor( { object, geometry } ) {\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );\n\n\t\t}\n\n\t\t// Instanced colors\n\n\t\tif ( object.instanceColor ) {\n\n\t\t\tconst instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );\n\n\t\t\tcolorNode = instanceColor.mul( colorNode );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh && object._colorsTexture ) {\n\n\t\t\tconst batchColor = varyingProperty( 'vec3', 'vBatchColor' );\n\n\t\t\tcolorNode = batchColor.mul( colorNode );\n\n\t\t}\n\n\n\t\t// COLOR\n\n\t\tdiffuseColor.assign( colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tdiffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tdiffuseColor.a.lessThanEqual( alphaTestNode ).discard();\n\n\t\t}\n\n\t\t// ALPHA HASH\n\n\t\tif ( this.alphaHash === true ) {\n\n\t\t\tdiffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();\n\n\t\t}\n\n\t\tif ( this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false ) {\n\n\t\t\tdiffuseColor.a.assign( 1.0 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract interface method that can be implemented by derived materials\n\t * to setup material-specific node variables.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\t/**\n\t * Setups the outgoing light node variable\n\t *\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupOutgoingLight() {\n\n\t\treturn ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;\n\n\t}\n\n\t/**\n\t * Setups the normal node from the material.\n\t *\n\t * @return {Node<vec3>} The normal node.\n\t */\n\tsetupNormal() {\n\n\t\treturn this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t}\n\n\t/**\n\t * Setups the environment node from the material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The environment node.\n\t */\n\tsetupEnvironment( /*builder*/ ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Setups the light map node from the material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The light map node.\n\t */\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new IrradianceNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Setups the lights node based on the scene, environment and material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {LightsNode} The lights node.\n\t */\n\tsetupLights( builder ) {\n\n\t\tconst materialLightsNode = [];\n\n\t\t//\n\n\t\tconst envNode = this.setupEnvironment( builder );\n\n\t\tif ( envNode && envNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( envNode );\n\n\t\t}\n\n\t\tconst lightMapNode = this.setupLightMap( builder );\n\n\t\tif ( lightMapNode && lightMapNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( lightMapNode );\n\n\t\t}\n\n\t\tif ( this.aoNode !== null || builder.material.aoMap ) {\n\n\t\t\tconst aoNode = this.aoNode !== null ? this.aoNode : materialAO;\n\n\t\t\tmaterialLightsNode.push( new AONode( aoNode ) );\n\n\t\t}\n\n\t\tlet lightsN = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsN;\n\n\t}\n\n\t/**\n\t * This method should be implemented by most derived materials\n\t * since it defines the material's lighting model.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {LightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\t/**\n\t * Setups the outgoing light node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = this.setupOutgoingLight( builder );\n\n\t\tif ( lightsNode && lightsNode.getScope().hasLights ) {\n\n\t\t\tconst lightingModel = this.setupLightingModel( builder );\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\temissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( emissive );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t/**\n\t * Setups the output node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node<vec4>} outputNode - The existing output node.\n\t * @return {Node<vec4>} The output node.\n\t */\n\tsetupOutput( builder, outputNode ) {\n\n\t\t// FOG\n\n\t\tif ( this.fog === true ) {\n\n\t\t\tconst fogNode = builder.fogNode;\n\n\t\t\tif ( fogNode ) {\n\n\t\t\t\toutput.assign( outputNode );\n\n\t\t\t\toutputNode = vec4( fogNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\t/**\n\t * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`\n\t * there is `MeshBasicNodeMaterial`. This utility method is intended for\n\t * defining all material properties of the classic type in the node type.\n\t *\n\t * @param {Material} material - The material to copy properties with their values to this node material.\n\t */\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes this material to JSON.\n\t *\n\t * @param {(Object|String)?} meta - The meta information for serialization.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeChildren = getNodeChildren( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of nodeChildren ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Copies the properties of the given node material to this instance.\n\t *\n\t * @param {NodeMaterial} source - The material to copy.\n\t * @return {NodeMaterial} A reference to this node material.\n\t */\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.geometryNode = source.geometryNode;\n\n\t\tthis.depthNode = source.depthNode;\n\t\tthis.shadowPositionNode = source.shadowPositionNode;\n\t\tthis.receivedShadowNode = source.receivedShadowNode;\n\t\tthis.castShadowNode = source.castShadowNode;\n\n\t\tthis.outputNode = source.outputNode;\n\t\tthis.mrtNode = source.mrtNode;\n\n\t\tthis.fragmentNode = source.fragmentNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();\n\n/**\n * Node material version of `LineBasicMaterial`.\n *\n * @augments NodeMaterial\n */\nclass LineBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineBasicNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new line basic node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineBasicNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$d );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nconst _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();\n\n/**\n * Node material version of `LineDashedMaterial`.\n *\n * @augments NodeMaterial\n */\nclass LineDashedNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineDashedNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new line dashed node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineDashedNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$c );\n\n\t\t/**\n\t\t * The dash offset.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.dashOffset = 0;\n\n\t\t/**\n\t\t * The offset of dash materials is by default inferred from the `dashOffset`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the offset with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the offset but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialLineDashOffset}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * The scale of dash materials is by default inferred from the `scale`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the scale with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the scale but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialLineScale}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dashScaleNode = null;\n\n\t\t/**\n\t\t * The dash size of dash materials is by default inferred from the `dashSize`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the dash size with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the dash size but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialLineDashSize}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dashSizeNode = null;\n\n\t\t/**\n\t\t * The gap size of dash materials is by default inferred from the `gapSize`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the gap size with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the gap size but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialLineGapSize}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the dash specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /* builder */ ) {\n\n\t\tconst offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;\n\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\tconst gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;\n\n\t\tdashSize.assign( dashSizeNode );\n\t\tgapSize.assign( gapSizeNode );\n\n\t\tconst vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );\n\t\tconst vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;\n\n\t\tvLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();\n\n\t}\n\n}\n\n/** @module ViewportSharedTextureNode **/\n\nlet _sharedFramebuffer = null;\n\n/**\n * `ViewportTextureNode` creates an internal texture for each node instance. This module\n * shares a texture across all instances of `ViewportSharedTextureNode`. It should\n * be the first choice when using data of the default/screen framebuffer for performance reasons.\n *\n * @augments module:ViewportTextureNode~ViewportTextureNode\n */\nclass ViewportSharedTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportSharedTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport shared texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {Node?} [levelNode=null] - The level node.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( _sharedFramebuffer === null ) {\n\n\t\t\t_sharedFramebuffer = new FramebufferTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, _sharedFramebuffer );\n\n\t}\n\n\tupdateReference() {\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a shared viewport texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @returns {ViewportSharedTextureNode}\n */\nconst viewportSharedTexture = /*@__PURE__*/ nodeProxy( ViewportSharedTextureNode );\n\nconst _defaultValues$b = /*@__PURE__*/ new LineDashedMaterial();\n\n/**\n * This node material can be used to render lines with a size larger than one\n * by representing them as instanced meshes.\n *\n * @augments NodeMaterial\n */\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'Line2NodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new node material for wide line rendering.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLine2NodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$b );\n\n\t\t/**\n\t\t * Whether vertex colors should be used or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useColor = parameters.vertexColors;\n\n\t\t/**\n\t\t * The dash offset.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.dashOffset = 0;\n\n\t\t/**\n\t\t * The line width.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.lineWidth = 1;\n\n\t\t/**\n\t\t * Defines the lines color.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.lineColorNode = null;\n\n\t\t/**\n\t\t * Defines the offset.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * Defines the dash scale.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dashScaleNode = null;\n\n\t\t/**\n\t\t * Defines the dash size.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dashSizeNode = null;\n\n\t\t/**\n\t\t * Defines the gap size.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.gapSizeNode = null;\n\n\t\t/**\n\t\t * Blending is set to `NoBlending` since transparency\n\t\t * is not supported, yet.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.blending = NoBlending;\n\n\t\tthis._useDash = parameters.dashed;\n\t\tthis._useAlphaToCoverage = true;\n\t\tthis._useWorldUnits = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst useAlphaToCoverage = this._useAlphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this._useDash;\n\t\tconst useWorldUnits = this._useWorldUnits;\n\n\t\tconst trimSegment = Fn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( - 0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'trimSegment',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'start', type: 'vec4' },\n\t\t\t\t{ name: 'end', type: 'vec4' }\n\t\t\t]\n\t\t} );\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = vec4( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ).toVar( 'start' );\n\t\t\tconst end = vec4( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) ).toVar( 'end' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tlet lineDistance = positionGeometry.y.lessThan( 0.5 ).select( dashScaleNode.mul( instanceDistanceStart ), dashScaleNode.mul( instanceDistanceEnd ) );\n\t\t\t\tlineDistance = lineDistance.add( offsetNode );\n\n\t\t\t\tvaryingProperty( 'float', 'lineDistance' ).assign( lineDistance );\n\n\t\t\t}\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tvaryingProperty( 'vec3', 'worldStart' ).assign( start.xyz );\n\t\t\t\tvaryingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tIf( perspective, () => {\n\n\t\t\t\tIf( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {\n\n\t\t\t\t\tend.assign( trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).ElseIf( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\t\tstart.assign( trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy ).toVar();\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x.assign( dir.x.mul( aspect ) );\n\t\t\tdir.assign( dir.normalize() );\n\n\t\t\tconst clip = vec4().toVar();\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\t\t\t\tconst tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();\n\t\t\t\tconst worldUp = worldDir.cross( tmpFwd ).normalize();\n\t\t\t\tconst worldFwd = worldDir.cross( worldUp );\n\n\t\t\t\tconst worldPos = varyingProperty( 'vec4', 'worldPos' );\n\n\t\t\t\tworldPos.assign( positionGeometry.y.lessThan( 0.5 ).select( start, end ) );\n\n\t\t\t\t// height offset\n\t\t\t\tconst hw = materialLineWidth.mul( 0.5 );\n\t\t\t\tworldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).select( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).select( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tIf( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {\n\n\t\t\t\t\t\tworldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// project the worldpos\n\t\t\t\tclip.assign( cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = vec3().toVar();\n\n\t\t\t\tclipPose.assign( positionGeometry.y.lessThan( 0.5 ).select( ndcStart, ndcEnd ) );\n\t\t\t\tclip.z.assign( clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = vec2( dir.y, dir.x.negate() ).toVar( 'offset' );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x.assign( dir.x.div( aspect ) );\n\t\t\t\toffset.x.assign( offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\toffset.assign( positionGeometry.x.lessThan( 0.0 ).select( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tIf( positionGeometry.y.lessThan( 0.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.sub( dir ) );\n\n\t\t\t\t} ).ElseIf( positionGeometry.y.greaterThan( 1.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset.assign( offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset.assign( offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tclip.assign( positionGeometry.y.lessThan( 0.5 ).select( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset.assign( offset.mul( clip.w ) );\n\n\t\t\t\tclip.assign( clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} )();\n\n\t\tconst closestLineToLine = Fn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = p13.dot( p43 );\n\t\t\tconst d4321 = p43.dot( p21 );\n\t\t\tconst d1321 = p13.dot( p21 );\n\t\t\tconst d4343 = p43.dot( p43 );\n\t\t\tconst d2121 = p21.dot( p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = numer.div( denom ).clamp();\n\t\t\tconst mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.colorNode = Fn( () => {\n\n\t\t\tconst vUv = uv();\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;\n\n\t\t\t\tdashSize.assign( dashSizeNode );\n\t\t\t\tgapSize.assign( gapSizeNode );\n\n\t\t\t\tconst vLineDistance = varyingProperty( 'float', 'lineDistance' );\n\n\t\t\t\tvUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps\n\t\t\t\tvLineDistance.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX\n\n\t\t\t}\n\n\t\t\tconst alpha = float( 1 ).toVar( 'alpha' );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tconst worldStart = varyingProperty( 'vec3', 'worldStart' );\n\t\t\t\tconst worldEnd = varyingProperty( 'vec3', 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\talpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnorm.greaterThan( 0.5 ).discard();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\tconst dlen = float( len2.fwidth() ).toVar( 'dlen' );\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tconst instanceColor = positionGeometry.y.lessThan( 0.5 ).select( instanceColorStart, instanceColorEnd );\n\n\t\t\t\t\tlineColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} )();\n\n\t\tif ( this.transparent ) {\n\n\t\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t\tthis.outputNode = vec4( this.colorNode.rgb.mul( opacityNode ).add( viewportSharedTexture().rgb.mul( opacityNode.oneMinus() ) ), this.colorNode.a );\n\n\t\t}\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\t/**\n\t * Whether the lines should sized in world units or not.\n\t * When set to `false` the unit is pixel.\n\t *\n\t * @type {Boolean}\n\t * @default false\n\t */\n\tget worldUnits() {\n\n\t\treturn this._useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this._useWorldUnits !== value ) {\n\n\t\t\tthis._useWorldUnits = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether the lines should be dashed or not.\n\t *\n\t * @type {Boolean}\n\t * @default false\n\t */\n\tget dashed() {\n\n\t\treturn this._useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this._useDash !== value ) {\n\n\t\t\tthis._useDash = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether alpha to coverage should be used or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget alphaToCoverage() {\n\n\t\treturn this._useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this._useAlphaToCoverage !== value ) {\n\n\t\t\tthis._useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\n/** @module Packing **/\n\n/**\n * Packs a direction vector into a color value.\n *\n * @method\n * @param {Node<vec3>} node - The direction to pack.\n * @return {Node<vec3>} The color.\n */\nconst directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );\n\n/**\n * Unpacks a color value into a direction vector.\n *\n * @method\n * @param {Node<vec3>} node - The color to unpack.\n * @return {Node<vec3>} The direction.\n */\nconst colorToDirection = ( node ) => nodeObject( node ).mul( 2.0 ).sub( 1 );\n\nconst _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();\n\n/**\n * Node material version of `MeshNormalMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshNormalNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshNormalNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh normal node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshNormalNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$a );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation by computing the diffuse color\n\t * based on the normal data.\n\t */\n\tsetupDiffuseColor() {\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\tdiffuseColor.assign( vec4( directionToColor( transformedNormalView ), opacityNode ) );\n\n\t}\n\n}\n\n/** @module EquirectUVNode **/\n\n/**\n * Can be used to compute texture coordinates for projecting an\n * equirectangular texture onto a mesh for using it as the scene's\n * background.\n *\n * ```js\n * scene.backgroundNode = texture( equirectTexture, equirectUV() );\n * ```\n *\n * @augments TempNode\n */\nclass EquirectUVNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'EquirectUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new equirect uv node.\n\t *\n\t * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.\n\t */\n\tconstructor( dirNode = positionWorldDirection ) {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * A direction vector for sampling why is by default `positionWorldDirection`.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.dirNode = dirNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst dir = this.dirNode;\n\n\t\tconst u = dir.z.atan( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );\n\t\tconst v = dir.y.clamp( - 1.0, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );\n\n\t\treturn vec2( u, v );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an equirect uv node.\n *\n * @function\n * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.\n * @returns {EquirectUVNode}\n */\nconst equirectUV = /*@__PURE__*/ nodeProxy( EquirectUVNode );\n\n// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget\n\n/**\n * This class represents a cube render target. It is a special version\n * of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.\n *\n * @augments WebGLCubeRenderTarget\n */\nclass CubeRenderTarget extends WebGLCubeRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, options );\n\n\t\tthis.isCubeRenderTarget = true;\n\n\t}\n\n\t/**\n\t * Converts the given equirectangular texture to a cube map.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Texture} texture - The equirectangular texture.\n\t * @return {CubeRenderTarget} A reference to this cube render target.\n\t */\n\tfromEquirectangularTexture( renderer, texture$1 ) {\n\n\t\tconst currentMinFilter = texture$1.minFilter;\n\t\tconst currentGenerateMipmaps = texture$1.generateMipmaps;\n\n\t\ttexture$1.generateMipmaps = true;\n\n\t\tthis.texture.type = texture$1.type;\n\t\tthis.texture.colorSpace = texture$1.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture$1.generateMipmaps;\n\t\tthis.texture.minFilter = texture$1.minFilter;\n\t\tthis.texture.magFilter = texture$1.magFilter;\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst uvNode = equirectUV( positionWorldDirection );\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.colorNode = texture( texture$1, uvNode, 0 );\n\t\tmaterial.side = BackSide;\n\t\tmaterial.blending = NoBlending;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst scene = new Scene();\n\t\tscene.add( mesh );\n\n\t\t// Avoid blurred poles\n\t\tif ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\trenderer.setMRT( null );\n\n\t\tcamera.update( renderer, scene );\n\n\t\trenderer.setMRT( currentMRT );\n\n\t\ttexture$1.minFilter = currentMinFilter;\n\t\ttexture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n}\n\n/** @module CubeMapNode **/\n\nconst _cache$1 = new WeakMap();\n\n/**\n * This node can be used to automatically convert environment maps in the\n * equirectangular format into the cube map format.\n *\n * @augments TempNode\n */\nclass CubeMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cube map node.\n\t *\n\t * @param {Node} envNode - The node representing the environment map.\n\t */\n\tconstructor( envNode ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * The node representing the environment map.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t\t/**\n\t\t * A reference to the internal cube texture.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTexture}\n\t\t * @default null\n\t\t */\n\t\tthis._cubeTexture = null;\n\n\t\t/**\n\t\t * A reference to the internal cube texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTextureNode}\n\t\t */\n\t\tthis._cubeTextureNode = cubeTexture();\n\n\t\tconst defaultTexture = new CubeTexture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\t/**\n\t\t * A default cube texture that acts as a placeholder.\n\t\t * It is used when the conversion from equirectangular to cube\n\t\t * map has not finished yet for a given texture.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTexture}\n\t\t */\n\t\tthis._defaultTexture = defaultTexture;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n\t\t * the texture once per render in its {@link CubeMapNode#updateBefore} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer, material } = frame;\n\n\t\tconst envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tif ( texture && texture.isTexture ) {\n\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\t\t// check for converted cubemap map\n\n\t\t\t\t\tif ( _cache$1.has( texture ) ) {\n\n\t\t\t\t\t\tconst cubeMap = _cache$1.get( texture );\n\n\t\t\t\t\t\tmapTextureMapping( cubeMap, texture.mapping );\n\t\t\t\t\t\tthis._cubeTexture = cubeMap;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// create cube map from equirectangular map\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( isEquirectangularMapReady$1( image ) ) {\n\n\t\t\t\t\t\t\tconst renderTarget = new CubeRenderTarget( image.height );\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\n\t\t\t\t\t\t\tmapTextureMapping( renderTarget.texture, texture.mapping );\n\t\t\t\t\t\t\tthis._cubeTexture = renderTarget.texture;\n\n\t\t\t\t\t\t\t_cache$1.set( texture, renderTarget.texture );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// default cube texture as fallback when equirectangular texture is not yet loaded\n\n\t\t\t\t\t\t\tthis._cubeTexture = this._defaultTexture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tthis._cubeTextureNode.value = this._cubeTexture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// envNode already refers to a cube map\n\n\t\t\t\t\tthis._cubeTextureNode = this.envNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateBefore( builder );\n\n\t\treturn this._cubeTextureNode;\n\n\t}\n\n}\n\n/**\n * Returns true if the given equirectangular image has been fully loaded\n * and is ready for further processing.\n *\n * @private\n * @param {Image} image - The equirectangular image to check.\n * @return {Boolean} Whether the image is ready or not.\n */\nfunction isEquirectangularMapReady$1( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\n/**\n * This function is executed when `dispose()` is called on the equirectangular\n * texture. In this case, the generated cube map with its render target\n * is deleted as well.\n *\n * @private\n * @param {Object} event - The event object.\n */\nfunction onTextureDispose( event ) {\n\n\tconst texture = event.target;\n\n\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\tconst renderTarget = _cache$1.get( texture );\n\n\tif ( renderTarget !== undefined ) {\n\n\t\t_cache$1.delete( texture );\n\n\t\trenderTarget.dispose();\n\n\t}\n\n}\n\n/**\n * This function makes sure the generated cube map uses the correct\n * texture mapping that corresponds to the equirectangular original.\n *\n * @private\n * @param {Texture} texture - The cube texture.\n * @param {Number} mapping - The original texture mapping.\n */\nfunction mapTextureMapping( texture, mapping ) {\n\n\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\ttexture.mapping = CubeReflectionMapping;\n\n\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\ttexture.mapping = CubeRefractionMapping;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cube map node.\n *\n * @function\n * @param {Node} envNode - The node representing the environment map.\n * @returns {CubeMapNode}\n */\nconst cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode );\n\n/**\n * Represents a basic model for Image-based lighting (IBL). The environment\n * is defined via environment maps in the equirectangular or cube map format.\n * `BasicEnvironmentNode` is intended for non-PBR materials like {@link MeshBasicNodeMaterial}\n * or {@link MeshPhongNodeMaterial}.\n *\n * @augments LightingNode\n */\nclass BasicEnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicEnvironmentNode';\n\n\t}\n\n\t/**\n\t * Constructs a new basic environment node.\n\t *\n\t * @param {Node} [envNode=null] - A node representing the environment.\n\t */\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node representing the environment.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// environment property is used in the finish() method of BasicLightingModel\n\n\t\tbuilder.context.environment = cubeMapNode( this.envNode );\n\n\t}\n\n}\n\n/**\n * A specific version of {@link IrradianceNode} that is only relevant\n * for {@link MeshBasicNodeMaterial}. Since the material is unlit, it\n * requires a special scaling factor for the light map.\n *\n * @augments LightingNode\n */\nclass BasicLightMapNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicLightMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new basic light map node.\n\t *\n\t * @param {Node<vec3>?} [lightMapNode=null] - The light map node.\n\t */\n\tconstructor( lightMapNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light map node.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t */\n\t\tthis.lightMapNode = lightMapNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel\n\n\t\tconst RECIPROCAL_PI = float( 1 / Math.PI );\n\n\t\tbuilder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );\n\n\t}\n\n}\n\n/**\n * Abstract class for implementing lighting models. The module defines\n * multiple methods that concrete lighting models can implement. These\n * methods are executed at different points during the light evaluation\n * process.\n */\nclass LightingModel {\n\n\t/**\n\t * This method is intended for setting up lighting model and context data\n\t * which are later used in the evaluation process.\n\t *\n\t * @abstract\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tstart( /*input, stack, builder*/ ) { }\n\n\t/**\n\t * This method is intended for executing final tasks like final updates\n\t * to the outgoing light.\n\t *\n\t * @abstract\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( /*input, stack, builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the direct light term and\n\t * executed during the build process of directional, point and spot light nodes.\n\t *\n\t * @abstract\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( /*input, stack, builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the direct light term for\n\t * rect area light nodes.\n\t *\n\t * @abstract\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirectRectArea( /*input, stack, builder*/ ) {}\n\n\t/**\n\t * This method is intended for implementing the indirect light term.\n\t *\n\t * @abstract\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( /*input, stack, builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the ambient occlusion term.\n\t * Unlike other methods, this method must be called manually by the lighting\n\t * model in its indirect term.\n\t *\n\t * @abstract\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tambientOcclusion( /*input, stack, builder*/ ) { }\n\n}\n\n/**\n * Represents the lighting model for unlit materials. The only light contribution\n * is baked indirect lighting modulated with ambient occlusion and the material's\n * diffuse color. Environment mapping is supported. Used in {@link MeshBasicNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass BasicLightingModel extends LightingModel {\n\n\t/**\n\t * Constructs a new basic lighting model.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\t/**\n\t * Implements the baked indirect lighting with its modulation.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( context, stack, builder ) {\n\n\t\tconst ambientOcclusion = context.ambientOcclusion;\n\t\tconst reflectedLight = context.reflectedLight;\n\t\tconst irradianceLightMap = builder.context.irradianceLightMap;\n\n\t\treflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );\n\n\t\t// accumulation (baked indirect lighting only)\n\n\t\tif ( irradianceLightMap ) {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( irradianceLightMap );\n\n\t\t} else {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );\n\n\t\t}\n\n\t\t// modulation\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );\n\n\t}\n\n\t/**\n\t * Implements the environment mapping.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( context, stack, builder ) {\n\n\t\tconst material = builder.material;\n\t\tconst outgoingLight = context.outgoingLight;\n\t\tconst envNode = builder.context.environment;\n\n\t\tif ( envNode ) {\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\toutgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();\n\n/**\n * Node material version of `MeshBasicMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshBasicNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh basic node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshBasicNodeMaterial = true;\n\n\t\t/**\n\t\t * Although the basic material is by definition unlit, we set\n\t\t * this property to `true` since we use a lighting model to compute\n\t\t * the outgoing light of the fragment shader.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$9 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Basic materials are not affected by normal and bump maps so we\n\t * return by default {@link module:Normal.normalView}.\n\t *\n\t * @return {Node<vec3>} The normal node.\n\t */\n\tsetupNormal() {\n\n\t\treturn normalView; // see #28839\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {BasicEnvironmentNode<vec3>?} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * This method must be overwritten since light maps are evaluated\n\t * with a special scaling factor for basic materials.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {BasicLightMapNode<vec3>?} The light map node.\n\t */\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new BasicLightMapNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * The material overwrites this method because `lights` is set to `true` but\n\t * we still want to return the diffuse color as the outgoing light.\n\t *\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupOutgoingLight() {\n\n\t\treturn diffuseColor.rgb;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {BasicLightingModel} The lighting model.\n\t */\n\tsetupLightingModel() {\n\n\t\treturn new BasicLightingModel();\n\n\t}\n\n}\n\nconst F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tconst fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();\n\n\treturn f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );\n\n} ); // validated\n\nconst BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\treturn inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light\n\n} ); // validated\n\nconst G_BlinnPhong_Implicit = () => float( 0.25 );\n\nconst D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {\n\n\treturn shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );\n\n} );\n\nconst BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNH = transformedNormalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tconst F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );\n\tconst G = G_BlinnPhong_Implicit();\n\tconst D = D_BlinnPhong( { dotNH } );\n\n\treturn F.mul( G ).mul( D );\n\n} );\n\n/**\n * Represents the lighting model for a phong material. Used in {@link MeshPhongNodeMaterial}.\n *\n * @augments BasicLightingModel\n */\nclass PhongLightingModel extends BasicLightingModel {\n\n\t/**\n\t * Constructs a new phong lighting model.\n\t *\n\t * @param {Boolean} [specular=true] - Whether specular is supported or not.\n\t */\n\tconstructor( specular = true ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Whether specular is supported or not. Set this to `false` if you are\n\t\t * looking for a Lambert-like material meaning a material for non-shiny\n\t\t * surfaces, without specular highlights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.specular = specular;\n\n\t}\n\n\t/**\n\t * Implements the direct lighting. The specular portion is optional an can be controlled\n\t * with the {@link PhongLightingModel#specular} flag.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\tif ( this.specular === true ) {\n\n\t\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( { ambientOcclusion, irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();\n\n/**\n * Node material version of `MeshLambertMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshLambertNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshLambertNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh lambert node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshLambertNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because lambert materials react on lights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$8 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {BasicEnvironmentNode<vec3>?} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhongLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel( false ); // ( specular ) -> force lambert\n\n\t}\n\n}\n\nconst _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();\n\n/**\n * Node material version of `MeshPhongMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshPhongNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhongNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh lambert node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshPhongNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because phong materials react on lights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\t/**\n\t\t * The shininess of phong materials is by default inferred from the `shininess`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the shininess with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the shininess but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialShininess}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.shininessNode = null;\n\n\t\t/**\n\t\t * The specular color of phong materials is by default inferred from the\n\t\t * `specular` property. This node property allows to overwrite the default\n\t\t * and define the specular color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular color but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSpecular}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.specularNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$7 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {BasicEnvironmentNode<vec3>?} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhongLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel();\n\n\t}\n\n\t/**\n\t * Setups the phong specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// SHININESS\n\n\t\tconst shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tshininess.assign( shininessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tconst specularNode = this.specularNode || materialSpecular;\n\n\t\tspecularColor.assign( specularNode );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.shininessNode = source.shininessNode;\n\t\tthis.specularNode = source.specularNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGeometryRoughness = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\treturn float( 0 );\n\n\t}\n\n\tconst dxy = normalView.dFdx().abs().max( normalView.dFdy().abs() );\n\tconst geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );\n\n\treturn geometryRoughness;\n\n} );\n\nconst getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { roughness } = inputs;\n\n\tconst geometryRoughness = getGeometryRoughness();\n\n\tlet roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\n\troughnessFactor = roughnessFactor.add( geometryRoughness );\n\troughnessFactor = roughnessFactor.min( 1.0 );\n\n\treturn roughnessFactor;\n\n} );\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );\n\tconst gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );\n\n\treturn div( 0.5, gv.add( gl ).max( EPSILON ) );\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' },\n\t\t{ name: 'dotNV', type: 'float' }\n\t]\n} ); // validated\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {\n\n\tconst gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );\n\tconst gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );\n\tconst v = div( 0.5, gv.add( gl ) );\n\n\treturn v.saturate();\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNL', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nconst D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1\n\n\treturn a2.div( denom.pow2() ).mul( 1 / Math.PI );\n\n} ).setLayout( {\n\tname: 'D_GGX',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} ); // validated\n\nconst RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {\n\n\tconst a2 = alphaT.mul( alphaB );\n\tconst v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );\n\tconst v2 = v.dot( v );\n\tconst w2 = a2.div( v2 );\n\n\treturn RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );\n\n} ).setLayout( {\n\tname: 'D_GGX_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBH', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { lightDirection, f0, f90, roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;\n\n\tconst normalView = inputs.normalView || transformedNormalView;\n\n\tconst alpha = roughness.pow2(); // UE4's roughness\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = normalView.dot( lightDirection ).clamp();\n\tconst dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\tconst dotNH = normalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tlet F = F_Schlick( { f0, f90, dotVH } );\n\tlet V, D;\n\n\tif ( defined( USE_IRIDESCENCE ) ) {\n\n\t\tF = iridescence.mix( F, f );\n\n\t}\n\n\tif ( defined( USE_ANISOTROPY ) ) {\n\n\t\tconst dotTL = anisotropyT.dot( lightDirection );\n\t\tconst dotTV = anisotropyT.dot( positionViewDirection );\n\t\tconst dotTH = anisotropyT.dot( halfDir );\n\t\tconst dotBL = anisotropyB.dot( lightDirection );\n\t\tconst dotBV = anisotropyB.dot( positionViewDirection );\n\t\tconst dotBH = anisotropyB.dot( halfDir );\n\n\t\tV = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );\n\t\tD = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );\n\n\t} else {\n\n\t\tV = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );\n\t\tD = D_GGX( { alpha, dotNH } );\n\n\t}\n\n\treturn F.mul( V ).mul( D );\n\n} ); // validated\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nconst DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {\n\n\tconst c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tconst r = roughness.mul( c0 ).add( c1 );\n\n\tconst a004 = r.x.mul( r.x ).min( dotNV.mul( - 9.28 ).exp2() ).mul( r.x ).add( r.y );\n\n\tconst fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );\n\n\treturn fab;\n\n} ).setLayout( {\n\tname: 'DFGApprox',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNV', type: 'vec3' }\n\t]\n} );\n\nconst EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { dotNV, specularColor, specularF90, roughness } = inputs;\n\n\tconst fab = DFGApprox( { dotNV, roughness } );\n\treturn specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n} );\n\nconst Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {\n\n\tconst x = dotVH.oneMinus().saturate();\n\tconst x2 = x.mul( x );\n\tconst x5 = x.mul( x2, x2 ).clamp( 0, .9999 );\n\n\treturn f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );\n\n} ).setLayout( {\n\tname: 'Schlick_to_F0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' },\n\t\t{ name: 'f90', type: 'float' },\n\t\t{ name: 'dotVH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {\n\n\tconst alpha = roughness.pow2();\n\n\t// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n\tconst invAlpha = float( 1.0 ).div( alpha );\n\tconst cos2h = dotNH.pow2();\n\tconst sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );\n\n} ).setLayout( {\n\tname: 'D_Charlie',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {\n\n\t// Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n\treturn float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );\n\n} ).setLayout( {\n\tname: 'V_Neubelt',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'dotNV', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' }\n\t]\n} );\n\nconst BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp();\n\tconst dotNH = transformedNormalView.dot( halfDir ).clamp();\n\n\tconst D = D_Charlie( { roughness: sheenRoughness, dotNH } );\n\tconst V = V_Neubelt( { dotNV, dotNL } );\n\n\treturn sheen.mul( D ).mul( V );\n\n} );\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {\n\n\tconst LUT_SIZE = 64.0;\n\tconst LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tconst dotNV = N.dot( V ).saturate();\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tconst uv = vec2( roughness, dotNV.oneMinus().sqrt() );\n\n\tuv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );\n\n\treturn uv;\n\n} ).setLayout( {\n\tname: 'LTC_Uv',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tconst l = f.length();\n\n\treturn max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );\n\n} ).setLayout( {\n\tname: 'LTC_ClippedSphereFormFactor',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' }\n\t]\n} );\n\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {\n\n\tconst x = v1.dot( v2 );\n\tconst y = x.abs().toVar();\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tconst a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();\n\tconst b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();\n\tconst v = a.div( b );\n\n\tconst theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );\n\n\treturn v1.cross( v2 ).mul( theta_sintheta );\n\n} ).setLayout( {\n\tname: 'LTC_EdgeVectorFormFactor',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' }\n\t]\n} );\n\nconst LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tconst v1 = p1.sub( p0 ).toVar();\n\tconst v2 = p3.sub( p0 ).toVar();\n\n\tconst lightNormal = v1.cross( v2 );\n\tconst result = vec3().toVar();\n\n\tIf( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {\n\n\t\t// construct orthonormal basis around N\n\t\tconst T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();\n\t\tconst T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t\t// compute transform\n\t\tconst mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();\n\n\t\t// transform rect\n\t\t// & project rect onto sphere\n\t\tconst coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();\n\t\tconst coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();\n\t\tconst coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();\n\t\tconst coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();\n\n\t\t// calculate vector form factor\n\t\tconst vectorFormFactor = vec3( 0 ).toVar();\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );\n\n\t\t// adjust for horizon clipping\n\t\tresult.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'LTC_Evaluate',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'P', type: 'vec3' },\n\t\t{ name: 'mInv', type: 'mat3' },\n\t\t{ name: 'p0', type: 'vec3' },\n\t\t{ name: 'p1', type: 'vec3' },\n\t\t{ name: 'p2', type: 'vec3' },\n\t\t{ name: 'p3', type: 'vec3' }\n\t]\n} );\n\n/** @module TextureBicubic **/\n\n// Mipped Bicubic Texture Filtering by N8\n// https://www.shadertoy.com/view/Dl2SDW\n\nconst bC = 1.0 / 6.0;\n\nconst w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );\n\nconst w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );\n\nconst w2 = ( a ) => mul( bC, mul( a, mul( a, mul( - 3.0, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );\n\nconst w3 = ( a ) => mul( bC, pow( a, 3 ) );\n\nconst g0 = ( a ) => w0( a ).add( w1( a ) );\n\nconst g1 = ( a ) => w2( a ).add( w3( a ) );\n\n// h0 and h1 are the two offset functions\nconst h0 = ( a ) => add( - 1.0, w1( a ).div( w0( a ).add( w1( a ) ) ) );\n\nconst h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );\n\nconst bicubic = ( textureNode, texelSize, lod ) => {\n\n\tconst uv = textureNode.uvNode;\n\tconst uvScaled = mul( uv, texelSize.zw ).add( 0.5 );\n\n\tconst iuv = floor( uvScaled );\n\tconst fuv = fract( uvScaled );\n\n\tconst g0x = g0( fuv.x );\n\tconst g1x = g1( fuv.x );\n\tconst h0x = h0( fuv.x );\n\tconst h1x = h1( fuv.x );\n\tconst h0y = h0( fuv.y );\n\tconst h1y = h1( fuv.y );\n\n\tconst p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\n\tconst a = g0( fuv.y ).mul( add( g0x.mul( textureNode.sample( p0 ).level( lod ) ), g1x.mul( textureNode.sample( p1 ).level( lod ) ) ) );\n\tconst b = g1( fuv.y ).mul( add( g0x.mul( textureNode.sample( p2 ).level( lod ) ), g1x.mul( textureNode.sample( p3 ).level( lod ) ) ) );\n\n\treturn a.add( b );\n\n};\n\n/**\n * Applies mipped bicubic texture filtering to the given texture node.\n *\n * @method\n * @param {TextureNode} textureNode - The texture node that should be filtered.\n * @param {Node<float>} [lodNode=float(3)] - Defines the LOD to sample from.\n * @return {Node} The filtered texture sample.\n */\nconst textureBicubic = /*@__PURE__*/ Fn( ( [ textureNode, lodNode = float( 3 ) ] ) => {\n\n\tconst fLodSize = vec2( textureNode.size( int( lodNode ) ) );\n\tconst cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );\n\tconst fLodSizeInv = div( 1.0, fLodSize );\n\tconst cLodSizeInv = div( 1.0, cLodSize );\n\tconst fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );\n\tconst cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );\n\n\treturn fract( lodNode ).mix( fSample, cSample );\n\n} );\n\n//\n// Transmission\n//\n\nconst getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {\n\n\t// Direction of refracted light.\n\tconst refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );\n\n\t// Compute rotation-independent scaling of the model matrix.\n\tconst modelScale = vec3(\n\t\tlength( modelMatrix[ 0 ].xyz ),\n\t\tlength( modelMatrix[ 1 ].xyz ),\n\t\tlength( modelMatrix[ 2 ].xyz )\n\t);\n\n\t// The thickness is specified in local space.\n\treturn normalize( refractionVector ).mul( thickness.mul( modelScale ) );\n\n} ).setLayout( {\n\tname: 'getVolumeTransmissionRay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'n', type: 'vec3' },\n\t\t{ name: 'v', type: 'vec3' },\n\t\t{ name: 'thickness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' },\n\t\t{ name: 'modelMatrix', type: 'mat4' }\n\t]\n} );\n\nconst applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {\n\n\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\treturn roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );\n\n} ).setLayout( {\n\tname: 'applyIorToRoughness',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' }\n\t]\n} );\n\nconst viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();\nconst viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();\n\nconst getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ], { material } ) => {\n\n\tconst vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;\n\n\tconst transmissionSample = vTexture.sample( fragCoord );\n\t//const transmissionSample = viewportMipTexture( fragCoord );\n\n\tconst lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );\n\n\treturn textureBicubic( transmissionSample, lod );\n\n} );\n\nconst volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {\n\n\tIf( attenuationDistance.notEqual( 0 ), () => {\n\n\t\t// Compute light attenuation using Beer's law.\n\t\tconst attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );\n\t\tconst transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );\n\n\t\treturn transmittance;\n\n\t} );\n\n\t// Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n\treturn vec3( 1.0 );\n\n} ).setLayout( {\n\tname: 'volumeAttenuation',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'transmissionDistance', type: 'float' },\n\t\t{ name: 'attenuationColor', type: 'vec3' },\n\t\t{ name: 'attenuationDistance', type: 'float' }\n\t]\n} );\n\nconst getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {\n\n\tlet transmittedLight, transmittance;\n\n\tif ( dispersion ) {\n\n\t\ttransmittedLight = vec4().toVar();\n\t\ttransmittance = vec3().toVar();\n\n\t\tconst halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );\n\t\tconst iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );\n\n\t\tLoop( { start: 0, end: 3 }, ( { i } ) => {\n\n\t\t\tconst ior = iors.element( i );\n\n\t\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\t\trefractionCoords.addAssign( 1.0 );\n\t\t\trefractionCoords.divAssign( 2.0 );\n\t\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\tconst transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\t\ttransmittedLight.element( i ).assign( transmissionSample.element( i ) );\n\t\t\ttransmittedLight.a.addAssign( transmissionSample.a );\n\n\t\t\ttransmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );\n\n\t\t} );\n\n\t\ttransmittedLight.a.divAssign( 3.0 );\n\n\t} else {\n\n\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\trefractionCoords.addAssign( 1.0 );\n\t\trefractionCoords.divAssign( 2.0 );\n\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\ttransmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );\n\n\t}\n\n\tconst attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );\n\tconst dotNV = n.dot( v ).clamp();\n\n\t// Get the specular component.\n\tconst F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness\n\t\tdotNV,\n\t\tspecularColor,\n\t\tspecularF90,\n\t\troughness\n\t} ) );\n\n\t// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job\n\t// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n\tconst transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );\n\n\treturn vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );\n\n} );\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = /*@__PURE__*/ mat3(\n\t3.2404542, - 0.9692660, 0.0556434,\n\t- 1.5371385, 1.8760108, - 0.2040259,\n\t- 0.4985314, 0.0415560, 1.0572252\n);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = ( fresnel0 ) => {\n\n\tconst sqrtF0 = fresnel0.sqrt();\n\treturn vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );\n\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = ( transmittedIor, incidentIor ) => {\n\n\treturn transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();\n\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = ( OPD, shift ) => {\n\n\tconst phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );\n\tconst val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\tconst pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\tconst VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\tconst x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( - 4.5282e+09 ).exp() );\n\n\tlet xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );\n\txyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );\n\n\tconst rgb = XYZ_TO_REC709.mul( xyz );\n\n\treturn rgb;\n\n};\n\nconst evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {\n\n\t// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n\tconst iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t// Evaluate the cosTheta on the base layer (Snell law)\n\tconst sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );\n\n\t// Handle TIR:\n\tconst cosTheta2Sq = sinTheta2Sq.oneMinus();\n\n\tIf( cosTheta2Sq.lessThan( 0 ), () => {\n\n\t\treturn vec3( 1.0 );\n\n\t} );\n\n\tconst cosTheta2 = cosTheta2Sq.sqrt();\n\n\t// First interface\n\tconst R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\tconst R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );\n\t//const R21 = R12;\n\tconst T121 = R12.oneMinus();\n\tconst phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );\n\tconst phi21 = float( Math.PI ).sub( phi12 );\n\n\t// Second interface\n\tconst baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0\n\tconst R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );\n\tconst R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );\n\tconst phi23 = vec3(\n\t\tbaseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )\n\t);\n\n\t// Phase shift\n\tconst OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );\n\tconst phi = vec3( phi21 ).add( phi23 );\n\n\t// Compound terms\n\tconst R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );\n\tconst r123 = R123.sqrt();\n\tconst Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );\n\n\t// Reflectance term for m = 0 (DC term amplitude)\n\tconst C0 = R12.add( Rs );\n\tconst I = C0.toVar();\n\n\t// Reflectance term for m > 0 (pairs of diracs)\n\tconst Cm = Rs.sub( T121 ).toVar();\n\n\tLoop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {\n\n\t\tCm.mulAssign( r123 );\n\t\tconst Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );\n\t\tI.addAssign( Cm.mul( Sm ) );\n\n\t} );\n\n\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\treturn I.max( vec3( 0.0 ) );\n\n} ).setLayout( {\n\tname: 'evalIridescence',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'outsideIOR', type: 'float' },\n\t\t{ name: 'eta2', type: 'float' },\n\t\t{ name: 'cosTheta1', type: 'float' },\n\t\t{ name: 'thinFilmThickness', type: 'float' },\n\t\t{ name: 'baseF0', type: 'vec3' }\n\t]\n} );\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approximation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {\n\n\tconst dotNV = normal.dot( viewDir ).saturate();\n\n\tconst r2 = roughness.pow2();\n\n\tconst a = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( - 339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),\n\t\tfloat( - 8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )\n\t);\n\n\tconst b = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),\n\t\tfloat( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )\n\t);\n\n\tconst DG = select( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );\n\n\treturn DG.mul( 1.0 / Math.PI ).saturate();\n\n} );\n\nconst clearcoatF0 = vec3( 0.04 );\nconst clearcoatF90 = float( 1 );\n\n\n/**\n * Represents the lighting model for a PBR material.\n *\n * @augments LightingModel\n */\nclass PhysicalLightingModel extends LightingModel {\n\n\t/**\n\t * Constructs a new physical lighting model.\n\t *\n\t * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n\t * @param {Boolean} [sheen=false] - Whether sheen is supported or not.\n\t * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.\n\t * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n\t * @param {Boolean} [transmission=false] - Whether transmission is supported or not.\n\t * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.\n\t */\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Whether clearcoat is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clearcoat = clearcoat;\n\n\t\t/**\n\t\t * Whether sheen is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.sheen = sheen;\n\n\t\t/**\n\t\t * Whether iridescence is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.iridescence = iridescence;\n\n\t\t/**\n\t\t * Whether anisotropy is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.anisotropy = anisotropy;\n\n\t\t/**\n\t\t * Whether transmission is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.transmission = transmission;\n\n\t\t/**\n\t\t * Whether dispersion is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.dispersion = dispersion;\n\n\t\t/**\n\t\t * The clear coat radiance.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatRadiance = null;\n\n\t\t/**\n\t\t * The clear coat specular direct.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatSpecularDirect = null;\n\n\t\t/**\n\t\t * The clear coat specular indirect.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatSpecularIndirect = null;\n\n\t\t/**\n\t\t * The sheen specular direct.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenSpecularDirect = null;\n\n\t\t/**\n\t\t * The sheen specular indirect.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenSpecularIndirect = null;\n\n\t\t/**\n\t\t * The iridescence Fresnel.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceFresnel = null;\n\n\t\t/**\n\t\t * The iridescence F0.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceF0 = null;\n\n\t}\n\n\t/**\n\t * Depending on what features are requested, the method prepares certain node variables\n\t * which are later used for lighting computations.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t */\n\tstart( context ) {\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );\n\t\t\tthis.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );\n\t\t\tthis.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );\n\t\t\tthis.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.iridescence === true ) {\n\n\t\t\tconst dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tthis.iridescenceFresnel = evalIridescence( {\n\t\t\t\toutsideIOR: float( 1.0 ),\n\t\t\t\teta2: iridescenceIOR,\n\t\t\t\tcosTheta1: dotNVi,\n\t\t\t\tthinFilmThickness: iridescenceThickness,\n\t\t\t\tbaseF0: specularColor\n\t\t\t} );\n\n\t\t\tthis.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );\n\n\t\t}\n\n\t\tif ( this.transmission === true ) {\n\n\t\t\tconst position = positionWorld;\n\t\t\tconst v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX\n\t\t\tconst n = transformedNormalWorld;\n\n\t\t\tcontext.backdrop = getIBLVolumeRefraction(\n\t\t\t\tn,\n\t\t\t\tv,\n\t\t\t\troughness,\n\t\t\t\tdiffuseColor,\n\t\t\t\tspecularColor,\n\t\t\t\tspecularF90, // specularF90\n\t\t\t\tposition, // positionWorld\n\t\t\t\tmodelWorldMatrix, // modelMatrix\n\t\t\t\tcameraViewMatrix, // viewMatrix\n\t\t\t\tcameraProjectionMatrix, // projMatrix\n\t\t\t\tior,\n\t\t\t\tthickness,\n\t\t\t\tattenuationColor,\n\t\t\t\tattenuationDistance,\n\t\t\t\tthis.dispersion ? dispersion : null\n\t\t\t);\n\n\t\t\tcontext.backdropAlpha = transmission;\n\n\t\t\tdiffuseColor.a.mulAssign( mix( 1, context.backdrop.a, transmission ) );\n\n\t\t}\n\n\t}\n\n\t// Fdez-Agüera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n\t// Approximates multi-scattering in order to preserve energy.\n\t// http://www.jcgt.org/published/0008/01/03/\n\n\tcomputeMultiscattering( singleScatter, multiScatter, specularF90 ) {\n\n\t\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst fab = DFGApprox( { roughness, dotNV } );\n\n\t\tconst Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;\n\n\t\tconst FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n\t\tconst Ess = fab.x.add( fab.y );\n\t\tconst Ems = Ess.oneMinus();\n\n\t\tconst Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21\n\t\tconst Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );\n\n\t\tsingleScatter.addAssign( FssEss );\n\t\tmultiScatter.addAssign( Fms.mul( Ems ) );\n\n\t}\n\n\t/**\n\t * Implements the direct light.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();\n\t\t\tconst ccIrradiance = dotNLcc.mul( lightColor );\n\n\t\t\tthis.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );\n\n\t\t}\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );\n\n\t}\n\n\t/**\n\t * This method is intended for implementing the direct light term for\n\t * rect area light nodes.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirectRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {\n\n\t\tconst p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction\n\t\tconst p1 = lightPosition.sub( halfWidth ).sub( halfHeight );\n\t\tconst p2 = lightPosition.sub( halfWidth ).add( halfHeight );\n\t\tconst p3 = lightPosition.add( halfWidth ).add( halfHeight );\n\n\t\tconst N = transformedNormalView;\n\t\tconst V = positionViewDirection;\n\t\tconst P = positionView.toVar();\n\n\t\tconst uv = LTC_Uv( { N, V, roughness } );\n\n\t\tconst t1 = ltc_1.sample( uv ).toVar();\n\t\tconst t2 = ltc_2.sample( uv ).toVar();\n\n\t\tconst mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3( 0, 1, 0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t).toVar();\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tconst fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();\n\n\t\treflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );\n\n\t\treflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( context, stack, builder ) {\n\n\t\tthis.indirectDiffuse( context, stack, builder );\n\t\tthis.indirectSpecular( context, stack, builder );\n\t\tthis.ambientOcclusion( context, stack, builder );\n\n\t}\n\n\t/**\n\t * Implements the indirect diffuse term.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirectDiffuse( { irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect specular term.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirectSpecular( { radiance, iblIrradiance, reflectedLight } ) {\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.addAssign( iblIrradiance.mul(\n\t\t\t\tsheen,\n\t\t\t\tIBLSheenBRDF( {\n\t\t\t\t\tnormal: transformedNormalView,\n\t\t\t\t\tviewDir: positionViewDirection,\n\t\t\t\t\troughness: sheenRoughness\n\t\t\t\t} )\n\t\t\t) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst clearcoatEnv = EnvironmentBRDF( {\n\t\t\t\tdotNV: dotNVcc,\n\t\t\t\tspecularColor: clearcoatF0,\n\t\t\t\tspecularF90: clearcoatF90,\n\t\t\t\troughness: clearcoatRoughness\n\t\t\t} );\n\n\t\t\tthis.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );\n\n\t\t}\n\n\t\t// Both indirect specular and indirect diffuse light accumulate here\n\n\t\tconst singleScattering = vec3().toVar( 'singleScattering' );\n\t\tconst multiScattering = vec3().toVar( 'multiScattering' );\n\t\tconst cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );\n\n\t\tthis.computeMultiscattering( singleScattering, multiScattering, specularF90 );\n\n\t\tconst totalScattering = singleScattering.add( multiScattering );\n\n\t\tconst diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );\n\n\t\treflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );\n\t\treflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );\n\n\t\treflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );\n\n\t}\n\n\t/**\n\t * Implements the ambient occlusion term.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tambientOcclusion( { ambientOcclusion, reflectedLight } ) {\n\n\t\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst aoNV = dotNV.add( ambientOcclusion );\n\t\tconst aoExp = roughness.mul( - 16.0 ).oneMinus().negate().exp2();\n\n\t\tconst aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\t\treflectedLight.indirectSpecular.mulAssign( aoNode );\n\n\t}\n\n\t/**\n\t * Used for final lighting accumulations depending on the requested features.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( context ) {\n\n\t\tconst { outgoingLight } = context;\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst Fcc = F_Schlick( {\n\t\t\t\tdotVH: dotNVcc,\n\t\t\t\tf0: clearcoatF0,\n\t\t\t\tf90: clearcoatF90\n\t\t\t} );\n\n\t\t\tconst clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );\n\n\t\t\toutgoingLight.assign( clearcoatLight );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tconst sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();\n\t\t\tconst sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );\n\n\t\t\toutgoingLight.assign( sheenLight );\n\n\t\t}\n\n\t}\n\n}\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/ float( 1.0 );\nconst cubeUV_m0 = /*@__PURE__*/ float( - 2.0 );\nconst cubeUV_r1 = /*@__PURE__*/ float( 0.8 );\nconst cubeUV_m1 = /*@__PURE__*/ float( - 1.0 );\nconst cubeUV_r4 = /*@__PURE__*/ float( 0.4 );\nconst cubeUV_m4 = /*@__PURE__*/ float( 2.0 );\nconst cubeUV_r5 = /*@__PURE__*/ float( 0.305 );\nconst cubeUV_m5 = /*@__PURE__*/ float( 3.0 );\nconst cubeUV_r6 = /*@__PURE__*/ float( 0.21 );\nconst cubeUV_m6 = /*@__PURE__*/ float( 4.0 );\n\nconst cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );\nconst cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {\n\n\tconst absDirection = vec3( abs( direction ) ).toVar();\n\tconst face = float( - 1.0 ).toVar();\n\n\tIf( absDirection.x.greaterThan( absDirection.z ), () => {\n\n\t\tIf( absDirection.x.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} ).Else( () => {\n\n\t\tIf( absDirection.z.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} );\n\n\treturn face;\n\n} ).setLayout( {\n\tname: 'getFace',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {\n\n\tconst uv = vec2().toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y\n\n\t} ).Else( () => {\n\n\t\tuv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z\n\n\t} );\n\n\treturn mul( 0.5, uv.add( 1.0 ) );\n\n} ).setLayout( {\n\tname: 'getUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\nconst roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {\n\n\tconst mip = float( 0.0 ).toVar();\n\n\tIf( roughness.greaterThanEqual( cubeUV_r1 ), () => {\n\n\t\tmip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {\n\n\t\tmip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {\n\n\t\tmip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {\n\n\t\tmip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );\n\n\t} ).Else( () => {\n\n\t\tmip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25\n\n\t} );\n\n\treturn mip;\n\n} ).setLayout( {\n\tname: 'roughnessToMip',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {\n\n\tconst uv = uv_immutable.toVar();\n\tuv.assign( mul( 2.0, uv ).sub( 1.0 ) );\n\tconst direction = vec3( uv, 1.0 ).toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tdirection.assign( direction.zyx ); // ( 1, v, u ) pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tdirection.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tdirection.assign( direction.zyx );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y\n\n\t} ).ElseIf( face.equal( 5.0 ), () => {\n\n\t\tdirection.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS\n\n\t} );\n\n\treturn direction;\n\n} ).setLayout( {\n\tname: 'getDirection',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'uv', type: 'vec2' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\n//\n\nconst textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst roughness = float( roughness_immutable );\n\tconst sampleDir = vec3( sampleDir_immutable );\n\n\tconst mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\tconst mipF = fract( mip );\n\tconst mipInt = floor( mip );\n\tconst color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\tIf( mipF.notEqual( 0.0 ), () => {\n\n\t\tconst color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\t\tcolor0.assign( mix( color0, color1, mipF ) );\n\n\t} );\n\n\treturn color0;\n\n} );\n\nconst bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst mipInt = float( mipInt_immutable ).toVar();\n\tconst direction = vec3( direction_immutable );\n\tconst face = float( getFace( direction ) ).toVar();\n\tconst filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();\n\tmipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );\n\tconst faceSize = float( exp2( mipInt ) ).toVar();\n\tconst uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();\n\n\tIf( face.greaterThan( 2.0 ), () => {\n\n\t\tuv.y.addAssign( faceSize );\n\t\tface.subAssign( 3.0 );\n\n\t} );\n\n\tuv.x.addAssign( face.mul( faceSize ) );\n\tuv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );\n\tuv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );\n\tuv.x.mulAssign( CUBEUV_TEXEL_WIDTH );\n\tuv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );\n\n\treturn envMap.sample( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering\n\n} );\n\nconst getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst cosTheta = cos( theta );\n\n\t// Rodrigues' axis-angle rotation\n\tconst sampleDirection = outputDirection.mul( cosTheta )\n\t\t.add( axis.cross( outputDirection ).mul( sin( theta ) ) )\n\t\t.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );\n\n\treturn bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );\n\n} );\n\nconst blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();\n\n\tIf( all( axis.equals( vec3( 0.0 ) ) ), () => {\n\n\t\taxis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );\n\n\t} );\n\n\taxis.assign( normalize( axis ) );\n\n\tconst gl_FragColor = vec3().toVar();\n\tgl_FragColor.addAssign( weights.element( 0 ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\tLoop( { start: int( 1 ), end: n }, ( { i } ) => {\n\n\t\tIf( i.greaterThanEqual( samples ), () => {\n\n\t\t\tBreak();\n\n\t\t} );\n\n\t\tconst theta = float( dTheta.mul( float( i ) ) ).toVar();\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\t} );\n\n\treturn vec4( gl_FragColor, 1 );\n\n} );\n\n/** @module PMREMNode **/\n\nlet _generator = null;\n\nconst _cache = new WeakMap();\n\n/**\n * Generates the cubeUV size based on the given image height.\n *\n * @private\n * @param {Number} imageHeight - The image height.\n * @return {{texelWidth: Number,texelHeight: Number, maxMip: Number}} The result object.\n */\nfunction _generateCubeUVSize( imageHeight ) {\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\n/**\n * Generates a PMREM from the given texture .\n *\n * @private\n * @param {Texture} texture - The texture to create the PMREM for.\n * @return {Texture} The PMREM.\n */\nfunction _getPMREMFromTexture( texture ) {\n\n\tlet cacheTexture = _cache.get( texture );\n\n\tconst pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : - 1;\n\n\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\tconst image = texture.image;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( isCubeMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = _generator.fromCubemap( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( isEquirectangularMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = _generator.fromEquirectangular( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcacheTexture.pmremVersion = texture.pmremVersion;\n\n\t\t_cache.set( texture, cacheTexture );\n\n\t}\n\n\treturn cacheTexture.texture;\n\n}\n\n/**\n * This node represents a PMREM which is a special type of preprocessed\n * environment map intended for PBR materials.\n *\n * ```js\n * const material = new MeshStandardNodeMaterial();\n * material.envNode = pmremTexture( envMap );\n * ```\n *\n * @augments TempNode\n */\nclass PMREMNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PMREMNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function overloading node.\n\t *\n\t * @param {Texture} value - The input texture.\n\t * @param {Node<vec2>} [uvNode=null] - The uv node.\n\t * @param {Node<float>} [levelNode=null] - The level node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Reference to the input texture.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture}\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * Reference to the generated PMREM.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture | null}\n\t\t * @default null\n\t\t */\n\t\tthis._pmrem = null;\n\n\t\t/**\n\t\t *  The uv node.\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t *  The level node.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t\t/**\n\t\t * Reference to a PMREM generator.\n\t\t *\n\t\t * @private\n\t\t * @type {PMREMGenerator}\n\t\t * @default null\n\t\t */\n\t\tthis._generator = null;\n\n\t\tconst defaultTexture = new Texture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\t/**\n\t\t * The texture node holding the generated PMREM.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._texture = texture( defaultTexture );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's width.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._width = uniform( 0 );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's height.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._height = uniform( 0 );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's max Mip.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._maxMip = uniform( 0 );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER`.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tset value( value ) {\n\n\t\tthis._value = value;\n\t\tthis._pmrem = null;\n\n\t}\n\n\t/**\n\t * The node's texture value.\n\t *\n\t * @type {Texture}\n\t */\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\t/**\n\t * Uses the given PMREM texture to update internal values.\n\t *\n\t * @param {Texture} texture - The PMREM texture.\n\t */\n\tupdateFromTexture( texture ) {\n\n\t\tconst cubeUVSize = _generateCubeUVSize( texture.image.height );\n\n\t\tthis._texture.value = texture;\n\t\tthis._width.value = cubeUVSize.texelWidth;\n\t\tthis._height.value = cubeUVSize.texelHeight;\n\t\tthis._maxMip.value = cubeUVSize.maxMip;\n\n\t}\n\n\tupdateBefore() {\n\n\t\tlet pmrem = this._pmrem;\n\n\t\tconst pmremVersion = pmrem ? pmrem.pmremVersion : - 1;\n\t\tconst texture = this._value;\n\n\t\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\t\tif ( texture.isPMREMTexture === true ) {\n\n\t\t\t\tpmrem = texture;\n\n\t\t\t} else {\n\n\t\t\t\tpmrem = _getPMREMFromTexture( texture );\n\n\t\t\t}\n\n\t\t\tif ( pmrem !== null ) {\n\n\t\t\t\tthis._pmrem = pmrem;\n\n\t\t\t\tthis.updateFromTexture( pmrem );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( _generator === null ) {\n\n\t\t\t_generator = builder.createPMREMGenerator();\n\n\t\t}\n\n\t\t//\n\n\t\tthis.updateBefore( builder );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( uvNode === null && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\t//\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true ) {\n\n\t\t\tuvNode = vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t}\n\n\t\tuvNode = vec3( uvNode.x, uvNode.y.negate(), uvNode.z );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\treturn textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given cube map image has been fully loaded.\n *\n * @private\n * @param {Array<(Image|Object)>} image - The cube map image.\n * @return {Boolean} Whether the given cube map is ready or not.\n */\nfunction isCubeMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\tlet count = 0;\n\tconst length = 6;\n\n\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t}\n\n\treturn count === length;\n\n\n}\n\n/**\n * Returns `true` if the given equirectangular image has been fully loaded.\n *\n * @private\n * @param {(Image|Object)} image - The equirectangular image.\n * @return {Boolean} Whether the given cube map is ready or not.\n */\nfunction isEquirectangularMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\n/**\n * TSL function for creating a PMREM node.\n *\n * @function\n * @param {Texture} value - The input texture.\n * @param {Node<vec2>} [uvNode=null] - The uv node.\n * @param {Node<float>} [levelNode=null] - The level node.\n * @returns {PMREMNode}\n */\nconst pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode );\n\nconst _envNodeCache = new WeakMap();\n\n/**\n * Represents a physical model for Image-based lighting (IBL). The environment\n * is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.\n * `EnvironmentNode` is intended for PBR materials like {@link MeshStandardNodeMaterial}.\n *\n * @augments LightingNode\n */\nclass EnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'EnvironmentNode';\n\n\t}\n\n\t/**\n\t * Constructs a new environment node.\n\t *\n\t * @param {Node} [envNode=null] - A node representing the environment.\n\t */\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node representing the environment.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { material } = builder;\n\n\t\tlet envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tlet cacheEnvNode = _envNodeCache.get( value );\n\n\t\t\tif ( cacheEnvNode === undefined ) {\n\n\t\t\t\tcacheEnvNode = pmremTexture( value );\n\n\t\t\t\t_envNodeCache.set( value, cacheEnvNode );\n\n\t\t\t}\n\n\t\t\tenvNode\t= cacheEnvNode;\n\n\t\t}\n\n\t\t//\n\n\t\tconst envMap = material.envMap;\n\t\tconst intensity = envMap ? reference( 'envMapIntensity', 'float', builder.material ) : reference( 'environmentIntensity', 'float', builder.scene ); // @TODO: Add materialEnvIntensity in MaterialNode\n\n\t\tconst useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;\n\t\tconst radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;\n\n\t\tconst radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( intensity );\n\t\tconst irradiance = envNode.context( createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );\n\n\t\tconst isolateRadiance = cache( radiance );\n\t\tconst isolateIrradiance = cache( irradiance );\n\n\t\t//\n\n\t\tbuilder.context.radiance.addAssign( isolateRadiance );\n\n\t\tbuilder.context.iblIrradiance.addAssign( isolateIrradiance );\n\n\t\t//\n\n\t\tconst clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n\n\t\tif ( clearcoatRadiance ) {\n\n\t\t\tconst clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );\n\t\t\tconst isolateClearcoatRadiance = cache( clearcoatRadianceContext );\n\n\t\t\tclearcoatRadiance.addAssign( isolateClearcoatRadiance );\n\n\t\t}\n\n\t}\n\n}\n\nconst createRadianceContext = ( roughnessNode, normalViewNode ) => {\n\n\tlet reflectVec = null;\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\tif ( reflectVec === null ) {\n\n\t\t\t\treflectVec = positionViewDirection.negate().reflect( normalViewNode );\n\n\t\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\t\treflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();\n\n\t\t\t\treflectVec = reflectVec.transformDirection( cameraViewMatrix );\n\n\t\t\t}\n\n\t\t\treturn reflectVec;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn roughnessNode;\n\n\t\t}\n\t};\n\n};\n\nconst createIrradianceContext = ( normalWorldNode ) => {\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\treturn normalWorldNode;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn float( 1.0 );\n\n\t\t}\n\t};\n\n};\n\nconst _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();\n\n/**\n * Node material version of `MeshStandardMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshStandardNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshStandardNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh standard node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshStandardNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because standard materials react on lights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\t/**\n\t\t * The emissive color of standard materials is by default inferred from the `emissive`,\n\t\t * `emissiveIntensity` and `emissiveMap` properties. This node property allows to\n\t\t * overwrite the default and define the emissive color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the emissive color but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialEmissive}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.emissiveNode = null;\n\n\t\t/**\n\t\t * The metalness of standard materials is by default inferred from the `metalness`,\n\t\t * and `metalnessMap` properties. This node property allows to\n\t\t * overwrite the default and define the metalness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the metalness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialMetalness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.metalnessNode = null;\n\n\t\t/**\n\t\t * The roughness of standard materials is by default inferred from the `roughness`,\n\t\t * and `roughnessMap` properties. This node property allows to\n\t\t * overwrite the default and define the roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the roughness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialRoughness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.roughnessNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$6 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link EnvironmentNode}\n\t * to implement the PBR (PMREM based) environment mapping. Besides, the\n\t * method honors `Scene.environment`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {EnvironmentNode<vec3>?} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tlet envNode = super.setupEnvironment( builder );\n\n\t\tif ( envNode === null && builder.environmentNode ) {\n\n\t\t\tenvNode = builder.environmentNode;\n\n\t\t}\n\n\t\treturn envNode ? new EnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhysicalLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel();\n\n\t}\n\n\t/**\n\t * Setups the specular related node variables.\n\t */\n\tsetupSpecular() {\n\n\t\tconst specularColorNode = mix( vec3( 0.04 ), diffuseColor.rgb, metalness );\n\n\t\tspecularColor.assign( specularColorNode );\n\t\tspecularF90.assign( 1.0 );\n\n\t}\n\n\t/**\n\t * Setups the standard specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants() {\n\n\t\t// METALNESS\n\n\t\tconst metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;\n\n\t\tmetalness.assign( metalnessNode );\n\n\t\t// ROUGHNESS\n\n\t\tlet roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;\n\t\troughnessNode = getRoughness( { roughness: roughnessNode } );\n\n\t\troughness.assign( roughnessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tthis.setupSpecular();\n\n\t\t// DIFFUSE COLOR\n\n\t\tdiffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.emissiveNode = source.emissiveNode;\n\n\t\tthis.metalnessNode = source.metalnessNode;\n\t\tthis.roughnessNode = source.roughnessNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();\n\n/**\n * Node material version of `MeshPhysicalMaterial`.\n *\n * @augments MeshStandardNodeMaterial\n */\nclass MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhysicalNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh physical node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshPhysicalNodeMaterial = true;\n\n\t\t/**\n\t\t * The clearcoat of physical materials is by default inferred from the `clearcoat`\n\t\t * and `clearcoatMap` properties. This node property allows to overwrite the default\n\t\t * and define the clearcoat with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialClearcoat}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatNode = null;\n\n\t\t/**\n\t\t * The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`\n\t\t * and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default\n\t\t * and define the clearcoat roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat roughness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialClearcoatRoughness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatRoughnessNode = null;\n\n\t\t/**\n\t\t * The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the clearcoat normal with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat normal but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialClearcoatNormal}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatNormalNode = null;\n\n\t\t/**\n\t\t * The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`\n\t\t * and `sheenColorMap` properties. This node property allows to overwrite the default\n\t\t * and define the sheen with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the sheen but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSheen}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenNode = null;\n\n\t\t/**\n\t\t * The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and\n\t\t * `sheenRoughnessMap` properties. This node property allows to overwrite the default\n\t\t * and define the sheen roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the sheen roughness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSheenRoughness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenRoughnessNode = null;\n\n\t\t/**\n\t\t * The iridescence of physical materials is by default inferred from the `iridescence`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the iridescence with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialIridescence}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceNode = null;\n\n\t\t/**\n\t\t * The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the iridescence IOR with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence IOR but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialIridescenceIOR}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceIORNode = null;\n\n\t\t/**\n\t\t * The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`\n\t\t * and `iridescenceThicknessMap` properties. This node property allows to overwrite the default\n\t\t * and define the iridescence thickness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence thickness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialIridescenceThickness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceThicknessNode = null;\n\n\t\t/**\n\t\t * The specular intensity of physical materials is by default inferred from the `specularIntensity`\n\t\t * and `specularIntensityMap` properties. This node property allows to overwrite the default\n\t\t * and define the specular intensity with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular intensity but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSpecularIntensity}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.specularIntensityNode = null;\n\n\t\t/**\n\t\t * The specular color of physical materials is by default inferred from the `specularColor`\n\t\t * and `specularColorMap` properties. This node property allows to overwrite the default\n\t\t * and define the specular color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular color but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSpecularColor}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.specularColorNode = null;\n\n\t\t/**\n\t\t * The ior of physical materials is by default inferred from the `ior`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the ior with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the ior but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialIOR}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.iorNode = null;\n\n\t\t/**\n\t\t * The transmission of physical materials is by default inferred from the `transmission` and\n\t\t * `transmissionMap` properties. This node property allows to overwrite the default\n\t\t * and define the transmission with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the transmission but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialTransmission}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.transmissionNode = null;\n\n\t\t/**\n\t\t * The thickness of physical materials is by default inferred from the `thickness` and\n\t\t * `thicknessMap` properties. This node property allows to overwrite the default\n\t\t * and define the thickness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the thickness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialThickness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.thicknessNode = null;\n\n\t\t/**\n\t\t * The attenuation distance of physical materials is by default inferred from the\n\t\t * `attenuationDistance` property. This node property allows to overwrite the default\n\t\t * and define the attenuation distance with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the attenuation distance but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialAttenuationDistance}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.attenuationDistanceNode = null;\n\n\t\t/**\n\t\t * The attenuation color of physical materials is by default inferred from the\n\t\t * `attenuationColor` property. This node property allows to overwrite the default\n\t\t * and define the attenuation color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the attenuation color but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialAttenuationColor}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.attenuationColorNode = null;\n\n\t\t/**\n\t\t * The dispersion of physical materials is by default inferred from the\n\t\t * `dispersion` property. This node property allows to overwrite the default\n\t\t * and define the dispersion with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the dispersion but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialDispersion}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dispersionNode = null;\n\n\t\t/**\n\t\t * The anisotropy of physical materials is by default inferred from the\n\t\t * `anisotropy` property. This node property allows to overwrite the default\n\t\t * and define the anisotropy with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the anisotropy but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialAnisotropy}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.anisotropyNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$5 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use clearcoat or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useClearcoat() {\n\n\t\treturn this.clearcoat > 0 || this.clearcoatNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use iridescence or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useIridescence() {\n\n\t\treturn this.iridescence > 0 || this.iridescenceNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use sheen or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useSheen() {\n\n\t\treturn this.sheen > 0 || this.sheenNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use anisotropy or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useAnisotropy() {\n\n\t\treturn this.anisotropy > 0 || this.anisotropyNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use transmission or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useTransmission() {\n\n\t\treturn this.transmission > 0 || this.transmissionNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use dispersion or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useDispersion() {\n\n\t\treturn this.dispersion > 0 || this.dispersionNode !== null;\n\n\t}\n\n\t/**\n\t * Setups the specular related node variables.\n\t */\n\tsetupSpecular() {\n\n\t\tconst iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;\n\n\t\tior.assign( iorNode );\n\t\tspecularColor.assign( mix( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );\n\t\tspecularF90.assign( mix( materialSpecularIntensity, 1.0, metalness ) );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhysicalLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );\n\n\t}\n\n\t/**\n\t * Setups the physical specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( builder ) {\n\n\t\tsuper.setupVariants( builder );\n\n\t\t// CLEARCOAT\n\n\t\tif ( this.useClearcoat ) {\n\n\t\t\tconst clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;\n\t\t\tconst clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;\n\n\t\t\tclearcoat.assign( clearcoatNode );\n\t\t\tclearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );\n\n\t\t}\n\n\t\t// SHEEN\n\n\t\tif ( this.useSheen ) {\n\n\t\t\tconst sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;\n\t\t\tconst sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;\n\n\t\t\tsheen.assign( sheenNode );\n\t\t\tsheenRoughness.assign( sheenRoughnessNode );\n\n\t\t}\n\n\t\t// IRIDESCENCE\n\n\t\tif ( this.useIridescence ) {\n\n\t\t\tconst iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;\n\t\t\tconst iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;\n\t\t\tconst iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;\n\n\t\t\tiridescence.assign( iridescenceNode );\n\t\t\tiridescenceIOR.assign( iridescenceIORNode );\n\t\t\tiridescenceThickness.assign( iridescenceThicknessNode );\n\n\t\t}\n\n\t\t// ANISOTROPY\n\n\t\tif ( this.useAnisotropy ) {\n\n\t\t\tconst anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();\n\n\t\t\tanisotropy.assign( anisotropyV.length() );\n\n\t\t\tIf( anisotropy.equal( 0.0 ), () => {\n\n\t\t\t\tanisotropyV.assign( vec2( 1.0, 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tanisotropyV.divAssign( vec2( anisotropy ) );\n\t\t\t\tanisotropy.assign( anisotropy.saturate() );\n\n\t\t\t} );\n\n\t\t\t// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n\t\t\talphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );\n\n\t\t\tanisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );\n\t\t\tanisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );\n\n\t\t}\n\n\t\t// TRANSMISSION\n\n\t\tif ( this.useTransmission ) {\n\n\t\t\tconst transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;\n\t\t\tconst thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;\n\t\t\tconst attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;\n\t\t\tconst attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;\n\n\t\t\ttransmission.assign( transmissionNode );\n\t\t\tthickness.assign( thicknessNode );\n\t\t\tattenuationDistance.assign( attenuationDistanceNode );\n\t\t\tattenuationColor.assign( attenuationColorNode );\n\n\t\t\tif ( this.useDispersion ) {\n\n\t\t\t\tconst dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;\n\n\t\t\t\tdispersion.assign( dispersionNode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups the clearcoat normal node.\n\t *\n\t * @return {Node<vec3>} The clearcoat normal.\n\t */\n\tsetupClearcoatNormal() {\n\n\t\treturn this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupClearcoatNormal = () => this.setupClearcoatNormal( builder );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.clearcoatNode = source.clearcoatNode;\n\t\tthis.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n\t\tthis.clearcoatNormalNode = source.clearcoatNormalNode;\n\n\t\tthis.sheenNode = source.sheenNode;\n\t\tthis.sheenRoughnessNode = source.sheenRoughnessNode;\n\n\t\tthis.iridescenceNode = source.iridescenceNode;\n\t\tthis.iridescenceIORNode = source.iridescenceIORNode;\n\t\tthis.iridescenceThicknessNode = source.iridescenceThicknessNode;\n\n\t\tthis.specularIntensityNode = source.specularIntensityNode;\n\t\tthis.specularColorNode = source.specularColorNode;\n\n\t\tthis.transmissionNode = source.transmissionNode;\n\t\tthis.thicknessNode = source.thicknessNode;\n\t\tthis.attenuationDistanceNode = source.attenuationDistanceNode;\n\t\tthis.attenuationColorNode = source.attenuationColorNode;\n\t\tthis.dispersionNode = source.dispersionNode;\n\n\t\tthis.anisotropyNode = source.anisotropyNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\n/** @module MeshSSSNodeMaterial **/\n\n/**\n * Represents the lighting model for {@link MeshSSSNodeMaterial}.\n *\n * @augments PhysicalLightingModel\n */\nclass SSSLightingModel extends PhysicalLightingModel {\n\n\t/**\n\t * Constructs a new physical lighting model.\n\t *\n\t * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n\t * @param {Boolean} [sheen=false] - Whether sheen is supported or not.\n\t * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.\n\t * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n\t * @param {Boolean} [transmission=false] - Whether transmission is supported or not.\n\t * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.\n\t * @param {Boolean} [sss=false] - Whether SSS is supported or not.\n\t */\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false, sss = false ) {\n\n\t\tsuper( clearcoat, sheen, iridescence, anisotropy, transmission, dispersion );\n\n\t\t/**\n\t\t * Whether the lighting model should use SSS or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useSSS = sss;\n\n\t}\n\n\t/**\n\t * Extends the default implementation with a SSS term.\n\t *\n\t * Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look]{@link https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/}\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight }, stack, builder ) {\n\n\t\tif ( this.useSSS === true ) {\n\n\t\t\tconst material = builder.material;\n\n\t\t\tconst { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;\n\n\t\t\tconst scatteringHalf = lightDirection.add( transformedNormalView.mul( thicknessDistortionNode ) ).normalize();\n\t\t\tconst scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ).mul( thicknessScaleNode ) );\n\t\t\tconst scatteringIllu = vec3( scatteringDot.add( thicknessAmbientNode ).mul( thicknessColorNode ) );\n\n\t\t\treflectedLight.directDiffuse.addAssign( scatteringIllu.mul( thicknessAttenuationNode.mul( lightColor ) ) );\n\n\t\t}\n\n\t\tsuper.direct( { lightDirection, lightColor, reflectedLight }, stack, builder );\n\n\t}\n\n}\n\n/**\n * This node material is an experimental extension of {@link MeshPhysicalNodeMaterial}\n * that implements a Subsurface scattering (SSS) term.\n *\n * @augments MeshPhysicalNodeMaterial\n */\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshSSSNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh SSS node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * Represents the thickness color.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.thicknessColorNode = null;\n\n\t\t/**\n\t\t * Represents the distortion factor.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessDistortionNode = float( 0.1 );\n\n\t\t/**\n\t\t * Represents the thickness ambient factor.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessAmbientNode = float( 0.0 );\n\n\t\t/**\n\t\t * Represents the thickness attenuation.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessAttenuationNode = float( .1 );\n\n\t\t/**\n\t\t * Represents the thickness power.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessPowerNode = float( 2.0 );\n\n\t\t/**\n\t\t * Represents the thickness scale.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessScaleNode = float( 10.0 );\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use SSS or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useSSS() {\n\n\t\treturn this.thicknessColorNode !== null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {SSSLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new SSSLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion, this.useSSS );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.thicknessColorNode = source.thicknessColorNode;\n\t\tthis.thicknessDistortionNode = source.thicknessDistortionNode;\n\t\tthis.thicknessAmbientNode = source.thicknessAmbientNode;\n\t\tthis.thicknessAttenuationNode = source.thicknessAttenuationNode;\n\t\tthis.thicknessPowerNode = source.thicknessPowerNode;\n\t\tthis.thicknessScaleNode = source.thicknessScaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {\n\n\t// dotNL will be from -1.0 to 1.0\n\tconst dotNL = normal.dot( lightDirection );\n\tconst coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );\n\n\tif ( builder.material.gradientMap ) {\n\n\t\tconst gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );\n\n\t\treturn vec3( gradientMap.r );\n\n\t} else {\n\n\t\tconst fw = coord.fwidth().mul( 0.5 );\n\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );\n\n\t}\n\n} );\n\n/**\n * Represents the lighting model for a toon material. Used in {@link MeshToonNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass ToonLightingModel extends LightingModel {\n\n\t/**\n\t * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is\n\t * reduced to a small number of discrete shades to create a comic-like, flat look.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight }, stack, builder ) {\n\n\t\tconst irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( { ambientOcclusion, irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();\n\n/**\n * Node material version of `MeshToonMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshToonNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshToonNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh toon node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshToonNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because toon materials react on lights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$4 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {ToonLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ToonLightingModel();\n\n\t}\n\n}\n\n/** @module MatcapUVNode **/\n\n/**\n * Can be used to compute texture coordinates for projecting a\n * matcap onto a mesh. Used by {@link MeshMatcapNodeMaterial}.\n *\n * @augments TempNode\n */\nclass MatcapUVNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MatcapUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new matcap uv node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t}\n\n\tsetup() {\n\n\t\tconst x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();\n\t\tconst y = positionViewDirection.cross( x );\n\n\t\treturn vec2( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t}\n\n}\n\n/**\n * TSL function for creating a matcap uv node.\n *\n * @function\n * @returns {MatcapUVNode}\n */\nconst matcapUV = /*@__PURE__*/ nodeImmutable( MatcapUVNode );\n\nconst _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();\n\n/**\n * Node material version of `MeshMatcapMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshMatcapNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshMatcapNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh normal node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshMatcapNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$3 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the matcap specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( builder ) {\n\n\t\tconst uv = matcapUV;\n\n\t\tlet matcapColor;\n\n\t\tif ( builder.material.matcap ) {\n\n\t\t\tmatcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );\n\n\t\t} else {\n\n\t\t\tmatcapColor = vec3( mix( 0.2, 0.8, uv.y ) ); // default if matcap is missing\n\n\t\t}\n\n\t\tdiffuseColor.rgb.mulAssign( matcapColor.rgb );\n\n\t}\n\n}\n\n/** @module RotateNode **/\n\n/**\n * Applies a rotation to the given position node.\n *\n * @augments TempNode\n */\nclass RotateNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RotateNode';\n\n\t}\n\n\t/**\n\t * Constructs a new rotate node.\n\t *\n\t * @param {Node} positionNode - The position node.\n\t * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending\n\t * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n\t */\n\tconstructor( positionNode, rotationNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The position node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.positionNode = positionNode;\n\n\t\t/**\n\t\t *  Represents the rotation that is applied to the position node.\n\t\t *  Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.rotationNode = rotationNode;\n\n\t}\n\n\t/**\n\t * The type of the {@link RotateNode#positionNode} defines the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node's type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.positionNode.getNodeType( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { rotationNode, positionNode } = this;\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( nodeType === 'vec2' ) {\n\n\t\t\tconst cosAngle = rotationNode.cos();\n\t\t\tconst sinAngle = rotationNode.sin();\n\n\t\t\tconst rotationMatrix = mat2(\n\t\t\t\tcosAngle, sinAngle,\n\t\t\t\tsinAngle.negate(), cosAngle\n\t\t\t);\n\n\t\t\treturn rotationMatrix.mul( positionNode );\n\n\t\t} else {\n\n\t\t\tconst rotation = rotationNode;\n\t\t\tconst rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\n\t\t\treturn rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a rotate node.\n *\n * @function\n * @param {Node} positionNode - The position node.\n * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending\n * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n * @returns {RotateNode}\n */\nconst rotate = /*@__PURE__*/ nodeProxy( RotateNode );\n\nconst _defaultValues$2 = /*@__PURE__*/ new SpriteMaterial();\n\n/**\n * Node material version of `SpriteMaterial`.\n *\n * @augments NodeMaterial\n */\nclass SpriteNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new sprite node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSpriteNodeMaterial = true;\n\n\t\tthis._useSizeAttenuation = true;\n\n\t\t/**\n\t\t * This property makes it possible to define the position of the sprite with a\n\t\t * node. That can be useful when the material is used with instanced rendering\n\t\t * and node data are defined with an instanced attribute node:\n\t\t * ```js\n\t\t * const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );\n\t\t * material.positionNode = instancedBufferAttribute( positionAttribute );\n\t\t * ```\n\t\t * Another possibility is to compute the instanced data with a compute shader:\n\t\t * ```js\n\t\t * const positionBuffer = instancedArray( particleCount, 'vec3' );\n\t\t * particleMaterial.positionNode = positionBuffer.toAttribute();\n\t\t * ```\n\t\t *\n\t\t * @type {Node<vec2>?}\n\t\t * @default null\n\t\t */\n\t\tthis.positionNode = null;\n\n\t\t/**\n\t\t * The rotation of sprite materials is by default inferred from the `rotation`,\n\t\t * property. This node property allows to overwrite the default and define\n\t\t * the rotation with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the rotation but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialRotation}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.rotationNode = null;\n\n\t\t/**\n\t\t * This node property provides an additional way to scale sprites next to\n\t\t * `Object3D.scale`. The scale transformation based in `Object3D.scale`\n\t\t * is multiplied with the scale value of this node in the vertex shader.\n\t\t *\n\t\t * @type {Node<vec2>?}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$2 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the position node in view space. This method implements\n\t * the sprite specific vertex shader.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in view space.\n\t */\n\tsetupPositionView( builder ) {\n\n\t\tconst { object, camera } = builder;\n\n\t\tconst sizeAttenuation = this.sizeAttenuation;\n\n\t\tconst { positionNode, rotationNode, scaleNode } = this;\n\n\t\tconst mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );\n\n\t\tlet scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tscale = scale.mul( float( scaleNode ) );\n\n\t\t}\n\n\t\tif ( sizeAttenuation === false ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tscale = scale.mul( mvPosition.z.negate() );\n\n\t\t\t} else {\n\n\t\t\t\tconst orthoScale = float( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );\n\t\t\t\tscale = scale.mul( orthoScale.mul( 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet alignedPosition = positionGeometry.xy;\n\n\t\tif ( object.center && object.center.isVector2 === true ) {\n\n\t\t\tconst center = reference$1( 'center', 'vec2', object );\n\n\t\t\talignedPosition = alignedPosition.sub( center.sub( 0.5 ) );\n\n\t\t}\n\n\t\talignedPosition = alignedPosition.mul( scale );\n\n\t\tconst rotation = float( rotationNode || materialRotation );\n\n\t\tconst rotatedPosition = rotate( alignedPosition, rotation );\n\n\t\treturn vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.rotationNode = source.rotationNode;\n\t\tthis.scaleNode = source.scaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\t/**\n\t * Whether to use size attenuation or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget sizeAttenuation() {\n\n\t\treturn this._useSizeAttenuation;\n\n\t}\n\n\tset sizeAttenuation( value ) {\n\n\t\tif ( this._useSizeAttenuation !== value ) {\n\n\t\t\tthis._useSizeAttenuation = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$1 = /*@__PURE__*/ new PointsMaterial();\n\n/**\n * Node material version of `PointsMaterial`.\n *\n * @augments NodeMaterial\n */\nclass PointsNodeMaterial extends SpriteNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'PointsNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new points node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This node property provides an additional way to set the point size.\n\t\t *\n\t\t * @type {Node<vec2>?}\n\t\t * @default null\n\t\t */\n\t\tthis.sizeNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPointsNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$1 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupPositionView() {\n\n\t\tconst { positionNode } = this;\n\n\t\treturn modelViewMatrix.mul( vec3( positionNode || positionLocal ) ).xyz;\n\n\t}\n\n\tsetupVertex( builder ) {\n\n\t\tconst mvp = super.setupVertex( builder );\n\n\t\t// skip further processing if the material is not a node material\n\n\t\tif ( builder.material.isNodeMaterial !== true ) {\n\n\t\t\treturn mvp;\n\n\t\t}\n\n\t\t// ndc space\n\n\t\tconst { rotationNode, scaleNode, sizeNode } = this;\n\n\t\tconst alignedPosition = positionGeometry.xy.toVar();\n\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t// rotation\n\n\t\tif ( rotationNode && rotationNode.isNode ) {\n\n\t\t\tconst rotation = float( rotationNode );\n\n\t\t\talignedPosition.assign( rotate( alignedPosition, rotation ) );\n\n\t\t}\n\n\t\t// point size\n\n\t\tlet pointSize = sizeNode !== null ? vec2( sizeNode ) : materialPointSize;\n\n\t\tif ( this.sizeAttenuation === true ) {\n\n\t\t\tpointSize = pointSize.mul( pointSize.div( positionView.z.negate() ) );\n\n\t\t}\n\n\t\t// scale\n\n\t\tif ( scaleNode && scaleNode.isNode ) {\n\n\t\t\tpointSize = pointSize.mul( vec2( scaleNode ) );\n\n\t\t}\n\n\t\talignedPosition.mulAssign( pointSize.mul( 2 ) );\n\n\t\talignedPosition.assign( alignedPosition.div( viewport.z ) );\n\t\talignedPosition.y.assign( alignedPosition.y.mul( aspect ) );\n\n\t\t// back to clip space\n\t\talignedPosition.assign( alignedPosition.mul( mvp.w ) );\n\n\t\t//clipPos.xy += offset;\n\t\tmvp.addAssign( vec4( alignedPosition, 0, 0 ) );\n\n\t\treturn mvp;\n\n\t}\n\n\t/**\n\t * Whether alpha to coverage should be used or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget alphaToCoverage() {\n\n\t\treturn this._useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this._useAlphaToCoverage !== value ) {\n\n\t\t\tthis._useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Represents lighting model for a shadow material. Used in {@link ShadowNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass ShadowMaskModel extends LightingModel {\n\n\t/**\n\t * Constructs a new shadow mask model.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The shadow mask node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.shadowNode = float( 1 ).toVar( 'shadowMask' );\n\n\t}\n\n\t/**\n\t * Only used to save the shadow mask.\n\t *\n\t * @param {Object} input - The input data.\n\t */\n\tdirect( { shadowMask } ) {\n\n\t\tthis.shadowNode.mulAssign( shadowMask );\n\n\t}\n\n\t/**\n\t * Uses the shadow mask to produce the final color.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t */\n\tfinish( context ) {\n\n\t\tdiffuseColor.a.mulAssign( this.shadowNode.oneMinus() );\n\n\t\tcontext.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment\n\n\t}\n\n}\n\nconst _defaultValues = /*@__PURE__*/ new ShadowMaterial();\n\n/**\n * Node material version of `ShadowMaterial`.\n *\n * @augments NodeMaterial\n */\nclass ShadowNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because so it's possible to implement\n\t\t * the shadow mask effect.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {ShadowMaskModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ShadowMaskModel();\n\n\t}\n\n}\n\n/** @module Texture3DNode **/\n\nconst normal = Fn( ( { texture, uv } ) => {\n\n\tconst epsilon = 0.0001;\n\n\tconst ret = vec3().toVar();\n\n\tIf( uv.x.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 1, 0 ) );\n\n\t} ).ElseIf( uv.z.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, 1 ) );\n\n\t} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( - 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, - 1, 0 ) );\n\n\t} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, - 1 ) );\n\n\t} ).Else( () => {\n\n\t\tconst step = 0.01;\n\n\t\tconst x = texture.sample( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );\n\t\tconst y = texture.sample( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );\n\t\tconst z = texture.sample( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, 0.0, step ) ) ).r );\n\n\t\tret.assign( vec3( x, y, z ) );\n\n\t} );\n\n\treturn ret.normalize();\n\n} );\n\n/**\n * This type of uniform node represents a 3D texture.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass Texture3DNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'Texture3DNode';\n\n\t}\n\n\t/**\n\t * Constructs a new 3D texture node.\n\t *\n\t * @param {Data3DTexture} value - The 3D texture.\n\t * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n\t * @param {Node<int>?} [levelNode=null] - The level node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTexture3DNode = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'texture3D'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture3D';\n\n\t}\n\n\t/**\n\t * Returns a default uv node which is in context of 3D textures a three-dimensional\n\t * uv node.\n\t *\n\t * @return {Node<vec3>} The default uv node.\n\t */\n\tgetDefaultUV() {\n\n\t\treturn vec3( 0.5, 0.5, 0.5 );\n\n\t}\n\n\t/**\n\t * Overwritten with an empty implementation since the `updateMatrix` flag is ignored\n\t * for 3D textures. The uv transformation matrix is not applied to 3D textures.\n\t *\n\t * @param {Boolean} value - The update toggle.\n\t */\n\tsetUpdateMatrix( /*value*/ ) { } // Ignore .updateMatrix for 3d TextureNode\n\n\t/**\n\t * Overwrites the default implementation to return the unmodified uv node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The unmodified uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true ) ) {\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = uvNode.flipY();\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to generate code for.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, 'vec3' );\n\n\t}\n\n\t/**\n\t * TODO.\n\t *\n\t * @param {Node<vec3>} uvNode - The uv node .\n\t * @return {Node<vec3>} TODO.\n\t */\n\tnormal( uvNode ) {\n\n\t\treturn normal( { texture: this, uv: uvNode } );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a 3D texture node.\n *\n * @function\n * @param {Data3DTexture} value - The 3D texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @returns {Texture3DNode}\n */\nconst texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode );\n\n/** @module VolumeNodeMaterial **/\n\n/**\n * Node material intended for volume rendering. The volumetric data are\n * defined with an instance of {@link Data3DTexture}.\n *\n * @augments NodeMaterial\n */\nclass VolumeNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'VolumeNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new volume node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVolumeNodeMaterial = true;\n\n\t\t/**\n\t\t * The base color of the volume.\n\t\t *\n\t\t * @type {Color}\n\t\t * @default 100\n\t\t */\n\t\tthis.base = new Color( 0xffffff );\n\n\t\t/**\n\t\t * A 3D data texture holding the volumetric data.\n\t\t *\n\t\t * @type {Data3DTexture?}\n\t\t * @default null\n\t\t */\n\t\tthis.map = null;\n\n\t\t/**\n\t\t * This number of samples for each ray that hits the mesh's surface\n\t\t * and travels through the volume.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 100\n\t\t */\n\t\tthis.steps = 100;\n\n\t\t/**\n\t\t * Callback for {@link VolumeNodeMaterial#testNode}.\n\t\t *\n\t\t * @callback testNodeCallback\n\t\t * @param {Data3DTexture<float>} map - The 3D texture.\n\t\t * @param {Node<float>} mapValue - The sampled value inside the volume.\n\t\t * @param {Node<vec3>} probe - The probe which is the entry point of the ray on the mesh's surface.\n\t\t * @param {Node<vec4>} finalColor - The final color.\n\t\t */\n\n\t\t/**\n\t\t * The volume rendering of this material works by shooting rays\n\t\t * from the camera position through each fragment of the mesh's\n\t\t * surface and sample the inner volume in a raymarching fashion\n\t\t * multiple times.\n\t\t *\n\t\t * This node can be used to assign a callback function of type `Fn`\n\t\t * that will be executed per sample. The callback receives the\n\t\t * texture, the sampled texture value as well as position on the surface\n\t\t * where the rays enters the volume. The last parameter is a color\n\t\t * that allows the callback to determine the final color.\n\t\t *\n\t\t * @type {testNodeCallback?}\n\t\t * @default null\n\t\t */\n\t\tthis.testNode = null;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst map = texture3D( this.map, null, 0 );\n\n\t\tconst hitBox = Fn( ( { orig, dir } ) => {\n\n\t\t\tconst box_min = vec3( - 0.5 );\n\t\t\tconst box_max = vec3( 0.5 );\n\n\t\t\tconst inv_dir = dir.reciprocal();\n\n\t\t\tconst tmin_tmp = box_min.sub( orig ).mul( inv_dir );\n\t\t\tconst tmax_tmp = box_max.sub( orig ).mul( inv_dir );\n\n\t\t\tconst tmin = min$1( tmin_tmp, tmax_tmp );\n\t\t\tconst tmax = max$1( tmin_tmp, tmax_tmp );\n\n\t\t\tconst t0 = max$1( tmin.x, max$1( tmin.y, tmin.z ) );\n\t\t\tconst t1 = min$1( tmax.x, min$1( tmax.y, tmax.z ) );\n\n\t\t\treturn vec2( t0, t1 );\n\n\t\t} );\n\n\t\tthis.fragmentNode = Fn( () => {\n\n\t\t\tconst vOrigin = varying( vec3( modelWorldMatrixInverse.mul( vec4( cameraPosition, 1.0 ) ) ) );\n\t\t\tconst vDirection = varying( positionGeometry.sub( vOrigin ) );\n\n\t\t\tconst rayDir = vDirection.normalize();\n\t\t\tconst bounds = vec2( hitBox( { orig: vOrigin, dir: rayDir } ) ).toVar();\n\n\t\t\tbounds.x.greaterThan( bounds.y ).discard();\n\n\t\t\tbounds.assign( vec2( max$1( bounds.x, 0.0 ), bounds.y ) );\n\n\t\t\tconst p = vec3( vOrigin.add( bounds.x.mul( rayDir ) ) ).toVar();\n\t\t\tconst inc = vec3( rayDir.abs().reciprocal() ).toVar();\n\t\t\tconst delta = float( min$1( inc.x, min$1( inc.y, inc.z ) ) ).toVar( 'delta' ); // used 'delta' name in loop\n\n\t\t\tdelta.divAssign( materialReference( 'steps', 'float' ) );\n\n\t\t\tconst ac = vec4( materialReference( 'base', 'color' ), 0.0 ).toVar();\n\n\t\t\tLoop( { type: 'float', start: bounds.x, end: bounds.y, update: '+= delta' }, () => {\n\n\t\t\t\tconst d = property( 'float', 'd' ).assign( map.sample( p.add( 0.5 ) ).r );\n\n\t\t\t\tif ( this.testNode !== null ) {\n\n\t\t\t\t\tthis.testNode( { map: map, mapValue: d, probe: p, finalColor: ac } ).append();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default to show surface of mesh\n\t\t\t\t\tac.a.assign( 1 );\n\t\t\t\t\tBreak();\n\n\t\t\t\t}\n\n\t\t\t\tp.addAssign( rayDir.mul( delta ) );\n\n\t\t\t} );\n\n\t\t\tac.a.equal( 0 ).discard();\n\n\t\t\treturn vec4( ac );\n\n\t\t} )();\n\n\t\tsuper.setup( builder );\n\n\t}\n\n}\n\n/**\n * This module manages the internal animation loop of the renderer.\n *\n * @private\n */\nclass Animation {\n\n\t/**\n\t * Constructs a new animation loop management component.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( nodes, info ) {\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * A reference to the context from `requestAnimationFrame()` can\n\t\t * be called (usually `window`).\n\t\t *\n\t\t * @type {Window|XRSession}\n\t\t */\n\t\tthis._context = self;\n\n\t\t/**\n\t\t * The user-defined animation loop.\n\t\t *\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._animationLoop = null;\n\n\t\t/**\n\t\t * The requestId which is returned from the `requestAnimationFrame()` call.\n\t\t * Can be used to cancel the stop the animation loop.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis._requestId = null;\n\n\t}\n\n\t/**\n\t * Starts the internal animation loop.\n\t */\n\tstart() {\n\n\t\tconst update = ( time, frame ) => {\n\n\t\t\tthis._requestId = this._context.requestAnimationFrame( update );\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\tthis.nodes.nodeFrame.update();\n\n\t\t\tthis.info.frame = this.nodes.nodeFrame.frameId;\n\n\t\t\tif ( this._animationLoop !== null ) this._animationLoop( time, frame );\n\n\t\t};\n\n\t\tupdate();\n\n\t}\n\n\t/**\n\t * Stops the internal animation loop.\n\t */\n\tstop() {\n\n\t\tthis._context.cancelAnimationFrame( this._requestId );\n\n\t\tthis._requestId = null;\n\n\t}\n\n\t/**\n\t * Returns the user-level animation loop.\n\t *\n\t * @return {Function} The animation loop.\n\t */\n\tgetAnimationLoop() {\n\n\t\treturn this._animationLoop;\n\n\t}\n\n\t/**\n\t * Defines the user-level animation loop.\n\t *\n\t * @param {Function} callback - The animation loop.\n\t */\n\tsetAnimationLoop( callback ) {\n\n\t\tthis._animationLoop = callback;\n\n\t}\n\n\t/**\n\t * Returns the animation context.\n\t *\n\t * @return {Window|XRSession} The animation context.\n\t */\n\tgetContext() {\n\n\t\treturn this._context;\n\n\t}\n\n\t/**\n\t * Defines the context in which `requestAnimationFrame()` is executed.\n\t *\n\t * @param {Window|XRSession} context - The context to set.\n\t */\n\tsetContext( context ) {\n\n\t\tthis._context = context;\n\n\t}\n\n\t/**\n\t * Frees all internal resources and stops the animation loop.\n\t */\n\tdispose() {\n\n\t\tthis.stop();\n\n\t}\n\n}\n\n/**\n * Data structure for the renderer. It allows defining values\n * with chained, hierarchical keys. Keys are meant to be\n * objects since the module internally works with Weak Maps\n * for performance reasons.\n *\n * @private\n */\nclass ChainMap {\n\n\t/**\n\t * Constructs a new Chain Map.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The root Weak Map.\n\t\t *\n\t\t * @type {WeakMap}\n\t\t */\n\t\tthis.weakMap = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns the value for the given array of keys.\n\t *\n\t * @param {Array<Object>} keys - List of keys.\n\t * @return {Any} The value. Returns `undefined` if no value was found.\n\t */\n\tget( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length - 1; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return undefined;\n\n\t\t}\n\n\t\treturn map.get( keys[ keys.length - 1 ] );\n\n\t}\n\n\t/**\n\t * Sets the value for the given keys.\n\t *\n\t * @param {Array<Object>} keys - List of keys.\n\t * @param {Any} value - The value to set.\n\t * @return {ChainMap} A reference to this Chain Map.\n\t */\n\tset( keys, value ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length - 1; i ++ ) {\n\n\t\t\tconst key = keys[ i ];\n\n\t\t\tif ( map.has( key ) === false ) map.set( key, new WeakMap() );\n\n\t\t\tmap = map.get( key );\n\n\t\t}\n\n\t\tmap.set( keys[ keys.length - 1 ], value );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes a value for the given keys.\n\t *\n\t * @param {Array<Object>} keys - The keys.\n\t * @return {Boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.\n\t */\n\tdelete( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length - 1; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return false;\n\n\t\t}\n\n\t\treturn map.delete( keys[ keys.length - 1 ] );\n\n\t}\n\n}\n\nlet _id$9 = 0;\n\nfunction getKeys( obj ) {\n\n\tconst keys = Object.keys( obj );\n\n\tlet proto = Object.getPrototypeOf( obj );\n\n\twhile ( proto ) {\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( proto );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( descriptors[ key ] !== undefined ) {\n\n\t\t\t\tconst descriptor = descriptors[ key ];\n\n\t\t\t\tif ( descriptor && typeof descriptor.get === 'function' ) {\n\n\t\t\t\t\tkeys.push( key );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tproto = Object.getPrototypeOf( proto );\n\n\t}\n\n\treturn keys;\n\n}\n\n/**\n * A render object is the renderer's representation of single entity that gets drawn\n * with a draw command. There is no unique mapping of render objects to 3D objects in the\n * scene since render objects also depend from the used material, the current render context\n * and the current scene's lighting.\n *\n * In general, the basic process of the renderer is:\n *\n * - Analyze the 3D objects in the scene and generate render lists containing render items.\n * - Process the render lists by calling one or more render commands for each render item.\n * - For each render command, request a render object and perform the draw.\n *\n * The module provides an interface to get data required for the draw command like the actual\n * draw parameters or vertex buffers. It also holds a series of caching related methods since\n * creating render objects should only be done when necessary.\n *\n * @private\n */\nclass RenderObject {\n\n\t/**\n\t * Constructs a new render object.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t */\n\tconstructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {\n\n\t\tthis.id = _id$9 ++;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t * @private\n\t\t */\n\t\tthis._nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing geometries.\n\t\t *\n\t\t * @type {Geometries}\n\t\t * @private\n\t\t */\n\t\tthis._geometries = geometries;\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The 3D object's material.\n\t\t *\n\t\t * @type {Material}\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * The scene the 3D object belongs to.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the 3D object should be rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The lights node.\n\t\t *\n\t\t * @type {LightsNode}\n\t\t */\n\t\tthis.lightsNode = lightsNode;\n\n\t\t/**\n\t\t * The render context.\n\t\t *\n\t\t * @type {RenderContext}\n\t\t */\n\t\tthis.context = renderContext;\n\n\t\t/**\n\t\t * The 3D object's geometry.\n\t\t *\n\t\t * @type {BufferGeometry}\n\t\t */\n\t\tthis.geometry = object.geometry;\n\n\t\t/**\n\t\t * The render object's version.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = material.version;\n\n\t\t/**\n\t\t * The draw range of the geometry.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.drawRange = null;\n\n\t\t/**\n\t\t * An array holding the buffer attributes\n\t\t * of the render object. This entails attribute\n\t\t * definitions on geometry and node level.\n\t\t *\n\t\t * @type {Array<BufferAttribute>?}\n\t\t * @default null\n\t\t */\n\t\tthis.attributes = null;\n\n\t\t/**\n\t\t * A reference to a render pipeline the render\n\t\t * object is processed with.\n\t\t *\n\t\t * @type {RenderPipeline}\n\t\t * @default null\n\t\t */\n\t\tthis.pipeline = null;\n\n\t\t/**\n\t\t * Only relevant for objects using\n\t\t * multiple materials. This represents a group entry\n\t\t * from the respective `BufferGeometry`.\n\t\t *\n\t\t * @type {{start: Number, count: Number}?}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * An array holding the vertex buffers which can\n\t\t * be buffer attributes but also interleaved buffers.\n\t\t *\n\t\t * @type {Array<BufferAttribute|InterleavedBuffer>?}\n\t\t * @default null\n\t\t */\n\t\tthis.vertexBuffers = null;\n\n\t\t/**\n\t\t * The parameters for the draw command.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.drawParams = null;\n\n\t\t/**\n\t\t * If this render object is used inside a render bundle,\n\t\t * this property points to the respective bundle group.\n\t\t *\n\t\t * @type {BundleGroup?}\n\t\t * @default null\n\t\t */\n\t\tthis.bundle = null;\n\n\t\t/**\n\t\t * The clipping context.\n\t\t *\n\t\t * @type {ClippingContext}\n\t\t */\n\t\tthis.clippingContext = clippingContext;\n\n\t\t/**\n\t\t * The clipping context's cache key.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n\n\t\t/**\n\t\t * The initial node cache key.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.initialNodesCacheKey = this.getDynamicCacheKey();\n\n\t\t/**\n\t\t * The initial cache key.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.initialCacheKey = this.getCacheKey();\n\n\t\t/**\n\t\t * The node builder state.\n\t\t *\n\t\t * @type {NodeBuilderState?}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._nodeBuilderState = null;\n\n\t\t/**\n\t\t * An array of bindings.\n\t\t *\n\t\t * @type {Array<BindGroup>?}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._bindings = null;\n\n\t\t/**\n\t\t * Reference to the node material observer.\n\t\t *\n\t\t * @type {NodeMaterialObserver?}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._monitor = null;\n\n\t\t/**\n\t\t * An event listener which is defined by `RenderObjects`. It performs\n\t\t * clean up tasks when `dispose()` on this render object.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onDispose = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderObject = true;\n\n\t\t/**\n\t\t * An event listener which is executed when `dispose()` is called on\n\t\t * the render object's material.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onMaterialDispose = () => {\n\n\t\t\tthis.dispose();\n\n\t\t};\n\n\t\tthis.material.addEventListener( 'dispose', this.onMaterialDispose );\n\n\t}\n\n\t/**\n\t * Updates the clipping context.\n\t *\n\t * @param {ClippingContext} context - The clipping context to set.\n\t */\n\tupdateClipping( context ) {\n\n\t\tthis.clippingContext = context;\n\n\t}\n\n\t/**\n\t * Whether the clipping requires an update or not.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tget clippingNeedsUpdate() {\n\n\t\tif ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;\n\n\t\tthis.clippingContextCacheKey = this.clippingContext.cacheKey;\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * The number of clipping planes defined in context of hardware clipping.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget hardwareClippingPlanes() {\n\n\t\treturn this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n\n\t}\n\n\t/**\n\t * Returns the node builder state of this render object.\n\t *\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetNodeBuilderState() {\n\n\t\treturn this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );\n\n\t}\n\n\t/**\n\t * Returns the node material observer of this render object.\n\t *\n\t * @return {NodeMaterialObserver} The node material observer.\n\t */\n\tgetMonitor() {\n\n\t\treturn this._monitor || ( this._monitor = this.getNodeBuilderState().observer );\n\n\t}\n\n\t/**\n\t * Returns an array of bind groups of this render object.\n\t *\n\t * @return {Array<BindGroup>} The bindings.\n\t */\n\tgetBindings() {\n\n\t\treturn this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );\n\n\t}\n\n\t/**\n\t * Returns a binding group by group name of this render object.\n\t *\n\t * @param {String} name - The name of the binding group.\n\t * @return {BindGroup?} The bindings.\n\t */\n\tgetBindingGroup( name ) {\n\n\t\tfor ( const bindingGroup of this.getBindings() ) {\n\n\t\t\tif ( bindingGroup.name === name ) {\n\n\t\t\t\treturn bindingGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the index of the render object's geometry.\n\t *\n\t * @return {BufferAttribute?} The index. Returns `null` for non-indexed geometries.\n\t */\n\tgetIndex() {\n\n\t\treturn this._geometries.getIndex( this );\n\n\t}\n\n\t/**\n\t * Returns the indirect buffer attribute.\n\t *\n\t * @return {BufferAttribute?} The indirect attribute. `null` if no indirect drawing is used.\n\t */\n\tgetIndirect() {\n\n\t\treturn this._geometries.getIndirect( this );\n\n\t}\n\n\t/**\n\t * Returns an array that acts as a key for identifying the render object in a chain map.\n\t *\n\t * @return {Array<Object>} An array with object references.\n\t */\n\tgetChainArray() {\n\n\t\treturn [ this.object, this.material, this.context, this.lightsNode ];\n\n\t}\n\n\t/**\n\t * This method is used when the geometry of a 3D object has been exchanged and the\n\t * respective render object now requires an update.\n\t *\n\t * @param {BufferGeometry} geometry - The geometry to set.\n\t */\n\tsetGeometry( geometry ) {\n\n\t\tthis.geometry = geometry;\n\t\tthis.attributes = null;\n\n\t}\n\n\t/**\n\t * Returns the buffer attributes of the render object. The returned array holds\n\t * attribute definitions on geometry and node level.\n\t *\n\t * @return {Array<BufferAttribute>} An array with buffer attributes.\n\t */\n\tgetAttributes() {\n\n\t\tif ( this.attributes !== null ) return this.attributes;\n\n\t\tconst nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n\t\tconst geometry = this.geometry;\n\n\t\tconst attributes = [];\n\t\tconst vertexBuffers = new Set();\n\n\t\tfor ( const nodeAttribute of nodeAttributes ) {\n\n\t\t\tconst attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );\n\n\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\t\tvertexBuffers.add( bufferAttribute );\n\n\t\t}\n\n\t\tthis.attributes = attributes;\n\t\tthis.vertexBuffers = Array.from( vertexBuffers.values() );\n\n\t\treturn attributes;\n\n\t}\n\n\t/**\n\t * Returns the vertex buffers of the render object.\n\t *\n\t * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.\n\t */\n\tgetVertexBuffers() {\n\n\t\tif ( this.vertexBuffers === null ) this.getAttributes();\n\n\t\treturn this.vertexBuffers;\n\n\t}\n\n\t/**\n\t * Returns the draw parameters for the render object.\n\t *\n\t * @return {{vertexCount: Number, firstVertex: Number, instanceCount: Number, firstInstance: Number}} The draw parameters.\n\t */\n\tgetDrawParameters() {\n\n\t\tconst { object, material, geometry, group, drawRange } = this;\n\n\t\tconst drawParams = this.drawParams || ( this.drawParams = {\n\t\t\tvertexCount: 0,\n\t\t\tfirstVertex: 0,\n\t\t\tinstanceCount: 0,\n\t\t\tfirstInstance: 0\n\t\t} );\n\n\t\tconst index = this.getIndex();\n\t\tconst hasIndex = ( index !== null );\n\t\tconst instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );\n\n\t\tif ( instanceCount === 0 ) return null;\n\n\t\tdrawParams.instanceCount = instanceCount;\n\n\t\tif ( object.isBatchedMesh === true ) return drawParams;\n\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {\n\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tlet firstVertex = drawRange.start * rangeFactor;\n\t\tlet lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\tif ( group !== null ) {\n\n\t\t\tfirstVertex = Math.max( firstVertex, group.start * rangeFactor );\n\t\t\tlastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );\n\n\t\t}\n\n\t\tconst position = geometry.attributes.position;\n\t\tlet itemCount = Infinity;\n\n\t\tif ( hasIndex ) {\n\n\t\t\titemCount = index.count;\n\n\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\titemCount = position.count;\n\n\t\t}\n\n\t\tfirstVertex = Math.max( firstVertex, 0 );\n\t\tlastVertex = Math.min( lastVertex, itemCount );\n\n\t\tconst count = lastVertex - firstVertex;\n\n\t\tif ( count < 0 || count === Infinity ) return null;\n\n\t\tdrawParams.vertexCount = count;\n\t\tdrawParams.firstVertex = firstVertex;\n\n\t\treturn drawParams;\n\n\t}\n\n\t/**\n\t * Returns the render object's geometry cache key.\n\t *\n\t * The geometry cache key is part of the material cache key.\n\t *\n\t * @return {String} The geometry cache key.\n\t */\n\tgetGeometryCacheKey() {\n\n\t\tconst { geometry } = this;\n\n\t\tlet cacheKey = '';\n\n\t\tfor ( const name of Object.keys( geometry.attributes ).sort() ) {\n\n\t\t\tconst attribute = geometry.attributes[ name ];\n\n\t\t\tcacheKey += name + ',';\n\n\t\t\tif ( attribute.data ) cacheKey += attribute.data.stride + ',';\n\t\t\tif ( attribute.offset ) cacheKey += attribute.offset + ',';\n\t\t\tif ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';\n\t\t\tif ( attribute.normalized ) cacheKey += 'n,';\n\n\t\t}\n\n\t\t// structural equality isn't sufficient for morph targets since the\n\t\t// data are maintained in textures. only if the targets are all equal\n\t\t// the texture and thus the instance of `MorphNode` can be shared.\n\n\t\tfor ( const name of Object.keys( geometry.morphAttributes ).sort() ) {\n\n\t\t\tconst targets = geometry.morphAttributes[ name ];\n\n\t\t\tcacheKey += 'morph-' + name + ',';\n\n\t\t\tfor ( let i = 0, l = targets.length; i < l; i ++ ) {\n\n\t\t\t\tconst attribute = targets[ i ];\n\n\t\t\t\tcacheKey += attribute.id + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometry.index ) {\n\n\t\t\tcacheKey += 'index,';\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Returns the render object's material cache key.\n\t *\n\t * The material cache key is part of the render object cache key.\n\t *\n\t * @return {Number} The material cache key.\n\t */\n\tgetMaterialCacheKey() {\n\n\t\tconst { object, material } = this;\n\n\t\tlet cacheKey = material.customProgramCacheKey();\n\n\t\tfor ( const property of getKeys( material ) ) {\n\n\t\t\tif ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tlet valueKey;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\t// some material values require a formatting\n\n\t\t\t\tconst type = typeof value;\n\n\t\t\t\tif ( type === 'number' ) {\n\n\t\t\t\t\tvalueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n\n\t\t\t\t} else if ( type === 'object' ) {\n\n\t\t\t\t\tvalueKey = '{';\n\n\t\t\t\t\tif ( value.isTexture ) {\n\n\t\t\t\t\t\tvalueKey += value.mapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvalueKey += '}';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalueKey = String( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvalueKey = String( value );\n\n\t\t\t}\n\n\t\t\tcacheKey += /*property + ':' +*/ valueKey + ',';\n\n\t\t}\n\n\t\tcacheKey += this.clippingContextCacheKey + ',';\n\n\t\tif ( object.geometry ) {\n\n\t\t\tcacheKey += this.getGeometryCacheKey();\n\n\t\t}\n\n\t\tif ( object.skeleton ) {\n\n\t\t\tcacheKey += object.skeleton.bones.length + ',';\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tcacheKey += object._matricesTexture.uuid + ',';\n\n\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\tcacheKey += object._colorsTexture.uuid + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\t// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n\t\t\tcacheKey += object.uuid + ',';\n\n\t\t}\n\n\t\tcacheKey += object.receiveShadow + ',';\n\n\t\treturn hashString( cacheKey );\n\n\t}\n\n\t/**\n\t * Whether the geometry requires an update or not.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tget needsGeometryUpdate() {\n\n\t\treturn this.geometry.id !== this.object.geometry.id;\n\n\t}\n\n\t/**\n\t * Whether the render object requires an update or not.\n\t *\n\t * Note: There are two distinct places where render objects are checked for an update.\n\t *\n\t * 1. In `RenderObjects.get()` which is executed when the render object is request. This\n\t * method checks the `needsUpdate` flag and recreates the render object if necessary.\n\t * 2. In `Renderer._renderObjectDirect()` right after getting the render object via\n\t * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect\n\t * a need for a refresh due to material, geometry or object related value changes.\n\t *\n\t * TODO: Investigate if it's possible to merge both steps so there is only a single place\n\t * that performs the 'needsUpdate' check.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tget needsUpdate() {\n\n\t\treturn /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );\n\n\t}\n\n\t/**\n\t * Returns the dynamic cache key which represents a key that is computed per draw command.\n\t *\n\t * @return {Number} The cache key.\n\t */\n\tgetDynamicCacheKey() {\n\n\t\tlet cacheKey = 0;\n\n\t\t// `Nodes.getCacheKey()` returns an environment cache key which is not relevant when\n\t\t// the renderer is inside a shadow pass.\n\n\t\tif ( this.material.isShadowPassMaterial !== true ) {\n\n\t\t\tcacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );\n\n\t\t}\n\n\t\tif ( this.camera.isArrayCamera ) {\n\n\t\t\tcacheKey = hash$1( cacheKey, this.camera.cameras.length );\n\n\t\t}\n\n\t\tif ( this.object.receiveShadow ) {\n\n\t\t\tcacheKey = hash$1( cacheKey, 1 );\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Returns the render object's cache key.\n\t *\n\t * @return {Number} The cache key.\n\t */\n\tgetCacheKey() {\n\n\t\treturn this.getMaterialCacheKey() + this.getDynamicCacheKey();\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.material.removeEventListener( 'dispose', this.onMaterialDispose );\n\n\t\tthis.onDispose();\n\n\t}\n\n}\n\nconst _chainKeys$5 = [];\n\n/**\n * This module manages the render objects of the renderer.\n *\n * @private\n */\nclass RenderObjects {\n\n\t/**\n\t * Constructs a new render object management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n\t * @param {Bindings} bindings - Renderer component for managing bindings.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( renderer, nodes, geometries, pipelines, bindings, info ) {\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing geometries.\n\t\t *\n\t\t * @type {Geometries}\n\t\t */\n\t\tthis.geometries = geometries;\n\n\t\t/**\n\t\t * Renderer component for managing pipelines.\n\t\t *\n\t\t * @type {Pipelines}\n\t\t */\n\t\tthis.pipelines = pipelines;\n\n\t\t/**\n\t\t * Renderer component for managing bindings.\n\t\t *\n\t\t * @type {Bindings}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * A dictionary that manages render contexts in chain maps\n\t\t * for each pass ID.\n\t\t *\n\t\t * @type {Object<String,ChainMap>}\n\t\t */\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Returns a render object for the given object and state data.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the 3D object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} passId - An optional ID for identifying the pass.\n\t * @return {RenderObject} The render object.\n\t */\n\tget( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\t// reuse chainArray\n\t\t_chainKeys$5[ 0 ] = object;\n\t\t_chainKeys$5[ 1 ] = material;\n\t\t_chainKeys$5[ 2 ] = renderContext;\n\t\t_chainKeys$5[ 3 ] = lightsNode;\n\n\t\tlet renderObject = chainMap.get( _chainKeys$5 );\n\n\t\tif ( renderObject === undefined ) {\n\n\t\t\trenderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\tchainMap.set( _chainKeys$5, renderObject );\n\n\t\t} else {\n\n\t\t\trenderObject.updateClipping( clippingContext );\n\n\t\t\tif ( renderObject.needsGeometryUpdate ) {\n\n\t\t\t\trenderObject.setGeometry( object.geometry );\n\n\t\t\t}\n\n\t\t\tif ( renderObject.version !== material.version || renderObject.needsUpdate ) {\n\n\t\t\t\tif ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {\n\n\t\t\t\t\trenderObject.dispose();\n\n\t\t\t\t\trenderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderObject.version = material.version;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t_chainKeys$5.length = 0;\n\n\t\treturn renderObject;\n\n\t}\n\n\t/**\n\t * Returns a chain map for the given pass ID.\n\t *\n\t * @param {String} [passId='default'] - The pass ID.\n\t * @return {ChainMap} The chain map.\n\t */\n\tgetChainMap( passId = 'default' ) {\n\n\t\treturn this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Factory method for creating render objects with the given list of parameters.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} passId - An optional ID for identifying the pass.\n\t * @return {RenderObject} The render object.\n\t */\n\tcreateRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\tconst renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );\n\n\t\trenderObject.onDispose = () => {\n\n\t\t\tthis.pipelines.delete( renderObject );\n\t\t\tthis.bindings.delete( renderObject );\n\t\t\tthis.nodes.delete( renderObject );\n\n\t\t\tchainMap.delete( renderObject.getChainArray() );\n\n\t\t};\n\n\t\treturn renderObject;\n\n\t}\n\n\n}\n\n/**\n * Data structure for the renderer. It is intended to manage\n * data of objects in dictionaries.\n *\n * @private\n */\nclass DataMap {\n\n\t/**\n\t * Constructs a new data map.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * `DataMap` internally uses a weak map\n\t\t * to manage its data.\n\t\t *\n\t\t * @type {WeakMap}\n\t\t */\n\t\tthis.data = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object} The dictionary.\n\t */\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Deletes the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object?} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tlet map = null;\n\n\t\tif ( this.data.has( object ) ) {\n\n\t\t\tmap = this.data.get( object );\n\n\t\t\tthis.data.delete( object );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given object has a dictionary defined.\n\t *\n\t * @param {Object} object - The object to test.\n\t * @return {Boolean} Whether a dictionary is defined or not.\n\t */\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.data = new WeakMap();\n\n\t}\n\n}\n\nconst AttributeType = {\n\tVERTEX: 1,\n\tINDEX: 2,\n\tSTORAGE: 3,\n\tINDIRECT: 4\n};\n\n// size of a chunk in bytes (STD140 layout)\n\nconst GPU_CHUNK_BYTES = 16;\n\n// @TODO: Move to src/constants.js\n\nconst BlendColorFactor = 211;\nconst OneMinusBlendColorFactor = 212;\n\n/**\n * This renderer module manages geometry attributes.\n *\n * @private\n * @augments DataMap\n */\nclass Attributes extends DataMap {\n\n\t/**\n\t * Constructs a new attribute management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t */\n\tconstructor( backend ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Deletes the data for the given attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {Object} The deleted attribute data.\n\t */\n\tdelete( attribute ) {\n\n\t\tconst attributeData = super.delete( attribute );\n\n\t\tif ( attributeData !== undefined ) {\n\n\t\t\tthis.backend.destroyAttribute( attribute );\n\n\t\t}\n\n\t\treturn attributeData;\n\n\t}\n\n\t/**\n\t * Updates the given attribute. This method creates attribute buffers\n\t * for new attributes and updates data for existing ones.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute to update.\n\t * @param {Number} type - The attribute type.\n\t */\n\tupdate( attribute, type ) {\n\n\t\tconst data = this.get( attribute );\n\n\t\tif ( data.version === undefined ) {\n\n\t\t\tif ( type === AttributeType.VERTEX ) {\n\n\t\t\t\tthis.backend.createAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDEX ) {\n\n\t\t\t\tthis.backend.createIndexAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.STORAGE ) {\n\n\t\t\t\tthis.backend.createStorageAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDIRECT ) {\n\n\t\t\t\tthis.backend.createIndirectStorageAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tdata.version = this._getBufferAttribute( attribute ).version;\n\n\t\t} else {\n\n\t\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\t\tif ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {\n\n\t\t\t\tthis.backend.updateAttribute( attribute );\n\n\t\t\t\tdata.version = bufferAttribute.version;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Utility method for handling interleaved buffer attributes correctly.\n\t * To process them, their `InterleavedBuffer` is returned.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {BufferAttribute|InterleavedBuffer}\n\t */\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\n/**\n * Returns the wireframe version for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {Number} The version.\n */\nfunction getWireframeVersion( geometry ) {\n\n\treturn ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;\n\n}\n\n/**\n * Returns a wireframe index attribute for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {BufferAttribute} The wireframe index attribute.\n */\nfunction getWireframeIndex( geometry ) {\n\n\tconst indices = [];\n\n\tconst geometryIndex = geometry.index;\n\tconst geometryPosition = geometry.attributes.position;\n\n\tif ( geometryIndex !== null ) {\n\n\t\tconst array = geometryIndex.array;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst a = array[ i + 0 ];\n\t\t\tconst b = array[ i + 1 ];\n\t\t\tconst c = array[ i + 2 ];\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = geometryPosition.array;\n\n\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\tconst a = i + 0;\n\t\t\tconst b = i + 1;\n\t\t\tconst c = i + 2;\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t}\n\n\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\tattribute.version = getWireframeVersion( geometry );\n\n\treturn attribute;\n\n}\n\n/**\n * This renderer module manages geometries.\n *\n * @private\n * @augments DataMap\n */\nclass Geometries extends DataMap {\n\n\t/**\n\t * Constructs a new geometry management component.\n\t *\n\t * @param {Attributes} attributes - Renderer component for managing attributes.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( attributes, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Renderer component for managing attributes.\n\t\t *\n\t\t * @type {Attributes}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * Weak Map for managing attributes for wireframe rendering.\n\t\t *\n\t\t * @type {WeakMap<BufferGeometry,BufferAttribute>}\n\t\t */\n\t\tthis.wireframes = new WeakMap();\n\n\t\t/**\n\t\t * This Weak Map is used to make sure buffer attributes are\n\t\t * updated only once per render call.\n\t\t *\n\t\t * @type {WeakMap<BufferAttribute,Number>}\n\t\t */\n\t\tthis.attributeCall = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object has an initialized geometry.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether if the given render object has an initialized geometry or not.\n\t */\n\thas( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\n\t\treturn super.has( geometry ) && this.get( geometry ).initialized === true;\n\n\t}\n\n\t/**\n\t * Prepares the geometry of the given render object for rendering.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tif ( this.has( renderObject ) === false ) this.initGeometry( renderObject );\n\n\t\tthis.updateAttributes( renderObject );\n\n\t}\n\n\t/**\n\t * Initializes the geometry of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tinitGeometry( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\t\tconst geometryData = this.get( geometry );\n\n\t\tgeometryData.initialized = true;\n\n\t\tthis.info.memory.geometries ++;\n\n\t\tconst onDispose = () => {\n\n\t\t\tthis.info.memory.geometries --;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst geometryAttributes = renderObject.getAttributes();\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.attributes.delete( index );\n\n\t\t\t}\n\n\t\t\tfor ( const geometryAttribute of geometryAttributes ) {\n\n\t\t\t\tthis.attributes.delete( geometryAttribute );\n\n\t\t\t}\n\n\t\t\tconst wireframeAttribute = this.wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute !== undefined ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener( 'dispose', onDispose );\n\n\t\t};\n\n\t\tgeometry.addEventListener( 'dispose', onDispose );\n\n\t}\n\n\t/**\n\t * Updates the geometry attributes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateAttributes( renderObject ) {\n\n\t\t// attributes\n\n\t\tconst attributes = renderObject.getAttributes();\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.STORAGE );\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.VERTEX );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indexes\n\n\t\tconst index = this.getIndex( renderObject );\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.updateAttribute( index, AttributeType.INDEX );\n\n\t\t}\n\n\t\t// indirect\n\n\t\tconst indirect = renderObject.geometry.indirect;\n\n\t\tif ( indirect !== null ) {\n\n\t\t\tthis.updateAttribute( indirect, AttributeType.INDIRECT );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute to update.\n\t * @param {Number} type - The attribute type.\n\t */\n\tupdateAttribute( attribute, type ) {\n\n\t\tconst callId = this.info.render.calls;\n\n\t\tif ( ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( this.attributeCall.get( attribute ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.attributeCall.get( attribute ) === undefined ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t} else if ( this.attributeCall.get( attribute.data ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute.data, callId );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the indirect buffer attribute of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {BufferAttribute?} The indirect attribute. `null` if no indirect drawing is used.\n\t */\n\tgetIndirect( renderObject ) {\n\n\t\treturn renderObject.geometry.indirect;\n\n\t}\n\n\t/**\n\t * Returns the index of the given render object's geometry. This is implemented\n\t * in a method to return a wireframe index if necessary.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {BufferAttribute?} The index. Returns `null` for non-indexed geometries.\n\t */\n\tgetIndex( renderObject ) {\n\n\t\tconst { geometry, material } = renderObject;\n\n\t\tlet index = geometry.index;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tconst wireframes = this.wireframes;\n\n\t\t\tlet wireframeAttribute = wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute === undefined ) {\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tindex = wireframeAttribute;\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n}\n\n/**\n * This renderer module provides a series of statistical information\n * about the GPU memory and the rendering process. Useful for debugging\n * and monitoring.\n */\nclass Info {\n\n\t/**\n\t * Constructs a new info component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Whether frame related metrics should automatically\n\t\t * be resetted or not. This property should be set to `false`\n\t\t * by apps which manage their own animation loop. They must\n\t\t * then call `renderer.info.reset()` once per frame manually.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoReset = true;\n\n\t\t/**\n\t\t * The current frame ID. This ID is managed\n\t\t * by `NodeFrame`.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.frame = 0;\n\n\t\t/**\n\t\t * The number of render calls since the\n\t\t * app has been started.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.calls = 0;\n\n\t\t/**\n\t\t * Render related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {Number} calls - The number of render calls since the app has been started.\n\t\t * @property {Number} frameCalls - The number of render calls of the current frame.\n\t\t * @property {Number} drawCalls - The number of draw calls of the current frame.\n\t\t * @property {Number} triangles - The number of rendered triangle primitives of the current frame.\n\t\t * @property {Number} points - The number of rendered point primitives of the current frame.\n\t\t * @property {Number} lines - The number of rendered line primitives of the current frame.\n\t\t * @property {Number} timestamp - The timestamp of the frame when using `renderer.renderAsync()`.\n\t\t */\n\t\tthis.render = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\tdrawCalls: 0,\n\t\t\ttriangles: 0,\n\t\t\tpoints: 0,\n\t\t\tlines: 0,\n\t\t\ttimestamp: 0,\n\t\t};\n\n\t\t/**\n\t\t * Compute related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {Number} calls - The number of compute calls since the app has been started.\n\t\t * @property {Number} frameCalls - The number of compute calls of the current frame.\n\t\t * @property {Number} timestamp - The timestamp of the frame when using `renderer.computeAsync()`.\n\t\t */\n\t\tthis.compute = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\ttimestamp: 0\n\t\t};\n\n\t\t/**\n\t\t * Memory related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {Number} geometries - The number of active geometries.\n\t\t * @property {Number} frameCalls - The number of active textures.\n\t\t */\n\t\tthis.memory = {\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\t\t};\n\n\t}\n\n\t/**\n\t * This method should be executed per draw call and updates the corresponding metrics.\n\t *\n\t * @param {Object3D} object - The 3D object that is going to be rendered.\n\t * @param {Number} count - The vertex or index count.\n\t * @param {Number} instanceCount - The instance count.\n\t */\n\tupdate( object, count, instanceCount ) {\n\n\t\tthis.render.drawCalls ++;\n\n\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\tthis.render.triangles += instanceCount * ( count / 3 );\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\tthis.render.points += instanceCount * count;\n\n\t\t} else if ( object.isLineSegments ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count / 2 );\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count - 1 );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.WebGPUInfo: Unknown object type.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resets frame related metrics.\n\t */\n\treset() {\n\n\t\tthis.render.drawCalls = 0;\n\t\tthis.render.frameCalls = 0;\n\t\tthis.compute.frameCalls = 0;\n\n\t\tthis.render.triangles = 0;\n\t\tthis.render.points = 0;\n\t\tthis.render.lines = 0;\n\n\n\t}\n\n\t/**\n\t * Performs a complete reset of the object.\n\t */\n\tdispose() {\n\n\t\tthis.reset();\n\n\t\tthis.calls = 0;\n\n\t\tthis.render.calls = 0;\n\t\tthis.compute.calls = 0;\n\n\t\tthis.render.timestamp = 0;\n\t\tthis.compute.timestamp = 0;\n\t\tthis.memory.geometries = 0;\n\t\tthis.memory.textures = 0;\n\n\t}\n\n}\n\n/**\n * Abstract class for representing pipelines.\n *\n * @private\n * @abstract\n */\nclass Pipeline {\n\n\t/**\n\t * Constructs a new pipeline.\n\t *\n\t * @param {String} cacheKey - The pipeline's cache key.\n\t */\n\tconstructor( cacheKey ) {\n\n\t\t/**\n\t\t * The pipeline's cache key.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.cacheKey = cacheKey;\n\n\t\t/**\n\t\t * How often the pipeline is currently in use.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\n/**\n * Class for representing render pipelines.\n *\n * @private\n * @augments Pipeline\n */\nclass RenderPipeline extends Pipeline {\n\n\t/**\n\t * Constructs a new render pipeline.\n\t *\n\t * @param {String} cacheKey - The pipeline's cache key.\n\t * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.\n\t * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.\n\t */\n\tconstructor( cacheKey, vertexProgram, fragmentProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\t/**\n\t\t * The pipeline's vertex shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.vertexProgram = vertexProgram;\n\n\t\t/**\n\t\t * The pipeline's fragment shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.fragmentProgram = fragmentProgram;\n\n\t}\n\n}\n\n/**\n * Class for representing compute pipelines.\n *\n * @private\n * @augments Pipeline\n */\nclass ComputePipeline extends Pipeline {\n\n\t/**\n\t * Constructs a new render pipeline.\n\t *\n\t * @param {String} cacheKey - The pipeline's cache key.\n\t * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.\n\t */\n\tconstructor( cacheKey, computeProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\t/**\n\t\t * The pipeline's compute shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.computeProgram = computeProgram;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isComputePipeline = true;\n\n\t}\n\n}\n\nlet _id$8 = 0;\n\n/**\n * Class for representing programmable stages which are vertex,\n * fragment or compute shaders. Unlike fixed-function states (like blending),\n * they represent the programmable part of a pipeline.\n *\n * @private\n */\nclass ProgrammableStage {\n\n\t/**\n\t * Constructs a new programmable stage.\n\t *\n\t * @param {String} code - The shader code.\n\t * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.\n\t * @param {String} name - The name of the shader.\n\t * @param {Array<Object>?} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t * @param {Array<Object>?} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t */\n\tconstructor( code, stage, name, transforms = null, attributes = null ) {\n\n\t\t/**\n\t\t * The id of the programmable stage.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$8 ++;\n\n\t\t/**\n\t\t * The shader code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.code = code;\n\n\t\t/**\n\t\t * The type of stage.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.stage = stage;\n\n\t\t/**\n\t\t * The name of the stage.\n\t\t * This is used for debugging purposes.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t\t *\n\t\t * @type {Array<Object>?}\n\t\t */\n\t\tthis.transforms = transforms;\n\n\t\t/**\n\t\t * The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t\t *\n\t\t * @type {Array<Object>?}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * How often the programmable stage is currently in use.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\n/**\n * This renderer module manages the pipelines of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Pipelines extends DataMap {\n\n\t/**\n\t * Constructs a new pipeline management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t */\n\tconstructor( backend, nodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * A references to the bindings management component.\n\t\t * This reference will be set inside the `Bindings`\n\t\t * constructor.\n\t\t *\n\t\t * @type {Bindings?}\n\t\t * @default null\n\t\t */\n\t\tthis.bindings = null;\n\n\t\t/**\n\t\t * Internal cache for maintaining pipelines.\n\t\t * The key of the map is a cache key, the value the pipeline.\n\t\t *\n\t\t * @type {Map<String,Pipeline>}\n\t\t */\n\t\tthis.caches = new Map();\n\n\t\t/**\n\t\t * This dictionary maintains for each shader stage type (vertex,\n\t\t * fragment and compute) the programmable stage objects which\n\t\t * represent the actual shader code.\n\t\t *\n\t\t * @type {Object<String,Map>}\n\t\t */\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a compute pipeline for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\tgetForCompute( computeNode, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( computeNode );\n\n\t\tif ( this._needsComputeUpdate( computeNode ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.computeProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = this.nodes.getForCompute( computeNode );\n\n\t\t\t// programmable stage\n\n\t\t\tlet stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );\n\n\t\t\tif ( stageCompute === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );\n\n\t\t\t\tstageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );\n\t\t\t\tthis.programs.compute.set( nodeBuilderState.computeShader, stageCompute );\n\n\t\t\t\tbackend.createProgram( stageCompute );\n\n\t\t\t}\n\n\t\t\t// determine compute pipeline\n\n\t\t\tconst cacheKey = this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageCompute.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.version = computeNode.version;\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>?} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n\t * @return {RenderPipeline} The render pipeline.\n\t */\n\tgetForRender( renderObject, promises = null ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( renderObject );\n\n\t\tif ( this._needsRenderUpdate( renderObject ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.vertexProgram.usedTimes --;\n\t\t\t\tpreviousPipeline.fragmentProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = renderObject.getNodeBuilderState();\n\n\t\t\tconst name = renderObject.material ? renderObject.material.name : '';\n\n\t\t\t// programmable stages\n\n\t\t\tlet stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );\n\n\t\t\tif ( stageVertex === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );\n\n\t\t\t\tstageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex', name );\n\t\t\t\tthis.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );\n\n\t\t\t\tbackend.createProgram( stageVertex );\n\n\t\t\t}\n\n\t\t\tlet stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );\n\n\t\t\tif ( stageFragment === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );\n\n\t\t\t\tstageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment', name );\n\t\t\t\tthis.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );\n\n\t\t\t\tbackend.createProgram( stageFragment );\n\n\t\t\t}\n\n\t\t\t// determine render pipeline\n\n\t\t\tconst cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );\n\n\t\t\t} else {\n\n\t\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageVertex.usedTimes ++;\n\t\t\tstageFragment.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\t/**\n\t * Deletes the pipeline for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @return {Object?} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tconst pipeline = this.get( object ).pipeline;\n\n\t\tif ( pipeline ) {\n\n\t\t\t// pipeline\n\n\t\t\tpipeline.usedTimes --;\n\n\t\t\tif ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );\n\n\t\t\t// programs\n\n\t\t\tif ( pipeline.isComputePipeline ) {\n\n\t\t\t\tpipeline.computeProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );\n\n\t\t\t} else {\n\n\t\t\t\tpipeline.fragmentProgram.usedTimes --;\n\t\t\t\tpipeline.vertexProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );\n\t\t\t\tif ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\t/**\n\t * Updates the pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tthis.getForRender( renderObject );\n\n\t}\n\n\t/**\n\t * Returns a compute pipeline for the given parameters.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n\t * @param {String} cacheKey - The cache key.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\t_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new ComputePipeline( cacheKey, stageCompute );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\tthis.backend.createComputePipeline( pipeline, bindings );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the given parameters.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n\t * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n\t * @param {String} cacheKey - The cache key.\n\t * @param {Array<Promise>?} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\t_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t// The `promises` array is `null` by default and only set to an empty array when\n\t\t\t// `Renderer.compileAsync()` is used. The next call actually fills the array with\n\t\t\t// pending promises that resolve when the render pipelines are ready for rendering.\n\n\t\t\tthis.backend.createRenderPipeline( renderObject, promises );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Computes a cache key representing a compute pipeline.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n\t * @return {String} The cache key.\n\t */\n\t_getComputeCacheKey( computeNode, stageCompute ) {\n\n\t\treturn computeNode.id + ',' + stageCompute.id;\n\n\t}\n\n\t/**\n\t * Computes a cache key representing a render pipeline.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n\t * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n\t * @return {String} The cache key.\n\t */\n\t_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {\n\n\t\treturn stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );\n\n\t}\n\n\t/**\n\t * Releases the given pipeline.\n\t *\n\t * @private\n\t * @param {Pipeline} pipeline - The pipeline to release.\n\t */\n\t_releasePipeline( pipeline ) {\n\n\t\tthis.caches.delete( pipeline.cacheKey );\n\n\t}\n\n\t/**\n\t * Releases the shader program.\n\t *\n\t * @private\n\t * @param {Object} program - The shader program to release.\n\t */\n\t_releaseProgram( program ) {\n\n\t\tconst code = program.code;\n\t\tconst stage = program.stage;\n\n\t\tthis.programs[ stage ].delete( code );\n\n\t}\n\n\t/**\n\t * Returns `true` if the compute pipeline for the given compute node requires an update.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @return {Boolean} Whether the compute pipeline for the given compute node requires an update or not.\n\t */\n\t_needsComputeUpdate( computeNode ) {\n\n\t\tconst data = this.get( computeNode );\n\n\t\treturn data.pipeline === undefined || data.version !== computeNode.version;\n\n\t}\n\n\t/**\n\t * Returns `true` if the render pipeline for the given render object requires an update.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the render object for the given render object requires an update or not.\n\t */\n\t_needsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\treturn data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );\n\n\t}\n\n}\n\n/**\n * This renderer module manages the bindings of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Bindings extends DataMap {\n\n\t/**\n\t * Constructs a new bindings management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Textures} textures - Renderer component for managing textures.\n\t * @param {Attributes} attributes - Renderer component for managing attributes.\n\t * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( backend, nodes, textures, attributes, pipelines, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing textures.\n\t\t *\n\t\t * @type {Textures}\n\t\t */\n\t\tthis.textures = textures;\n\n\t\t/**\n\t\t * Renderer component for managing pipelines.\n\t\t *\n\t\t * @type {Pipelines}\n\t\t */\n\t\tthis.pipelines = pipelines;\n\n\t\t/**\n\t\t * Renderer component for managing attributes.\n\t\t *\n\t\t * @type {Attributes}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\tthis.pipelines.bindings = this; // assign bindings to pipelines\n\n\t}\n\n\t/**\n\t * Returns the bind groups for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Array<BindGroup>} The bind groups.\n\t */\n\tgetForRender( renderObject ) {\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\t// each object defines an array of bindings (ubos, textures, samplers etc.)\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\t/**\n\t * Returns the bind groups for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @return {Array<BindGroup>} The bind groups.\n\t */\n\tgetForCompute( computeNode ) {\n\n\t\tconst bindings = this.nodes.getForCompute( computeNode ).bindings;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\t/**\n\t * Updates the bindings for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tupdateForCompute( computeNode ) {\n\n\t\tthis._updateBindings( this.getForCompute( computeNode ) );\n\n\t}\n\n\t/**\n\t * Updates the bindings for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tthis._updateBindings( this.getForRender( renderObject ) );\n\n\t}\n\n\t/**\n\t * Updates the given array of bindings.\n\t *\n\t * @param {Array<BindGroup>} bindings - The bind groups.\n\t */\n\t_updateBindings( bindings ) {\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tthis._update( bindGroup, bindings );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Initializes the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group to initialize.\n\t */\n\t_init( bindGroup ) {\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isSampledTexture ) {\n\n\t\t\t\tthis.textures.updateTexture( binding.texture );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\tconst attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n\n\t\t\t\tthis.attributes.update( attribute, attributeType );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group to update.\n\t * @param {Array<BindGroup>} bindings - The bind groups.\n\t */\n\t_update( bindGroup, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tlet needsBindingsUpdate = false;\n\t\tlet cacheBindings = true;\n\t\tlet cacheIndex = 0;\n\t\tlet version = 0;\n\n\t\t// iterate over all bindings and check if buffer updates or a new binding group is required\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isNodeUniformsGroup ) {\n\n\t\t\t\tconst updated = this.nodes.updateGroup( binding );\n\n\t\t\t\t// every uniforms group is a uniform buffer. So if no update is required,\n\t\t\t\t// we move one with the next binding. Otherwise the next if block will update the group.\n\n\t\t\t\tif ( updated === false ) continue;\n\n\t\t\t}\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tbackend.updateBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tbinding.update();\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texturesTextureData = this.textures.get( binding.texture );\n\n\t\t\t\tif ( binding.needsBindingsUpdate( texturesTextureData.generation ) ) needsBindingsUpdate = true;\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tconst texture = binding.texture;\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\n\t\t\t\t}\n\n\t\t\t\tconst textureData = backend.get( texture );\n\n\t\t\t\tif ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {\n\n\t\t\t\t\tcacheBindings = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcacheIndex = cacheIndex * 10 + texture.id;\n\t\t\t\t\tversion += texture.version;\n\n\t\t\t\t}\n\n\t\t\t\tif ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {\n\n\t\t\t\t\t// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend\n\t\t\t\t\tconsole.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\t\t\t\t\tneedsBindingsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\tif ( binding.store === true ) {\n\n\t\t\t\t\t\ttextureData.needsMipmap = true;\n\n\t\t\t\t\t} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {\n\n\t\t\t\t\t\tthis.backend.generateMipmaps( texture );\n\n\t\t\t\t\t\ttextureData.needsMipmap = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsBindingsUpdate === true ) {\n\n\t\t\tthis.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Default sorting function for opaque render items.\n *\n * @private\n * @function\n * @param {Object} a - The first render item.\n * @param {Object} b - The second render item.\n * @return {Number} A numeric value which defines the sort order.\n */\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n/**\n * Default sorting function for transparent render items.\n *\n * @private\n * @function\n * @param {Object} a - The first render item.\n * @param {Object} b - The second render item.\n * @return {Number} A numeric value which defines the sort order.\n */\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given transparent material requires a double pass.\n *\n * @private\n * @function\n * @param {Material} material - The transparent material.\n * @return {Boolean} Whether the given material requires a double pass or not.\n */\nfunction needsDoublePass( material ) {\n\n\tconst hasTransmission = material.transmission > 0 || material.transmissionNode;\n\n\treturn hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;\n\n}\n\n/**\n * When the renderer analyzes the scene at the beginning of a render call,\n * it stores 3D object for further processing in render lists. Depending on the\n * properties of a 3D objects (like their transformation or material state), the\n * objects are maintained in ordered lists for the actual rendering.\n *\n * Render lists are unique per scene and camera combination.\n *\n * @private\n * @augments Pipeline\n */\nclass RenderList {\n\n\t/**\n\t * Constructs a render list.\n\t *\n\t * @param {Lighting} lighting - The lighting management component.\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t */\n\tconstructor( lighting, scene, camera ) {\n\n\t\t/**\n\t\t * 3D objects are transformed into render items and stored in this array.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.renderItems = [];\n\n\t\t/**\n\t\t * The current render items index.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderItemsIndex = 0;\n\n\t\t/**\n\t\t * A list with opaque render items.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.opaque = [];\n\n\t\t/**\n\t\t * A list with transparent render items which require\n\t\t * double pass rendering (e.g. transmissive objects).\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transparentDoublePass = [];\n\n\t\t/**\n\t\t * A list with transparent render items.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transparent = [];\n\n\t\t/**\n\t\t * A list with transparent render bundle data.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.bundles = [];\n\n\t\t/**\n\t\t * The render list's lights node. This node is later\n\t\t * relevant for the actual analytical light nodes which\n\t\t * compute the scene's lighting in the shader.\n\t\t *\n\t\t * @type {LightsNode}\n\t\t */\n\t\tthis.lightsNode = lighting.getNode( scene, camera );\n\n\t\t/**\n\t\t * The scene's lights stored in an array. This array\n\t\t * is used to setup the lights node.\n\t\t *\n\t\t * @type {Array<Light>}\n\t\t */\n\t\tthis.lightsArray = [];\n\n\t\t/**\n\t\t * The scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * How many objects perform occlusion query tests.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.occlusionQueryCount = 0;\n\n\t}\n\n\t/**\n\t * This method is called right at the beginning of a render call\n\t * before the scene is analyzed. It prepares the internal data\n\t * structures for the upcoming render lists generation.\n\t *\n\t * @return {RenderList} A reference to this render list.\n\t */\n\tbegin() {\n\n\t\tthis.renderItemsIndex = 0;\n\n\t\tthis.opaque.length = 0;\n\t\tthis.transparentDoublePass.length = 0;\n\t\tthis.transparent.length = 0;\n\t\tthis.bundles.length = 0;\n\n\t\tthis.lightsArray.length = 0;\n\n\t\tthis.occlusionQueryCount = 0;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a render item for the giving render item state. The state is defined\n\t * by a series of object-related parameters.\n\t *\n\t * The method avoids object creation by holding render items and reusing them in\n\t * subsequent render calls (just with different property values).\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Number} groupOrder - The current group order.\n\t * @param {Number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t * @return {Object} The render item.\n\t */\n\tgetNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tlet renderItem = this.renderItems[ this.renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group,\n\t\t\t\tclippingContext: clippingContext\n\t\t\t};\n\n\t\t\tthis.renderItems[ this.renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\t\t\trenderItem.clippingContext = clippingContext;\n\n\t\t}\n\n\t\tthis.renderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\t/**\n\t * Pushes the given object as a render item to the internal render lists.\n\t * The selected lists depend on the object properties.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Number} groupOrder - The current group order.\n\t * @param {Number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\tpush( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( object.occlusionTest === true ) this.occlusionQueryCount ++;\n\n\t\tif ( material.transparent === true || material.transmission > 0 ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );\n\n\t\t\tthis.transparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inserts the given object as a render item at the start of the internal render lists.\n\t * The selected lists depend on the object properties.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Number} groupOrder - The current group order.\n\t * @param {Number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\tunshift( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( material.transparent === true || material.transmission > 0 ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );\n\n\t\t\tthis.transparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pushes render bundle group data into the render list.\n\t *\n\t * @param {Object} group - Bundle group data.\n\t */\n\tpushBundle( group ) {\n\n\t\tthis.bundles.push( group );\n\n\t}\n\n\t/**\n\t * Pushes a light into the render list.\n\t *\n\t * @param {Light} light - The light.\n\t */\n\tpushLight( light ) {\n\n\t\tthis.lightsArray.push( light );\n\n\t}\n\n\t/**\n\t * Sorts the internal render lists.\n\t *\n\t * @param {function(Any, Any): Number} customOpaqueSort - A custom sort function for opaque objects.\n\t * @param {function(Any, Any): Number} customTransparentSort -  A custom sort function for transparent objects.\n\t */\n\tsort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\t/**\n\t * This method performs finalizing tasks right after the render lists\n\t * have been generated.\n\t */\n\tfinish() {\n\n\t\t// update lights\n\n\t\tthis.lightsNode.setLights( this.lightsArray );\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = this.renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.groupOrder = null;\n\t\t\trenderItem.renderOrder = null;\n\t\t\trenderItem.z = null;\n\t\t\trenderItem.group = null;\n\t\t\trenderItem.clippingContext = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _chainKeys$4 = [];\n\n/**\n * This renderer module manages the render lists which are unique\n * per scene and camera combination.\n *\n * @private\n */\nclass RenderLists {\n\n\t/**\n\t * Constructs a render lists management component.\n\t *\n\t * @param {Lighting} lighting - The lighting management component.\n\t */\n\tconstructor( lighting ) {\n\n\t\t/**\n\t\t * The lighting management component.\n\t\t *\n\t\t * @type {Lighting}\n\t\t */\n\t\tthis.lighting = lighting;\n\n\t\t/**\n\t\t * The internal chain map which holds the render lists.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n\t/**\n\t * Returns a render list for the given scene and camera.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera.\n\t * @return {RenderList} The render list.\n\t */\n\tget( scene, camera ) {\n\n\t\tconst lists = this.lists;\n\n\t\t_chainKeys$4[ 0 ] = scene;\n\t\t_chainKeys$4[ 1 ] = camera;\n\n\t\tlet list = lists.get( _chainKeys$4 );\n\n\t\tif ( list === undefined ) {\n\n\t\t\tlist = new RenderList( this.lighting, scene, camera );\n\t\t\tlists.set( _chainKeys$4, list );\n\n\t\t}\n\n\t\t_chainKeys$4.length = 0;\n\n\t\treturn list;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n}\n\nlet _id$7 = 0;\n\n/**\n * Any render or compute command is executed in a specific context that defines\n * the state of the renderer and its backend. Typical examples for such context\n * data are the current clear values or data from the active framebuffer. This\n * module is used to represent these contexts as objects.\n *\n * @private\n */\nclass RenderContext {\n\n\t/**\n\t * Constructs a new render context.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The context's ID.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$7 ++;\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a color attachment.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.color = true;\n\n\t\t/**\n\t\t * Whether the color attachment should be cleared or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearColor = true;\n\n\t\t/**\n\t\t * The clear color value.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default true\n\t\t */\n\t\tthis.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a depth attachment.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.depth = true;\n\n\t\t/**\n\t\t * Whether the depth attachment should be cleared or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearDepth = true;\n\n\t\t/**\n\t\t * The clear depth value.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.clearDepthValue = 1;\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a stencil attachment.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencil = false;\n\n\t\t/**\n\t\t * Whether the stencil attachment should be cleared or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearStencil = true;\n\n\t\t/**\n\t\t * The clear stencil value.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.clearStencilValue = 1;\n\n\t\t/**\n\t\t * By default the viewport encloses the entire framebuffer If a smaller\n\t\t * viewport is manually defined, this property is to `true` by the renderer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.viewport = false;\n\n\t\t/**\n\t\t * The viewport value. This value is in physical pixels meaning it incorporates\n\t\t * the renderer's pixel ratio. The viewport property of render targets or\n\t\t * the renderer is in logical pixels.\n\t\t *\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis.viewportValue = new Vector4();\n\n\t\t/**\n\t\t * When the scissor test is active and scissor rectangle smaller than the\n\t\t * framebuffers dimensions, this property is to `true` by the renderer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.scissor = false;\n\n\t\t/**\n\t\t * The scissor rectangle.\n\t\t *\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis.scissorValue = new Vector4();\n\n\t\t/**\n\t\t * The active render target.\n\t\t *\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis.renderTarget = null;\n\n\t\t/**\n\t\t * The textures of the active render target.\n\t\t * `null` when no render target is set.\n\t\t *\n\t\t * @type {Array<Texture>?}\n\t\t * @default null\n\t\t */\n\t\tthis.textures = null;\n\n\t\t/**\n\t\t * The depth texture of the active render target.\n\t\t * `null` when no render target is set.\n\t\t *\n\t\t * @type {DepthTexture?}\n\t\t * @default null\n\t\t */\n\t\tthis.depthTexture = null;\n\n\t\t/**\n\t\t * The active cube face.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.activeCubeFace = 0;\n\n\t\t/**\n\t\t * The active mipmap level.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.activeMipmapLevel = 0;\n\n\t\t/**\n\t\t * The number of MSAA samples. This value is always `1` when\n\t\t * MSAA isn't used.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.sampleCount = 1;\n\n\t\t/**\n\t\t * The active render target's width in physical pixels.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.width = 0;\n\n\t\t/**\n\t\t * The active render target's height in physical pixels.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.height = 0;\n\n\t\t/**\n\t\t * The occlusion query count.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.occlusionQueryCount = 0;\n\n\t\t/**\n\t\t * The current clipping context.\n\t\t *\n\t\t * @type {ClippingContext?}\n\t\t * @default null\n\t\t */\n\t\tthis.clippingContext = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderContext = true;\n\n\t}\n\n\t/**\n\t * Returns the cache key of this render context.\n\t *\n\t * @return {Number} The cache key.\n\t */\n\tgetCacheKey() {\n\n\t\treturn getCacheKey( this );\n\n\t}\n\n}\n\n/**\n * Computes a cache key for the given render context. This key\n * should identify the render target state so it is possible to\n * configure the correct attachments in the respective backend.\n *\n * @param {RenderContext} renderContext - The render context.\n * @return {Number} The cache key.\n */\nfunction getCacheKey( renderContext ) {\n\n\tconst { textures, activeCubeFace } = renderContext;\n\n\tconst values = [ activeCubeFace ];\n\n\tfor ( const texture of textures ) {\n\n\t\tvalues.push( texture.id );\n\n\t}\n\n\treturn hashArray( values );\n\n}\n\nconst _chainKeys$3 = [];\nconst _defaultScene = /*@__PURE__*/ new Scene();\nconst _defaultCamera = /*@__PURE__*/ new Camera();\n\n/**\n * This module manages the render contexts of the renderer.\n *\n * @private\n */\nclass RenderContexts {\n\n\t/**\n\t * Constructs a new render context management component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A dictionary that manages render contexts in chain maps\n\t\t * for each attachment state.\n\t\t *\n\t\t * @type {Object<String,ChainMap>}\n\t\t */\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Returns a render context for the given scene, camera and render target.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {RenderTarget?} [renderTarget=null] - The active render target.\n\t * @return {RenderContext} The render context.\n\t */\n\tget( scene, camera, renderTarget = null ) {\n\n\t\t_chainKeys$3[ 0 ] = scene;\n\t\t_chainKeys$3[ 1 ] = camera;\n\n\t\tlet attachmentState;\n\n\t\tif ( renderTarget === null ) {\n\n\t\t\tattachmentState = 'default';\n\n\t\t} else {\n\n\t\t\tconst format = renderTarget.texture.format;\n\t\t\tconst count = renderTarget.textures.length;\n\n\t\t\tattachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;\n\n\t\t}\n\n\t\tconst chainMap = this._getChainMap( attachmentState );\n\n\t\tlet renderState = chainMap.get( _chainKeys$3 );\n\n\t\tif ( renderState === undefined ) {\n\n\t\t\trenderState = new RenderContext();\n\n\t\t\tchainMap.set( _chainKeys$3, renderState );\n\n\t\t}\n\n\t\t_chainKeys$3.length = 0;\n\n\t\tif ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\n\t\treturn renderState;\n\n\t}\n\n\t/**\n\t * Returns a render context intended for clear operations.\n\t *\n\t * @param {RenderTarget?} [renderTarget=null] - The active render target.\n\t * @return {RenderContext} The render context.\n\t */\n\tgetForClear( renderTarget = null ) {\n\n\t\treturn this.get( _defaultScene, _defaultCamera, renderTarget );\n\n\t}\n\n\t/**\n\t * Returns a chain map for the given attachment state.\n\t *\n\t * @private\n\t * @param {String} attachmentState - The attachment state.\n\t * @return {ChainMap} The chain map.\n\t */\n\t_getChainMap( attachmentState ) {\n\n\t\treturn this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n}\n\nconst _size$3 = /*@__PURE__*/ new Vector3();\n\n/**\n * This module manages the textures of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Textures extends DataMap {\n\n\t/**\n\t * Constructs a new texture management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( renderer, backend, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t}\n\n\t/**\n\t * Updates the given render target. Based on the given render target configuration,\n\t * it updates the texture states representing the attachments of the framebuffer.\n\t *\n\t * @param {RenderTarget} renderTarget - The render target to update.\n\t * @param {Number} [activeMipmapLevel=0] - The active mipmap level.\n\t */\n\tupdateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {\n\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tconst sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\t\tconst depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst size = this.getSize( textures[ 0 ] );\n\n\t\tconst mipWidth = size.width >> activeMipmapLevel;\n\t\tconst mipHeight = size.height >> activeMipmapLevel;\n\n\t\tlet depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];\n\t\tconst useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n\n\t\tlet textureNeedsUpdate = false;\n\n\t\tif ( depthTexture === undefined && useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\t\t\tdepthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n\t\t\tdepthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\tdepthTexture.image.height = mipHeight;\n\n\t\t\tdepthTextureMips[ activeMipmapLevel ] = depthTexture;\n\n\t\t}\n\n\t\tif ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\t\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\t\tdepthTexture.image.height = mipHeight;\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderTargetData.width = size.width;\n\t\trenderTargetData.height = size.height;\n\t\trenderTargetData.textures = textures;\n\t\trenderTargetData.depthTexture = depthTexture || null;\n\t\trenderTargetData.depth = renderTarget.depthBuffer;\n\t\trenderTargetData.stencil = renderTarget.stencilBuffer;\n\t\trenderTargetData.renderTarget = renderTarget;\n\n\t\tif ( renderTargetData.sampleCount !== sampleCount ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\trenderTargetData.sampleCount = sampleCount;\n\n\t\t}\n\n\t\t//\n\n\n\t\tconst options = { sampleCount };\n\n\t\t// XR render targets require no texture updates\n\n\t\tif ( renderTarget.isXRRenderTarget !== true ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( textureNeedsUpdate ) texture.needsUpdate = true;\n\n\t\t\t\tthis.updateTexture( texture, options );\n\n\t\t\t}\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tthis.updateTexture( depthTexture, options );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( renderTargetData.initialized !== true ) {\n\n\t\t\trenderTargetData.initialized = true;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tthis._destroyTexture( textures[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( depthTexture ) {\n\n\t\t\t\t\tthis._destroyTexture( depthTexture );\n\n\t\t\t\t}\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given texture. Depending on the texture state, this method\n\t * triggers the upload of texture data to the GPU memory. If the texture data are\n\t * not yet ready for the upload, it uses default texture data for as a placeholder.\n\t *\n\t * @param {Texture} texture - The texture to update.\n\t * @param {Object} [options={}] - The options.\n\t */\n\tupdateTexture( texture, options = {} ) {\n\n\t\tconst textureData = this.get( texture );\n\t\tif ( textureData.initialized === true && textureData.version === texture.version ) return;\n\n\t\tconst isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n\t\tconst backend = this.backend;\n\n\t\tif ( isRenderTarget && textureData.initialized === true ) {\n\n\t\t\t// it's an update\n\n\t\t\tbackend.destroySampler( texture );\n\t\t\tbackend.destroyTexture( texture );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tconst renderTarget = this.renderer.getRenderTarget();\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttexture.type = renderTarget.texture.type;\n\n\t\t\t} else {\n\n\t\t\t\ttexture.type = UnsignedByteType;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { width, height, depth } = this.getSize( texture );\n\n\t\toptions.width = width;\n\t\toptions.height = height;\n\t\toptions.depth = depth;\n\t\toptions.needsMipmaps = this.needsMipmaps( texture );\n\t\toptions.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;\n\n\t\t//\n\n\t\tif ( isRenderTarget || texture.isStorageTexture === true ) {\n\n\t\t\tbackend.createSampler( texture );\n\t\t\tbackend.createTexture( texture, options );\n\n\t\t\ttextureData.generation = texture.version;\n\n\t\t} else {\n\n\t\t\tconst needsCreate = textureData.initialized !== true;\n\n\t\t\tif ( needsCreate ) backend.createSampler( texture );\n\n\t\t\tif ( texture.version > 0 ) {\n\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( texture.images ) {\n\n\t\t\t\t\t\tconst images = [];\n\n\t\t\t\t\t\tfor ( const image of texture.images ) {\n\n\t\t\t\t\t\t\timages.push( image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toptions.images = images;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toptions.image = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {\n\n\t\t\t\t\t\tbackend.createTexture( texture, options );\n\n\t\t\t\t\t\ttextureData.isDefaultTexture = false;\n\t\t\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.source.dataReady === true ) backend.updateTexture( texture, options );\n\n\t\t\t\t\tif ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// async update\n\n\t\t\t\tbackend.createDefaultTexture( texture );\n\n\t\t\t\ttextureData.isDefaultTexture = true;\n\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( textureData.initialized !== true ) {\n\n\t\t\ttextureData.initialized = true;\n\t\t\ttextureData.generation = texture.version;\n\n\t\t\t//\n\n\t\t\tthis.info.memory.textures ++;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\ttexture.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis._destroyTexture( texture );\n\n\t\t\t\tthis.info.memory.textures --;\n\n\t\t\t};\n\n\t\t\ttexture.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t}\n\n\t/**\n\t * Computes the size of the given texture and writes the result\n\t * into the target vector. This vector is also returned by the\n\t * method.\n\t *\n\t * If no texture data are available for the compute yet, the method\n\t * returns default size values.\n\t *\n\t * @param {Texture} texture - The texture to compute the size for.\n\t * @param {Vector3} target - The target vector.\n\t * @return {Vector3} The target vector.\n\t */\n\tgetSize( texture, target = _size$3 ) {\n\n\t\tlet image = texture.images ? texture.images[ 0 ] : texture.image;\n\n\t\tif ( image ) {\n\n\t\t\tif ( image.image !== undefined ) image = image.image;\n\n\t\t\ttarget.width = image.width || 1;\n\t\t\ttarget.height = image.height || 1;\n\t\t\ttarget.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );\n\n\t\t} else {\n\n\t\t\ttarget.width = target.height = target.depth = 1;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Computes the number of mipmap levels for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Number} width - The texture's width.\n\t * @param {Number} height - The texture's height.\n\t * @return {Number} The number of mipmap levels.\n\t */\n\tgetMipLevels( texture, width, height ) {\n\n\t\tlet mipLevelCount;\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tif ( texture.mipmaps ) {\n\n\t\t\t\tmipLevelCount = texture.mipmaps.length;\n\n\t\t\t} else {\n\n\t\t\t\tmipLevelCount = 1;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;\n\n\t\t}\n\n\t\treturn mipLevelCount;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture requires mipmaps.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {Boolean} Whether mipmaps are required or not.\n\t */\n\tneedsMipmaps( texture ) {\n\n\t\treturn this.isEnvironmentTexture( texture ) || texture.isCompressedTexture === true || texture.generateMipmaps;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture is an environment map.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {Boolean} Whether the given texture is an environment map or not.\n\t */\n\tisEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t/**\n\t * Frees internal resource when the given texture isn't\n\t * required anymore.\n\t *\n\t * @param {Texture} texture - The texture to destroy.\n\t */\n\t_destroyTexture( texture ) {\n\n\t\tthis.backend.destroySampler( texture );\n\t\tthis.backend.destroyTexture( texture );\n\n\t\tthis.delete( texture );\n\n\t}\n\n}\n\n/**\n * A four-component version of {@link Color} which is internally\n * used by the renderer to represents clear color with alpha as\n * one object.\n *\n * @private\n * @augments Color\n */\nclass Color4 extends Color {\n\n\t/**\n\t * Constructs a new four-component color.\n\t * You can also pass a single THREE.Color, hex or\n\t * string argument to this constructor.\n\t *\n\t * @param {Number|String} [r=1] - The red value.\n\t * @param {Number} [g=1] - The green value.\n\t * @param {Number} [b=1] - The blue value.\n\t * @param {Number} [a=1] - The alpha value.\n\t */\n\tconstructor( r, g, b, a = 1 ) {\n\n\t\tsuper( r, g, b );\n\n\t\tthis.a = a;\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t * You can also pass a single THREE.Color, hex or\n\t * string argument to this method.\n\t *\n\t * @param {Number|String} r - The red value.\n\t * @param {Number} g - The green value.\n\t * @param {Number} b - The blue value.\n\t * @param {Number} [a=1] - The alpha value.\n\t * @return {Color4} A reference to this object.\n\t */\n\tset( r, g, b, a = 1 ) {\n\n\t\tthis.a = a;\n\n\t\treturn super.set( r, g, b );\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t *\n\t * @param {Color4} color - The color to copy.\n\t * @return {Color4} A reference to this object.\n\t */\n\tcopy( color ) {\n\n\t\tif ( color.a !== undefined ) this.a = color.a;\n\n\t\treturn super.copy( color );\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t *\n\t * @return {Color4} The cloned color.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b, this.a );\n\n\t}\n\n}\n\n/** @module ParameterNode **/\n\n/**\n * Special version of {@link PropertyNode} which is used for parameters.\n *\n * @augments PropertyNode\n */\nclass ParameterNode extends PropertyNode {\n\n\tstatic get type() {\n\n\t\treturn 'ParameterNode';\n\n\t}\n\n\t/**\n\t * Constructs a new parameter node.\n\t *\n\t * @param {String} nodeType - The type of the node.\n\t * @param {String?} [name=null] - The name of the parameter in the shader.\n\t */\n\tconstructor( nodeType, name = null ) {\n\n\t\tsuper( nodeType, name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isParameterNode = true;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgenerate() {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a parameter node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} name - The name of the parameter in the shader.\n * @returns {ParameterNode}\n */\nconst parameter = ( type, name ) => nodeObject( new ParameterNode( type, name ) );\n\n/** @module StackNode **/\n\n/**\n * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.\n * They are usually needed in cases like `If`, `Else`.\n *\n * @augments Node\n */\nclass StackNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StackNode';\n\n\t}\n\n\t/**\n\t * Constructs a new stack node.\n\t *\n\t * @param {StackNode?} [parent=null] - The parent stack node.\n\t */\n\tconstructor( parent = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * List of nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = [];\n\n\t\t/**\n\t\t * The output node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.outputNode = null;\n\n\t\t/**\n\t\t * The parent stack node.\n\t\t *\n\t\t * @type {StackNode}\n\t\t * @default null\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * The current conditional node.\n\t\t *\n\t\t * @private\n\t\t * @type {ConditionalNode}\n\t\t * @default null\n\t\t */\n\t\tthis._currentCond = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.outputNode ? this.outputNode.getMemberType( builder, name ) : 'void';\n\n\t}\n\n\t/**\n\t * Adds a node to this stack.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tadd( node ) {\n\n\t\tthis.nodes.push( node );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represent an `if` statement in TSL.\n\t *\n\t * @param {Node} boolNode - Represents the condition.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tthis._currentCond = select( boolNode, methodNode );\n\n\t\treturn this.add( this._currentCond );\n\n\t}\n\n\t/**\n\t * Represent an `elseif` statement in TSL.\n\t *\n\t * @param {Node} boolNode - Represents the condition.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tElseIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tconst ifNode = select( boolNode, methodNode );\n\n\t\tthis._currentCond.elseNode = ifNode;\n\t\tthis._currentCond = ifNode;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represent an `else` statement in TSL.\n\t *\n\t * @param {Function} method - TSL code which is executed in the `else` case.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tElse( method ) {\n\n\t\tthis._currentCond.elseNode = new ShaderNode( method );\n\n\t\treturn this;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousStack = getCurrentStack();\n\n\t\tsetCurrentStack( this );\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tnode.build( builder, 'void' );\n\n\t\t}\n\n\t\tsetCurrentStack( previousStack );\n\n\t\treturn this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );\n\n\t}\n\n\t// Deprecated\n\n\t/**\n\t * @function\n\t * @deprecated since r168. Use {@link StackNode#Else} instead.\n\t *\n\t * @param  {...any} params\n\t * @returns {StackNode}\n\t */\n\telse( ...params ) { // @deprecated, r168\n\n\t\tconsole.warn( 'TSL.StackNode: .else() has been renamed to .Else().' );\n\t\treturn this.Else( ...params );\n\n\t}\n\n\t/**\n\t * @deprecated since r168. Use {@link StackNode#ElseIf} instead.\n\t *\n\t * @param  {...any} params\n\t * @returns {StackNode}\n\t */\n\telseif( ...params ) { // @deprecated, r168\n\n\t\tconsole.warn( 'TSL.StackNode: .elseif() has been renamed to .ElseIf().' );\n\t\treturn this.ElseIf( ...params );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a stack node.\n *\n * @function\n * @param {StackNode?} [parent=null] - The parent stack node.\n * @returns {StackNode}\n */\nconst stack = /*@__PURE__*/ nodeProxy( StackNode );\n\n/** @module StructTypeNode **/\n\n/**\n * Generates a layout for struct members.\n * This function takes an object representing struct members and returns an array of member layouts.\n * Each member layout includes the member's name, type, and whether it is atomic.\n *\n * @param {Object.<string, string|Object>} members - An object where keys are member names and values are either types (as strings) or objects with type and atomic properties.\n * @returns {Array.<{name: string, type: string, atomic: boolean}>} An array of member layouts.\n */\nfunction getMembersLayout( members ) {\n\n\treturn Object.entries( members ).map( ( [ name, value ] ) => {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\treturn { name, type: value, atomic: false };\n\n\t\t}\n\n\t\treturn { name, type: value.type, atomic: value.atomic || false };\n\n\t} );\n\n}\n\n/**\n * Represents a struct type node in the node-based system.\n * This class is used to define and manage the layout and types of struct members.\n * It extends the base Node class and provides methods to get the length of the struct,\n * retrieve member types, and generate the struct type for a builder.\n *\n * @augments Node\n */\nclass StructTypeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StructTypeNode';\n\n\t}\n\n\t/**\n\t * Creates an instance of StructTypeNode.\n\t *\n\t * @param {Object} membersLayout - The layout of the members for the struct.\n\t * @param {string} [name=null] - The optional name of the struct.\n\t */\n\tconstructor( membersLayout, name = null ) {\n\n\t\tsuper( 'struct' );\n\n\t\t/**\n\t\t * The layout of the members for the struct\n\t\t *\n\t\t * @type {Array.<{name: string, type: string, atomic: boolean}>}\n\t\t */\n\t\tthis.membersLayout = getMembersLayout( membersLayout );\n\n\t\t/**\n\t\t * The name of the struct.\n\t\t *\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStructLayoutNode = true;\n\n\t}\n\n\t/**\n\t * Returns the length of the struct.\n\t * The length is calculated by summing the lengths of the struct's members.\n\t *\n\t * @returns {Number} The length of the struct.\n\t */\n\tgetLength() {\n\n\t\tlet length = 0;\n\n\t\tfor ( const member of this.membersLayout ) {\n\n\t\t\tlength += getLengthFromType( member.type );\n\n\t\t}\n\n\t\treturn length;\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\tconst member = this.membersLayout.find( m => m.name === name );\n\n\t\treturn member ? member.type : 'void';\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst structType = builder.getStructTypeFromNode( this, this.membersLayout, this.name );\n\n\t\treturn structType.name;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n}\n\n/** @module StructNode **/\n\n/**\n * StructNode allows to create custom structures with multiple members.\n * This can also be used to define structures in attribute and uniform data.\n *\n * ```js\n * // Define a custom struct\n * const BoundingBox = struct( { min: 'vec3', max: 'vec3' } );\n *\n * // Create a new instance of the struct\n * const bb = BoundingBox( vec3( 0 ), vec3( 1 ) ); // style 1\n * const bb = BoundingBox( { min: vec3( 0 ), max: vec3( 1 ) } ); // style 2\n *\n * // Access the struct members\n * const min = bb.get( 'min' );\n *\n * // Assign a new value to a member\n * min.assign( vec3() );\n * ```\n * @augments Node\n */\nclass StructNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StructNode';\n\n\t}\n\n\tconstructor( structLayoutNode, values ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.structLayoutNode = structLayoutNode;\n\t\tthis.values = values;\n\n\t\tthis.isStructNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.structLayoutNode.getNodeType( builder );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.structLayoutNode.getMemberType( builder, name );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeVar = builder.getVarFromNode( this );\n\t\tconst structType = nodeVar.type;\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tbuilder.addLineFlowCode( `${ propertyName } = ${ builder.generateStruct( structType, this.structLayoutNode.membersLayout, this.values ) }`, this );\n\n\t\treturn nodeVar.name;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a struct node.\n *\n * @function\n * @param {Object} membersLayout - The layout of the struct members.\n * @param {string} [name=null] - The name of the struct.\n * @returns {Function} The struct function.\n */\nconst struct = ( membersLayout, name = null ) => {\n\n\tconst structLayout = new StructTypeNode( membersLayout, name );\n\n\tconst struct = ( ...params ) => {\n\n\t\tlet values = null;\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tif ( params[ 0 ].isNode ) {\n\n\t\t\t\tvalues = {};\n\n\t\t\t\tconst names = Object.keys( membersLayout );\n\n\t\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\tvalues[ names[ i ] ] = params[ i ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvalues = params[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeObject( new StructNode( structLayout, values ) );\n\n\t};\n\n\tstruct.layout = structLayout;\n\tstruct.isStruct = true;\n\n\treturn struct;\n\n};\n\n/** @module OutputStructNode **/\n\n/**\n * This node can be used to define multiple outputs in a shader programs.\n *\n * @augments Node\n */\nclass OutputStructNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'OutputStructNode';\n\n\t}\n\n\t/**\n\t * Constructs a new output struct node. The constructor can be invoked with an\n\t * arbitrary number of nodes representing the members.\n\t *\n\t * @param {...Node} members - A parameter list of nodes.\n\t */\n\tconstructor( ...members ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * An array of nodes which defines the output.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.members = members;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputStructNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.membersLayout === undefined ) {\n\n\t\t\tconst members = this.members;\n\t\t\tconst membersLayout = [];\n\n\t\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\t\tconst name = 'm' + i;\n\t\t\t\tconst type = members[ i ].getNodeType( builder );\n\n\t\t\t\tmembersLayout.push( { name, type, index: i } );\n\n\t\t\t}\n\n\t\t\tproperties.membersLayout = membersLayout;\n\t\t\tproperties.structType = builder.getOutputStructTypeFromNode( this, properties.membersLayout );\n\n\t\t}\n\n\t\treturn properties.structType.name;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst propertyName = builder.getOutputStructName();\n\t\tconst members = this.members;\n\n\t\tconst structPrefix = propertyName !== '' ? propertyName + '.' : '';\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst snippet = members[ i ].build( builder );\n\n\t\t\tbuilder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an output struct node.\n *\n * @function\n * @param {...Node} members - A parameter list of nodes.\n * @returns {OutputStructNode}\n */\nconst outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );\n\n/** @module MRTNode **/\n\n/**\n * Returns the MRT texture index for the given name.\n *\n * @param {Array<Texture>} textures - The textures of a MRT-configured render target.\n * @param {String} name - The name of the MRT texture which index is requested.\n * @return {Number} The texture index.\n */\nfunction getTextureIndex( textures, name ) {\n\n\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\tif ( textures[ i ].name === name ) {\n\n\t\t\treturn i;\n\n\t\t}\n\n\t}\n\n\treturn - 1;\n\n}\n\n/**\n * This node can be used setup a MRT context for rendering. A typical MRT setup for\n * post-processing is shown below:\n * ```js\n * const mrtNode = mrt( {\n *   output: output,\n *   normal: normalView\n * } ) );\n * ```\n * The MRT output is defined as a dictionary.\n *\n * @augments OutputStructNode\n */\nclass MRTNode extends OutputStructNode {\n\n\tstatic get type() {\n\n\t\treturn 'MRTNode';\n\n\t}\n\n\t/**\n\t * Constructs a new output struct node.\n\t *\n\t * @param {Object<String, Node>} outputNodes - The MRT outputs.\n\t */\n\tconstructor( outputNodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A dictionary representing the MRT outputs. The key\n\t\t * is the name of the output, the value the node which produces\n\t\t * the output result.\n\t\t *\n\t\t * @type {Object<String, Node>}\n\t\t */\n\t\tthis.outputNodes = outputNodes;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMRTNode = true;\n\n\t}\n\n\t/**\n\t * Returns `true` if the MRT node has an output with the given name.\n\t *\n\t * @param {String} name - The name of the output.\n\t * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.\n\t */\n\thas( name ) {\n\n\t\treturn this.outputNodes[ name ] !== undefined;\n\n\t}\n\n\t/**\n\t * Returns the output node for the given name.\n\t *\n\t * @param {String} name - The name of the output.\n\t * @return {Node} The output node.\n\t */\n\tget( name ) {\n\n\t\treturn this.outputNodes[ name ];\n\n\t}\n\n\t/**\n\t * Merges the outputs of the given MRT node with the outputs of this node.\n\t *\n\t * @param {MRTNode} mrtNode - The MRT to merge.\n\t * @return {MRTNode} A new MRT node with merged outputs..\n\t */\n\tmerge( mrtNode ) {\n\n\t\tconst outputs = { ...this.outputNodes, ...mrtNode.outputNodes };\n\n\t\treturn mrt( outputs );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst outputNodes = this.outputNodes;\n\t\tconst mrt = builder.renderer.getRenderTarget();\n\n\t\tconst members = [];\n\n\t\tconst textures = mrt.textures;\n\n\t\tfor ( const name in outputNodes ) {\n\n\t\t\tconst index = getTextureIndex( textures, name );\n\n\t\t\tmembers[ index ] = vec4( outputNodes[ name ] );\n\n\t\t}\n\n\t\tthis.members = members;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a MRT node.\n *\n * @function\n * @param {Object<String, Node>} outputNodes - The MRT outputs.\n * @returns {MRTNode}\n */\nconst mrt = /*@__PURE__*/ nodeProxy( MRTNode );\n\n/** @module Hash **/\n\n/**\n * Generates a hash value in the range `[0, 1]` from the given seed.\n *\n * @method\n * @param {Node<float>} seed - The seed.\n * @return {Node<float>} The hash value.\n */\nconst hash = /*@__PURE__*/ Fn( ( [ seed ] ) => {\n\n\t// Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org\n\n\tconst state = seed.toUint().mul( 747796405 ).add( 2891336453 );\n\tconst word = state.shiftRight( state.shiftRight( 28 ).add( 4 ) ).bitXor( state ).mul( 277803737 );\n\tconst result = word.shiftRight( 22 ).bitXor( word );\n\n\treturn result.toFloat().mul( 1 / 2 ** 32 ); // Convert to range [0, 1)\n\n} );\n\n/** @module MathUtils **/\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * The corners are mapped to `0` and the center to `1`.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} k - Allows to control the remapping functions shape by rising the parabola to a power `k`.\n * @return {Node<float>} The remapped value.\n */\nconst parabola = ( x, k ) => pow( mul( 4.0, x.mul( sub( 1.0, x ) ) ), k );\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} k - `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces \"s\" shaped curves.\n * @return {Node<float>} The remapped value.\n */\nconst gain = ( x, k ) => x.lessThan( 0.5 ) ? parabola( x.mul( 2.0 ), k ).div( 2.0 ) : sub( 1.0, parabola( mul( sub( 1.0, x ), 2.0 ), k ).div( 2.0 ) );\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} a - First control parameter.\n * @param {Node<float>} b - Second control parameter.\n * @return {Node<float>} The remapped value.\n */\nconst pcurve = ( x, a, b ) => pow( div( pow( x, a ), add( pow( x, a ), pow( sub( 1.0, x ), b ) ) ), 1.0 / a );\n\n/**\n * A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to compute the sin for.\n * @param {Node<float>} k - Controls the amount of bounces.\n * @return {Node<float>} The result value.\n */\nconst sinc = ( x, k ) => sin( PI.mul( k.mul( x ).sub( 1.0 ) ) ).div( PI.mul( k.mul( x ).sub( 1.0 ) ) );\n\n// https://github.com/cabbibo/glsl-tri-noise-3d\n\n\n/** @module TriNoise3D **/\n\nconst tri = /*@__PURE__*/ Fn( ( [ x ] ) => {\n\n\treturn x.fract().sub( .5 ).abs();\n\n} ).setLayout( {\n\tname: 'tri',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst tri3 = /*@__PURE__*/ Fn( ( [ p ] ) => {\n\n\treturn vec3( tri( p.z.add( tri( p.y.mul( 1. ) ) ) ), tri( p.z.add( tri( p.x.mul( 1. ) ) ) ), tri( p.y.add( tri( p.x.mul( 1. ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'tri3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\n/**\n * Generates a noise value from the given position, speed and time parameters.\n *\n * @method\n * @param {Node<vec3>} position - The position.\n * @param {Node<float>} speed - The speed.\n * @param {Node<float>} time - The time.\n * @return {Node<float>} The generated noise.\n */\nconst triNoise3D = /*@__PURE__*/ Fn( ( [ position, speed, time ] ) => {\n\n\tconst p = vec3( position ).toVar();\n\tconst z = float( 1.4 ).toVar();\n\tconst rz = float( 0.0 ).toVar();\n\tconst bp = vec3( p ).toVar();\n\n\tLoop( { start: float( 0.0 ), end: float( 3.0 ), type: 'float', condition: '<=' }, () => {\n\n\t\tconst dg = vec3( tri3( bp.mul( 2.0 ) ) ).toVar();\n\t\tp.addAssign( dg.add( time.mul( float( 0.1 ).mul( speed ) ) ) );\n\t\tbp.mulAssign( 1.8 );\n\t\tz.mulAssign( 1.5 );\n\t\tp.mulAssign( 1.2 );\n\n\t\tconst t = float( tri( p.z.add( tri( p.x.add( tri( p.y ) ) ) ) ) ).toVar();\n\t\trz.addAssign( t.div( z ) );\n\t\tbp.addAssign( 0.14 );\n\n\t} );\n\n\treturn rz;\n\n} ).setLayout( {\n\tname: 'triNoise3D',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec3' },\n\t\t{ name: 'speed', type: 'float' },\n\t\t{ name: 'time', type: 'float' }\n\t]\n} );\n\n/** @module FunctionOverloadingNode **/\n\n/**\n * This class allows to define multiple overloaded versions\n * of the same function. Depending on the parameters of the function\n * call, the node picks the best-fit overloaded version.\n *\n * @augments Node\n */\nclass FunctionOverloadingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionOverloadingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function overloading node.\n\t *\n\t * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.\n\t * @param {...Node} parametersNodes - A list of parameter nodes.\n\t */\n\tconstructor( functionNodes = [], ...parametersNodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Array of `Fn` function definitions.\n\t\t *\n\t\t * @type {Array<Function>}\n\t\t */\n\t\tthis.functionNodes = functionNodes;\n\n\t\t/**\n\t\t * A list of parameter nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.parametersNodes = parametersNodes;\n\n\t\t/**\n\t\t * The selected overloaded function call.\n\t\t *\n\t\t * @private\n\t\t * @type {ShaderCallNodeInternal}\n\t\t */\n\t\tthis._candidateFnCall = null;\n\n\t\t/**\n\t\t * This node is marked as global.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the function's return type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.functionNodes[ 0 ].shaderNode.layout.type;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst params = this.parametersNodes;\n\n\t\tlet candidateFnCall = this._candidateFnCall;\n\n\t\tif ( candidateFnCall === null ) {\n\n\t\t\tlet candidateFn = null;\n\t\t\tlet candidateScore = - 1;\n\n\t\t\tfor ( const functionNode of this.functionNodes ) {\n\n\t\t\t\tconst shaderNode = functionNode.shaderNode;\n\t\t\t\tconst layout = shaderNode.layout;\n\n\t\t\t\tif ( layout === null ) {\n\n\t\t\t\t\tthrow new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst inputs = layout.inputs;\n\n\t\t\t\tif ( params.length === inputs.length ) {\n\n\t\t\t\t\tlet score = 0;\n\n\t\t\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\t\tconst param = params[ i ];\n\t\t\t\t\t\tconst input = inputs[ i ];\n\n\t\t\t\t\t\tif ( param.getNodeType( builder ) === input.type ) {\n\n\t\t\t\t\t\t\tscore ++;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscore = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( score > candidateScore ) {\n\n\t\t\t\t\t\tcandidateFn = functionNode;\n\t\t\t\t\t\tcandidateScore = score;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._candidateFnCall = candidateFnCall = candidateFn( ...params );\n\n\t\t}\n\n\t\treturn candidateFnCall;\n\n\t}\n\n}\n\nconst overloadingBaseFn = /*@__PURE__*/ nodeProxy( FunctionOverloadingNode );\n\n/**\n * TSL function for creating a function overloading node.\n *\n * @function\n * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.\n * @returns {FunctionOverloadingNode}\n */\nconst overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );\n\n/** @module Timer **/\n\n/**\n * Represents the elapsed time in seconds.\n *\n * @type {UniformNode<float>}\n */\nconst time = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.time );\n\n/**\n * Represents the delta time in seconds.\n *\n * @type {UniformNode<float>}\n */\nconst deltaTime = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.deltaTime );\n\n/**\n * Represents the current frame ID.\n *\n * @type {UniformNode<uint>}\n */\nconst frameId = /*@__PURE__*/ uniform( 0, 'uint' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.frameId );\n\n// Deprecated\n\n/**\n * @function\n * @deprecated since r170. Use {@link time} instead.\n *\n * @param {Number} [timeScale=1] - The time scale.\n * @returns {UniformNode<float>}\n */\nconst timerLocal = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerLocal() is deprecated. Use \"time\" instead.' );\n\treturn time.mul( timeScale );\n\n};\n\n/**\n * @function\n * @deprecated since r170. Use {@link time} instead.\n *\n * @param {Number} [timeScale=1] - The time scale.\n * @returns {UniformNode<float>}\n */\nconst timerGlobal = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerGlobal() is deprecated. Use \"time\" instead.' );\n\treturn time.mul( timeScale );\n\n};\n\n/**\n * @function\n * @deprecated since r170. Use {@link deltaTime} instead.\n *\n * @param {Number} [timeScale=1] - The time scale.\n * @returns {UniformNode<float>}\n */\nconst timerDelta = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerDelta() is deprecated. Use \"deltaTime\" instead.' );\n\treturn deltaTime.mul( timeScale );\n\n};\n\n/** @module Oscillators **/\n\n/**\n * Generates a sine wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSine = ( t = time ) => t.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );\n\n/**\n * Generates a square wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSquare = ( t = time ) => t.fract().round();\n\n/**\n * Generates a triangle wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscTriangle = ( t = time ) => t.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();\n\n/**\n * Generates a sawtooth wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSawtooth = ( t = time ) => t.fract();\n\n/** @module UVUtils **/\n\n/**\n * Rotates the given uv coordinates around a center point\n *\n * @method\n * @param {Node<vec2>} uv - The uv coordinates.\n * @param {Node<float>} rotation - The rotation defined in radians.\n * @param {Node<vec2>} center - The center of rotation\n * @return {Node<vec2>} The rotated uv coordinates.\n */\nconst rotateUV = /*@__PURE__*/ Fn( ( [ uv, rotation, center = vec2( 0.5 ) ] ) => {\n\n\treturn rotate( uv.sub( center ), rotation ).add( center );\n\n} );\n\n/**\n * Applies a spherical warping effect to the given uv coordinates.\n *\n * @method\n * @param {Node<vec2>} uv - The uv coordinates.\n * @param {Node<float>} strength - The strength of the effect.\n * @param {Node<vec2>} center - The center point\n * @return {Node<vec2>} The updated uv coordinates.\n */\nconst spherizeUV = /*@__PURE__*/ Fn( ( [ uv, strength, center = vec2( 0.5 ) ] ) => {\n\n\tconst delta = uv.sub( center );\n\tconst delta2 = delta.dot( delta );\n\tconst delta4 = delta2.mul( delta2 );\n\tconst deltaOffset = delta4.mul( strength );\n\n\treturn uv.add( delta.mul( deltaOffset ) );\n\n} );\n\n/** @module SpriteUtils **/\n\n/**\n * This can be used to achieve a billboarding behavior for flat meshes. That means they are\n * oriented always towards the camera.\n *\n * ```js\n * material.vertexNode = billboarding();\n * ```\n *\n * @method\n * @param {Object} config - The configuration object.\n * @param {Node<vec3>?} [config.position=null] - Can be used to define the vertex positions in world space.\n * @param {Boolean} [config.horizontal=true] - Whether to follow the camera rotation horizontally or not.\n * @param {Boolean} [config.vertical=false] - Whether to follow the camera rotation vertically or not.\n * @return {Node<vec3>} The updated vertex position in clip space.\n */\nconst billboarding = /*@__PURE__*/ Fn( ( { position = null, horizontal = true, vertical = false } ) => {\n\n\tlet worldMatrix;\n\n\tif ( position !== null ) {\n\n\t\tworldMatrix = modelWorldMatrix.toVar();\n\t\tworldMatrix[ 3 ][ 0 ] = position.x;\n\t\tworldMatrix[ 3 ][ 1 ] = position.y;\n\t\tworldMatrix[ 3 ][ 2 ] = position.z;\n\n\t} else {\n\n\t\tworldMatrix = modelWorldMatrix;\n\n\t}\n\n\tconst modelViewMatrix = cameraViewMatrix.mul( worldMatrix );\n\n\tif ( defined( horizontal ) ) {\n\n\t\tmodelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();\n\t\tmodelViewMatrix[ 0 ][ 1 ] = 0;\n\t\tmodelViewMatrix[ 0 ][ 2 ] = 0;\n\n\t}\n\n\tif ( defined( vertical ) ) {\n\n\t\tmodelViewMatrix[ 1 ][ 0 ] = 0;\n\t\tmodelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();\n\t\tmodelViewMatrix[ 1 ][ 2 ] = 0;\n\n\t}\n\n\tmodelViewMatrix[ 2 ][ 0 ] = 0;\n\tmodelViewMatrix[ 2 ][ 1 ] = 0;\n\tmodelViewMatrix[ 2 ][ 2 ] = 1;\n\n\treturn cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\n} );\n\n/** @module ViewportUtils **/\n\n/**\n * A special version of a screen uv function that involves a depth comparison\n * when computing the final uvs. The function mitigates visual errors when\n * using viewport texture nodes for refraction purposes. Without this function\n * objects in front of a refractive surface might appear on the refractive surface\n * which is incorrect.\n *\n * @method\n * @param {Node<vec2>?} uv - Optional uv coordinates. By default `screenUV` is used.\n * @return {Node<vec2>} The update uv coordinates.\n */\nconst viewportSafeUV = /*@__PURE__*/ Fn( ( [ uv = null ] ) => {\n\n\tconst depth = linearDepth();\n\tconst depthDiff = linearDepth( viewportDepthTexture( uv ) ).sub( depth );\n\tconst finalUV = depthDiff.lessThan( 0 ).select( screenUV, uv );\n\n\treturn finalUV;\n\n} );\n\n/** @module SpriteSheetUVNode **/\n\n/**\n * Can be used to compute texture coordinates for animated sprite sheets.\n *\n * ```js\n * const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );\n *\n * material.colorNode = texture( spriteSheet, uvNode );\n * ```\n *\n * @augments Node\n */\nclass SpriteSheetUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteSheetUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new sprite sheet uv node.\n\t *\n\t * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).\n\t * @param {Node<vec2>} [uvNode=uv()] - The uv node.\n\t * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.\n\t */\n\tconstructor( countNode, uvNode = uv(), frameNode = float( 0 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * The node that defines the number of sprites in the x and y direction (e.g 6x6).\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.countNode = countNode;\n\n\t\t/**\n\t\t * The uv node.\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t * The node that defines the current frame/sprite.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.frameNode = frameNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { frameNode, uvNode, countNode } = this;\n\n\t\tconst { width, height } = countNode;\n\n\t\tconst frameNum = frameNode.mod( width.mul( height ) ).floor();\n\n\t\tconst column = frameNum.mod( width );\n\t\tconst row = height.sub( frameNum.add( 1 ).div( width ).ceil() );\n\n\t\tconst scale = countNode.reciprocal();\n\t\tconst uvFrameOffset = vec2( column, row );\n\n\t\treturn uvNode.add( uvFrameOffset ).mul( scale );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a sprite sheet uv node.\n *\n * @function\n * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).\n * @param {Node<vec2>} [uvNode=uv()] - The uv node.\n * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.\n * @returns {SpriteSheetUVNode}\n */\nconst spritesheetUV = /*@__PURE__*/ nodeProxy( SpriteSheetUVNode );\n\n/** @module TriplanarTexturesNode **/\n\n/**\n * Can be used for triplanar texture mapping.\n *\n * ```js\n * material.colorNode = triplanarTexture( texture( diffuseMap ) );\n * ```\n *\n * @augments Node\n */\nclass TriplanarTexturesNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TriplanarTexturesNode';\n\n\t}\n\n\t/**\n\t * Constructs a new triplanar textures node.\n\t *\n\t * @param {Node} textureXNode - First texture node.\n\t * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n\t * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n\t * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n\t * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n\t * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n\t */\n\tconstructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionLocal, normalNode = normalLocal ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * First texture node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.textureXNode = textureXNode;\n\n\t\t/**\n\t\t * Second texture node. When not set, the shader will sample from `textureXNode` instead.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.textureYNode = textureYNode;\n\n\t\t/**\n\t\t * Third texture node. When not set, the shader will sample from `textureXNode` instead.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.textureZNode = textureZNode;\n\n\t\t/**\n\t\t * The scale node.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t * @default float(1)\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t\t/**\n\t\t * Vertex positions in local space.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t * @default positionLocal\n\t\t */\n\t\tthis.positionNode = positionNode;\n\n\t\t/**\n\t\t * Normals in local space.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t * @default normalLocal\n\t\t */\n\t\tthis.normalNode = normalNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;\n\n\t\t// Ref: https://github.com/keijiro/StandardTriplanar\n\n\t\t// Blending factor of triplanar mapping\n\t\tlet bf = normalNode.abs().normalize();\n\t\tbf = bf.div( bf.dot( vec3( 1.0 ) ) );\n\n\t\t// Triplanar mapping\n\t\tconst tx = positionNode.yz.mul( scaleNode );\n\t\tconst ty = positionNode.zx.mul( scaleNode );\n\t\tconst tz = positionNode.xy.mul( scaleNode );\n\n\t\t// Base color\n\t\tconst textureX = textureXNode.value;\n\t\tconst textureY = textureYNode !== null ? textureYNode.value : textureX;\n\t\tconst textureZ = textureZNode !== null ? textureZNode.value : textureX;\n\n\t\tconst cx = texture( textureX, tx ).mul( bf.x );\n\t\tconst cy = texture( textureY, ty ).mul( bf.y );\n\t\tconst cz = texture( textureZ, tz ).mul( bf.z );\n\n\t\treturn add( cx, cy, cz );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n * @returns {TriplanarTexturesNode}\n */\nconst triplanarTextures = /*@__PURE__*/ nodeProxy( TriplanarTexturesNode );\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n * @returns {TriplanarTexturesNode}\n */\nconst triplanarTexture = ( ...params ) => triplanarTextures( ...params );\n\n/** @module ReflectorNode **/\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, - 1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size$2 = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n\n_defaultRT.depthTexture = new DepthTexture( 1, 1 );\n\nlet _inReflector = false;\n\n/**\n * This node can be used to implement mirror-like flat reflective surfaces.\n *\n * ```js\n * const groundReflector = reflector();\n * material.colorNode = groundReflector;\n *\n * const plane = new Mesh( geometry, material );\n * plane.add( groundReflector.target );\n * ```\n *\n * @augments module:TextureNode~TextureNode\n */\nclass ReflectorNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reflector node.\n\t *\n\t * @param {Object} [parameters={}] - An object holding configuration parameters.\n\t * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n\t * @param {Number} [parameters.resolution=1] - The resolution scale.\n\t * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n\t * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n\t * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n\t * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n\t * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters.defaultTexture || _defaultRT.texture, _defaultUV );\n\n\t\t/**\n\t\t * A reference to the internal reflector base node which holds the actual implementation.\n\t\t *\n\t\t * @private\n\t\t * @type {ReflectorBaseNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );\n\n\t\t/**\n\t\t * A reference to the internal depth node.\n\t\t *\n\t\t * @private\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis._depthNode = null;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\t/**\n\t * A reference to the internal reflector node.\n\t *\n\t * @type {ReflectorBaseNode}\n\t */\n\tget reflector() {\n\n\t\treturn this._reflectorBaseNode;\n\n\t}\n\n\t/**\n\t * A reference to 3D object the reflector is linked to.\n\t *\n\t * @type {Object3D}\n\t */\n\tget target() {\n\n\t\treturn this._reflectorBaseNode.target;\n\n\t}\n\n\t/**\n\t * Returns a node representing the mirror's depth. That can be used\n\t * to implement more advanced reflection effects like distance attenuation.\n\t *\n\t * @return {Node} The depth node.\n\t */\n\tgetDepthNode() {\n\n\t\tif ( this._depthNode === null ) {\n\n\t\t\tif ( this._reflectorBaseNode.depth !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );\n\n\t\t\t}\n\n\t\t\tthis._depthNode = nodeObject( new ReflectorNode( {\n\t\t\t\tdefaultTexture: _defaultRT.depthTexture,\n\t\t\t\treflector: this._reflectorBaseNode\n\t\t\t} ) );\n\n\t\t}\n\n\t\treturn this._depthNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// ignore if used in post-processing\n\t\tif ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\tconst texture = new this.constructor( this.reflectorNode );\n\t\ttexture._reflectorBaseNode = this._reflectorBaseNode;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Holds the actual implementation of the reflector.\n *\n * TODO: Explain why `ReflectorBaseNode`. Originally the entire logic was implemented\n * in `ReflectorNode`, see #29619.\n *\n * @private\n * @augments Node\n */\nclass ReflectorBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reflector base node.\n\t *\n\t * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.\n\t * @param {Object} [parameters={}] - An object holding configuration parameters.\n\t * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n\t * @param {Number} [parameters.resolution=1] - The resolution scale.\n\t * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n\t * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n\t * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n\t */\n\tconstructor( textureNode, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolution = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true,\n\t\t\tdepth = false\n\t\t} = parameters;\n\n\t\t/**\n\t\t * Represents the rendered reflections as a texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The 3D object the reflector is linked to.\n\t\t *\n\t\t * @type {Object3D}\n\t\t * @default {new Object3D()}\n\t\t */\n\t\tthis.target = target;\n\n\t\t/**\n\t\t * The resolution scale.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default {1}\n\t\t */\n\t\tthis.resolution = resolution;\n\n\t\t/**\n\t\t * Whether mipmaps should be generated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.generateMipmaps = generateMipmaps;\n\n\t\t/**\n\t\t * Whether reflectors can render other reflector nodes or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default {true}\n\t\t */\n\t\tthis.bounces = bounces;\n\n\t\t/**\n\t\t * Whether depth data should be generated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.depth = depth;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` when {@link ReflectorBaseNode#bounces}\n\t\t * is `true`. Otherwise it's `NodeUpdateType.FRAME`.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * Weak map for managing virtual cameras.\n\t\t *\n\t\t * @type {WeakMap<Camera, Camera>}\n\t\t */\n\t\tthis.virtualCameras = new WeakMap();\n\n\t\t/**\n\t\t * Weak map for managing render targets.\n\t\t *\n\t\t * @type {WeakMap<Camera, RenderTarget>}\n\t\t */\n\t\tthis.renderTargets = new WeakMap();\n\n\t}\n\n\t/**\n\t * Updates the resolution of the internal render target.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The render target to resize.\n\t * @param {Renderer} renderer - The renderer that is used to determine the new size.\n\t */\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolution;\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\trenderTarget.setSize( Math.round( _size$2.width * resolution ), Math.round( _size$2.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Returns a virtual camera for the given camera. The virtual camera is used to\n\t * render the scene from the reflector's view so correct reflections can be produced.\n\t *\n\t * @param {Camera} camera - The scene's camera.\n\t * @return {Camera} The corresponding virtual camera.\n\t */\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\t/**\n\t * Returns a render target for the given camera. The reflections are rendered\n\t * into this render target.\n\t *\n\t * @param {Camera} camera - The scene's camera.\n\t * @return {RenderTarget} The render target.\n\t */\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t\trenderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t\trenderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tif ( this.depth === true ) {\n\n\t\t\t\trenderTarget.depthTexture = new DepthTexture();\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return false;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( _view.dot( _normal ) > 0 ) return;\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, - 1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = - 1.0;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.textureNode.value = renderTarget.texture;\n\n\t\tif ( this.depth === true ) {\n\n\t\t\tthis.textureNode.getDepthNode().value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst currentAutoClear = renderer.autoClear;\n\n\t\trenderer.setMRT( null );\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.setMRT( currentMRT );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reflector node.\n *\n * @function\n * @param {Object} [parameters={}] - An object holding configuration parameters.\n * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n * @param {Number} [parameters.resolution=1] - The resolution scale.\n * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n * @returns {ReflectorNode}\n */\nconst reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\nconst _camera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n/**\n * The purpose of this special geometry is to fill the entire viewport with a single triangle.\n *\n * Reference: {@link https://github.com/mrdoob/three.js/pull/21358}\n *\n * @private\n * @augments BufferGeometry\n */\nclass QuadGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new quad geometry.\n\t *\n\t * @param {Boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.\n\t */\n\tconstructor( flipY = false ) {\n\n\t\tsuper();\n\n\t\tconst uv = flipY === false ? [ 0, - 1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\n\n\t}\n\n}\n\nconst _geometry = /*@__PURE__*/ new QuadGeometry();\n\n\n/**\n * This module is a helper for passes which need to render a full\n * screen effect which is quite common in context of post processing.\n *\n * The intended usage is to reuse a single quad mesh for rendering\n * subsequent passes by just reassigning the `material` reference.\n *\n * @augments Mesh\n */\nclass QuadMesh extends Mesh {\n\n\t/**\n\t * Constructs a new quad mesh.\n\t *\n\t * @param {Material?} [material=null] - The material to render the quad mesh with.\n\t */\n\tconstructor( material = null ) {\n\n\t\tsuper( _geometry, material );\n\n\t\t/**\n\t\t * The camera to render the quad mesh with.\n\t\t *\n\t\t * @type {OrthographicCamera}\n\t\t * @readonly\n\t\t */\n\t\tthis.camera = _camera;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isQuadMesh = true;\n\n\t}\n\n\t/**\n\t * Async version of `render()`.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync( renderer ) {\n\n\t\treturn renderer.renderAsync( this, _camera );\n\n\t}\n\n\t/**\n\t * Renders the quad mesh\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\trender( renderer ) {\n\n\t\trenderer.render( this, _camera );\n\n\t}\n\n}\n\n/** @module RTTNode **/\n\nconst _size$1 = /*@__PURE__*/ new Vector2();\n\n/**\n * `RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).\n * This module is especially relevant in context of post processing where certain nodes require\n * texture input for their effects. With the helper function `convertToTexture()` which is based\n * on this module, the node system can automatically ensure texture input if required.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass RTTNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'RTTNode';\n\n\t}\n\n\t/**\n\t * Constructs a new RTT node.\n\t *\n\t * @param {Node} node - The node to render a texture with.\n\t * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n\t * @param {Number?} [height=null] - The height of the internal render target.\n\t * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n\t */\n\tconstructor( node, width = null, height = null, options = { type: HalfFloatType } ) {\n\n\t\tconst renderTarget = new RenderTarget( width, height, options );\n\n\t\tsuper( renderTarget.texture, uv() );\n\n\t\t/**\n\t\t * The node to render a texture with.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The width of the internal render target.\n\t\t * If not width is applied, the render target is automatically resized.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.width = width;\n\n\t\t/**\n\t\t * The height of the internal render target.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.height = height;\n\n\t\t/**\n\t\t * The pixel ratio\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.pixelRatio = 1;\n\n\t\t/**\n\t\t * The render target\n\t\t *\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * Whether the texture requires an update or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.textureNeedsUpdate = true;\n\n\t\t/**\n\t\t * Whether the texture should automatically be updated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoUpdate = true;\n\n\t\t/**\n\t\t * The node which is used with the quad mesh for RTT.\n\t\t *\n\t\t * @private\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis._rttNode = null;\n\n\t\t/**\n\t\t * The internal quad mesh for RTT.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quadMesh = new QuadMesh( new NodeMaterial() );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n\t\t * the texture once per render in its {@link RTTNode#updateBefore} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\t/**\n\t * Whether the internal render target should automatically be resized or not.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t * @default true\n\t */\n\tget autoSize() {\n\n\t\treturn this.width === null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._rttNode = this.node.context( builder.getSharedContext() );\n\t\tthis._quadMesh.material.name = 'RTT';\n\t\tthis._quadMesh.material.needsUpdate = true;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Sets the size of the internal render target\n\t *\n\t * @param {Number} width - The width to set.\n\t * @param {Number} height - The width to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tconst effectiveWidth = width * this.pixelRatio;\n\t\tconst effectiveHeight = height * this.pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\tthis.textureNeedsUpdate = true;\n\n\t}\n\n\t/**\n\t * Sets the pixel ratio. This will also resize the render target.\n\t *\n\t * @param {Number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis.pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this.width, this.height );\n\n\t}\n\n\tupdateBefore( { renderer } ) {\n\n\t\tif ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;\n\n\t\tthis.textureNeedsUpdate = false;\n\n\t\t//\n\n\t\tif ( this.autoSize === true ) {\n\n\t\t\tthis.pixelRatio = renderer.getPixelRatio();\n\n\t\t\tconst size = renderer.getSize( _size$1 );\n\n\t\t\tthis.setSize( size.width, size.height );\n\n\t\t}\n\n\t\t//\n\n\t\tthis._quadMesh.material.fragmentNode = this._rttNode;\n\n\t\t//\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\n\t\tthis._quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new TextureNode( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.referenceNode = this;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a RTT node.\n *\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {Number?} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nconst rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );\n\n/**\n * TSL function for converting nodes to textures nodes.\n *\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {Number?} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nconst convertToTexture = ( node, ...params ) => {\n\n\tif ( node.isTextureNode ) return node;\n\tif ( node.isPassNode ) return node.getTextureNode();\n\n\treturn rtt( node, ...params );\n\n};\n\n/** @module PostProcessingUtils **/\n\n/**\n * Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n * depth value and the camera's inverse projection matrix.\n *\n * @method\n * @param {Node<vec2>} screenPosition - The fragment's screen position expressed as uv coordinates.\n * @param {Node<float>} depth - The fragment's depth value.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The fragments position in view space.\n */\nconst getViewPosition = /*@__PURE__*/ Fn( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {\n\n\tlet clipSpacePosition;\n\n\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\tscreenPosition = vec2( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );\n\t\tclipSpacePosition = vec4( vec3( screenPosition, depth ), 1.0 );\n\n\t} else {\n\n\t\tclipSpacePosition = vec4( vec3( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );\n\n\t}\n\n\tconst viewSpacePosition = vec4( projectionMatrixInverse.mul( clipSpacePosition ) );\n\n\treturn viewSpacePosition.xyz.div( viewSpacePosition.w );\n\n} );\n\n/**\n * Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n * and the camera's projection matrix\n *\n * @method\n * @param {Node<vec3>} viewPosition - The fragments position in view space.\n * @param {Node<mat4>} projectionMatrix - The camera's projection matrix.\n * @return {Node<vec2>} The fragment's screen position expressed as uv coordinates.\n */\nconst getScreenPosition = /*@__PURE__*/ Fn( ( [ viewPosition, projectionMatrix ] ) => {\n\n\tconst sampleClipPos = projectionMatrix.mul( vec4( viewPosition, 1.0 ) );\n\tconst sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();\n\treturn vec2( sampleUv.x, sampleUv.y.oneMinus() );\n\n} );\n\n/**\n * Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n * target is available or if flat surface normals are required.\n *\n * @method\n * @param {Node<vec2>} uv - The texture coordinate.\n * @param {DepthTexture} depthTexture - The depth texture.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The computed normal vector.\n */\nconst getNormalFromDepth = /*@__PURE__*/ Fn( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {\n\n\tconst size = textureSize( textureLoad( depthTexture ) );\n\tconst p = ivec2( uv.mul( size ) ).toVar();\n\n\tconst c0 = textureLoad( depthTexture, p ).toVar();\n\n\tconst l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();\n\tconst l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();\n\tconst r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();\n\tconst r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();\n\tconst b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();\n\tconst b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();\n\tconst t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();\n\tconst t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();\n\n\tconst dl = abs( sub( float( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();\n\tconst dr = abs( sub( float( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();\n\tconst db = abs( sub( float( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();\n\tconst dt = abs( sub( float( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();\n\n\tconst ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();\n\n\tconst dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2( float( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2( float( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );\n\tconst dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2( 0, float( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2( 0, float( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );\n\n\treturn normalize( cross( dpdx, dpdy ) );\n\n} );\n\n/**\n * This special type of instanced buffer attribute is intended for compute shaders.\n * In earlier three.js versions it was only possible to update attribute data\n * on the CPU via JavaScript and then upload the data to the GPU. With the\n * new material system and renderer it is now possible to use compute shaders\n * to compute the data for an attribute more efficiently on the GPU.\n *\n * The idea is to create an instance of this class and provide it as an input\n * to {@link module:StorageBufferNode}.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`.\n *\n * @augments InstancedBufferAttribute\n */\nclass StorageInstancedBufferAttribute extends InstancedBufferAttribute {\n\n\t/**\n\t * Constructs a new storage instanced buffer attribute.\n\t *\n\t * @param {Number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.\n\t * The subsequent parameters are then obsolete.\n\t * @param {Number} itemSize - The item size.\n\t * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.\n\t */\n\tconstructor( count, itemSize, typeClass = Float32Array ) {\n\n\t\tconst array = ArrayBuffer.isView( count ) ? count : new typeClass( count * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageInstancedBufferAttribute = true;\n\n\t}\n\n}\n\n/**\n * This special type of buffer attribute is intended for compute shaders.\n * In earlier three.js versions it was only possible to update attribute data\n * on the CPU via JavaScript and then upload the data to the GPU. With the\n * new material system and renderer it is now possible to use compute shaders\n * to compute the data for an attribute more efficiently on the GPU.\n *\n * The idea is to create an instance of this class and provide it as an input\n * to {@link module:StorageBufferNode}.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`.\n *\n * @augments BufferAttribute\n */\nclass StorageBufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new storage buffer attribute.\n\t *\n\t * @param {Number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.\n\t * The subsequent parameters are then obsolete.\n\t * @param {Number} itemSize - The item size.\n\t * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.\n\t */\n\tconstructor( count, itemSize, typeClass = Float32Array ) {\n\n\t\tconst array = ArrayBuffer.isView( count ) ? count : new typeClass( count * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBufferAttribute = true;\n\n\t}\n\n}\n\n/** @module StorageArrayElementNode **/\n\n/**\n * This class enables element access on instances of {@link StorageBufferNode}.\n * In most cases, it is indirectly used when accessing elements with the\n * {@link StorageBufferNode#element} method.\n *\n * ```js\n * const position = positionStorage.element( instanceIndex );\n * ```\n *\n * @augments ArrayElementNode\n */\nclass StorageArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs storage buffer element node.\n\t *\n\t * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( storageBufferNode, indexNode ) {\n\n\t\tsuper( storageBufferNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageArrayElementNode = true;\n\n\t}\n\n\t/**\n\t * The storage buffer node.\n\t *\n\t * @param {Node} value\n\t * @type {StorageBufferNode}\n\t */\n\tset storageBufferNode( value ) {\n\n\t\tthis.node = value;\n\n\t}\n\n\tget storageBufferNode() {\n\n\t\treturn this.node;\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\tconst structTypeNode = this.storageBufferNode.structTypeNode;\n\n\t\tif ( structTypeNode ) {\n\n\t\t\treturn structTypeNode.getMemberType( builder, name );\n\n\t\t}\n\n\t\treturn 'void';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true ) {\n\n\t\t\t\tbuilder.setupPBO( this.node );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\n\t\t//\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true && isAssignContext !== true && ( this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute' ) ) {\n\n\t\t\t\tsnippet = builder.generatePBO( this );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = this.node.build( builder );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder );\n\n\t\t}\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage element node.\n *\n * @function\n * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n * @param {Node} indexNode - The index node that defines the element access.\n * @returns {StorageArrayElementNode}\n */\nconst storageElement = /*@__PURE__*/ nodeProxy( StorageArrayElementNode );\n\n/** @module StorageBufferNode **/\n\n/**\n * This node is used in context of compute shaders and allows to define a\n * storage buffer for data. A typical workflow is to create instances of\n * this node with the convenience functions `attributeArray()` or `instancedArray()`,\n * setup up a compute shader that writes into the buffers and then convert\n * the storage buffers to attribute nodes for rendering.\n *\n * ```js\n * const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node\n *\n * const computeInit = Fn( () => { // the compute shader\n *\n * \tconst position = positionBuffer.element( instanceIndex );\n *\n * \t// compute position data\n *\n * \tposition.x = 1;\n * \tposition.y = 1;\n * \tposition.z = 1;\n *\n * } )().compute( particleCount );\n *\n * const particleMaterial = new THREE.SpriteNodeMaterial();\n * particleMaterial.positionNode = positionBuffer.toAttribute();\n *\n * renderer.computeAsync( computeInit );\n *\n * ```\n *\n * @augments BufferNode\n */\nclass StorageBufferNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageBufferNode';\n\n\t}\n\n\t/**\n\t * Constructs a new storage buffer node.\n\t *\n\t * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n\t * @param {(String|Struct)?} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {Number} [bufferCount=0] - The buffer count.\n\t */\n\tconstructor( value, bufferType = null, bufferCount = 0 ) {\n\n\t\tlet nodeType, structTypeNode = null;\n\n\t\tif ( bufferType && bufferType.isStruct ) {\n\n\t\t\tnodeType = 'struct';\n\t\t\tstructTypeNode = bufferType.layout;\n\n\t\t} else if ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {\n\n\t\t\tnodeType = getTypeFromLength( value.itemSize );\n\t\t\tbufferCount = value.count;\n\n\t\t} else {\n\n\t\t\tnodeType = bufferType;\n\n\t\t}\n\n\t\tsuper( value, nodeType, bufferCount );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBufferNode = true;\n\n\n\t\t/**\n\t\t * The buffer struct type.\n\t\t *\n\t\t * @type {structTypeNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.structTypeNode = structTypeNode;\n\n\t\t/**\n\t\t * The access type of the texture node.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'readWrite'\n\t\t */\n\t\tthis.access = NodeAccess.READ_WRITE;\n\n\t\t/**\n\t\t * Whether the node is atomic or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isAtomic = false;\n\n\t\t/**\n\t\t * Whether the node represents a PBO or not.\n\t\t * Only relevant for WebGL.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isPBO = false;\n\n\t\t/**\n\t\t * A reference to the internal buffer attribute node.\n\t\t *\n\t\t * @type {BufferAttributeNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._attribute = null;\n\n\t\t/**\n\t\t * A reference to the internal varying node.\n\t\t *\n\t\t * @type {VaryingNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._varying = null;\n\n\t\t/**\n\t\t * `StorageBufferNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {\n\n\t\t\t// TODO: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n\t\t\tif ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;\n\t\t\telse value.isStorageBufferAttribute = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the buffer data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferCount === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n\n\t}\n\n\t/**\n\t * Enables element access with the given index node.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {StorageArrayElementNode} A node representing the element access.\n\t */\n\telement( indexNode ) {\n\n\t\treturn storageElement( this, indexNode );\n\n\t}\n\n\t/**\n\t * Defines whether this node is a PBO or not. Only relevant for WebGL.\n\t *\n\t * @param {Boolean} value - The value so set.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetPBO( value ) {\n\n\t\tthis.isPBO = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the `isPBO` value.\n\t *\n\t * @return {Boolean} Whether the node represents a PBO or not.\n\t */\n\tgetPBO() {\n\n\t\treturn this.isPBO;\n\n\t}\n\n\t/**\n\t * Defines the node access.\n\t *\n\t * @param {String} value - The node access.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read-only node access.\n\t *\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\t/**\n\t * Defines whether the node is atomic or not.\n\t *\n\t * @param {Boolean} value - The atomic flag.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetAtomic( value ) {\n\n\t\tthis.isAtomic = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenience method for making this node atomic.\n\t *\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\ttoAtomic() {\n\n\t\treturn this.setAtomic( true );\n\n\t}\n\n\t/**\n\t * Returns attribute data for this storage buffer node.\n\t *\n\t * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.\n\t */\n\tgetAttributeData() {\n\n\t\tif ( this._attribute === null ) {\n\n\t\t\tthis._attribute = bufferAttribute( this.value );\n\t\t\tthis._varying = varying( this._attribute );\n\n\t\t}\n\n\t\treturn {\n\t\t\tattribute: this._attribute,\n\t\t\tvarying: this._varying\n\t\t};\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type from the availability of storage buffers\n\t * and the attribute data.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.structTypeNode !== null ) {\n\n\t\t\treturn this.structTypeNode.getNodeType( builder );\n\n\t\t}\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.getNodeType( builder );\n\n\t\t}\n\n\t\tconst { attribute } = this.getAttributeData();\n\n\t\treturn attribute.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage buffer node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tif ( this.structTypeNode !== null ) this.structTypeNode.build( builder );\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.generate( builder );\n\n\t\t}\n\n\t\tconst { attribute, varying } = this.getAttributeData();\n\n\t\tconst output = varying.build( builder );\n\n\t\tbuilder.registerTransform( output, attribute );\n\n\t\treturn output;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage buffer node.\n *\n * @function\n * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n * @param {(String|Struct)?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [count=0] - The buffer count.\n * @returns {StorageBufferNode}\n */\nconst storage = ( value, type = null, count = 0 ) => nodeObject( new StorageBufferNode( value, type, count ) );\n\n/**\n * @function\n * @deprecated since r171. Use `storage().setPBO( true )` instead.\n *\n * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n * @param {String?} type - The buffer type (e.g. `'vec3'`).\n * @param {Number} count - The buffer count.\n * @returns {StorageBufferNode}\n */\nconst storageObject = ( value, type, count ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.' );\n\n\treturn storage( value, type, count ).setPBO( true );\n\n};\n\n/** @module Arrays **/\n\n/**\n * TSL function for creating a storage buffer node with a configured `StorageBufferAttribute`.\n *\n * @function\n * @param {Number|TypedArray} count - The data count. It is also valid to pass a typed array as an argument.\n * @param {String|Struct} [type='float'] - The data type.\n * @returns {StorageBufferNode}\n */\nconst attributeArray = ( count, type = 'float' ) => {\n\n\tlet itemSize, typedArray;\n\n\tif ( type.isStruct === true ) {\n\n\t\titemSize = type.layout.getLength();\n\t\ttypedArray = getTypedArrayFromType( 'float' );\n\n\t} else {\n\n\t\titemSize = getLengthFromType( type );\n\t\ttypedArray = getTypedArrayFromType( type );\n\n\t}\n\n\tconst buffer = new StorageBufferAttribute( count, itemSize, typedArray );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\n/**\n * TSL function for creating a storage buffer node with a configured `StorageInstancedBufferAttribute`.\n *\n * @function\n * @param {Number|TypedArray} count - The data count. It is also valid to pass a typed array as an argument.\n * @param {String|Struct} [type='float'] - The data type.\n * @returns {StorageBufferNode}\n */\nconst instancedArray = ( count, type = 'float' ) => {\n\n\tlet itemSize, typedArray;\n\n\tif ( type.isStruct === true ) {\n\n\t\titemSize = type.layout.getLength();\n\t\ttypedArray = getTypedArrayFromType( 'float' );\n\n\t} else {\n\n\t\titemSize = getLengthFromType( type );\n\t\ttypedArray = getTypedArrayFromType( type );\n\n\t}\n\n\tconst buffer = new StorageInstancedBufferAttribute( count, itemSize, typedArray );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\n/** @module VertexColorNode **/\n\n/**\n * An attribute node for representing vertex colors.\n *\n * @augments module:AttributeNode~AttributeNode\n */\nclass VertexColorNode extends AttributeNode {\n\n\tstatic get type() {\n\n\t\treturn 'VertexColorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new vertex color node.\n\t *\n\t * @param {Number} [index=0] - The attribute index.\n\t */\n\tconstructor( index = 0 ) {\n\n\t\tsuper( null, 'vec4' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVertexColorNode = true;\n\n\t\t/**\n\t\t * The attribute index to enable more than one sets of vertex colors.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.index = index;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation by honoring the attribute index.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The attribute name.\n\t */\n\tgetAttributeName( /*builder*/ ) {\n\n\t\tconst index = this.index;\n\n\t\treturn 'color' + ( index > 0 ? index : '' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tlet result;\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tresult = super.generate( builder );\n\n\t\t} else {\n\n\t\t\t// Vertex color fallback should be white\n\t\t\tresult = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.index = this.index;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.index = data.index;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference node.\n *\n * @function\n * @param {Number} index - The attribute index.\n * @returns {VertexColorNode}\n */\nconst vertexColor = ( index ) => nodeObject( new VertexColorNode( index ) );\n\n/** @module PointUVNode **/\n\n/**\n * A node for representing the uv coordinates of points.\n *\n * Can only be used with a WebGL backend. In WebGPU, point\n * primitives always have the size of one pixel and can thus\n * can't be used as sprite-like objects that display textures.\n *\n * @augments Node\n */\nclass PointUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PointUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point uv node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPointUVNode = true;\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\treturn 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n\n\t}\n\n}\n\n/**\n * TSL object that represents the uv coordinates of points.\n *\n * @type {PointUVNode}\n */\nconst pointUV = /*@__PURE__*/ nodeImmutable( PointUVNode );\n\nconst _e1 = /*@__PURE__*/ new Euler();\nconst _m1 = /*@__PURE__*/ new Matrix4();\n\n/** @module SceneNode **/\n\n/**\n * This module allows access to a collection of scene properties. The following predefined TSL objects\n * are available for easier use:\n *\n * - `backgroundBlurriness`: A node that represents the scene's background blurriness.\n * - `backgroundIntensity`: A node that represents the scene's background intensity.\n * - `backgroundRotation`: A node that represents the scene's background rotation.\n *\n * @augments Node\n */\nclass SceneNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SceneNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scene node.\n\t *\n\t * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.\n\t * @param {Scene?} [scene=null] - A reference to the scene.\n\t */\n\tconstructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scope defines the type of scene property that is accessed.\n\t\t *\n\t\t * @type {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * A reference to the scene that is going to be accessed.\n\t\t *\n\t\t * @type {Scene?}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = scene;\n\n\t}\n\n\t/**\n\t * Depending on the scope, the method returns a different type of node that represents\n\t * the respective scene property.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst scope = this.scope;\n\t\tconst scene = this.scene !== null ? this.scene : builder.scene;\n\n\t\tlet output;\n\n\t\tif ( scope === SceneNode.BACKGROUND_BLURRINESS ) {\n\n\t\t\toutput = reference( 'backgroundBlurriness', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {\n\n\t\t\toutput = reference( 'backgroundIntensity', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {\n\n\t\t\toutput = uniform( 'mat4' ).label( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\t\t\tconst background = scene.background;\n\n\t\t\t\tif ( background !== null && background.isTexture && background.mapping !== UVMapping ) {\n\n\t\t\t\t\t_e1.copy( scene.backgroundRotation );\n\n\t\t\t\t\t// accommodate left-handed frame\n\t\t\t\t\t_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;\n\n\t\t\t\t\t_m1.makeRotationFromEuler( _e1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_m1.identity();\n\n\t\t\t\t}\n\n\t\t\t\treturn _m1;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.SceneNode: Unknown scope:', scope );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nSceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';\nSceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';\nSceneNode.BACKGROUND_ROTATION = 'backgroundRotation';\n\n/**\n * TSL object that represents the scene's background blurriness.\n *\n * @type {SceneNode}\n */\nconst backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );\n\n/**\n * TSL object that represents the scene's background intensity.\n *\n * @type {SceneNode}\n */\nconst backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );\n\n/**\n * TSL object that represents the scene's background rotation.\n *\n * @type {SceneNode}\n */\nconst backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );\n\n/** @module StorageTextureNode **/\n\n/**\n * This special version of a texture node can be used to\n * write data into a storage texture with a compute shader.\n *\n * ```js\n * const storageTexture = new THREE.StorageTexture( width, height );\n *\n * const computeTexture = Fn( ( { storageTexture } ) => {\n *\n * \tconst posX = instanceIndex.modInt( width );\n * \tconst posY = instanceIndex.div( width );\n * \tconst indexUV = uvec2( posX, posY );\n *\n * \t// generate RGB values\n *\n * \tconst r = 1;\n * \tconst g = 1;\n * \tconst b = 1;\n *\n * \ttextureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();\n *\n * } );\n *\n * const computeNode = computeTexture( { storageTexture } ).compute( width * height );\n * renderer.computeAsync( computeNode );\n * ```\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass StorageTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new storage texture node.\n\t *\n\t * @param {StorageTexture} value - The storage texture.\n\t * @param {Node<vec2|vec3>} uvNode - The uv node.\n\t * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n\t */\n\tconstructor( value, uvNode, storeNode = null ) {\n\n\t\tsuper( value, uvNode );\n\n\t\t/**\n\t\t * The value node that should be stored in the texture.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.storeNode = storeNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTextureNode = true;\n\n\t\t/**\n\t\t * The access type of the texture node.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'writeOnly'\n\t\t */\n\t\tthis.access = NodeAccess.WRITE_ONLY;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'storageTexture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'storageTexture';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.storeNode = this.storeNode;\n\n\t}\n\n\t/**\n\t * Defines the node access.\n\t *\n\t * @param {String} value - The node access.\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the stroge node. If no `storeNode`\n\t * is defined, the texture node is generated as normal texture.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} output - The current output.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tsnippet = this.generateStore( builder );\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read/write node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoReadWrite() {\n\n\t\treturn this.setAccess( NodeAccess.READ_WRITE );\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read-only node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a write-only node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoWriteOnly() {\n\n\t\treturn this.setAccess( NodeAccess.WRITE_ONLY );\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage texture node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tgenerateStore( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst { uvNode, storeNode } = properties;\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\t\tconst uvSnippet = uvNode.build( builder, 'uvec2' );\n\t\tconst storeSnippet = storeNode.build( builder, 'vec4' );\n\n\t\tconst snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, storeSnippet );\n\n\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage texture node.\n *\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {Node<vec2|vec3>} uvNode - The uv node.\n * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nconst storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode );\n\n\n/**\n * TODO: Explain difference to `storageTexture()`.\n *\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {Node<vec2|vec3>} uvNode - The uv node.\n * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nconst textureStore = ( value, uvNode, storeNode ) => {\n\n\tconst node = storageTexture( value, uvNode, storeNode );\n\n\tif ( storeNode !== null ) node.append();\n\n\treturn node;\n\n};\n\n/** @module UserDataNode **/\n\n/**\n * A special type of reference node that allows to link values in\n * `userData` fields to node objects.\n * ```js\n * sprite.userData.rotation = 1; // stores individual rotation per sprite\n *\n * const material = new THREE.SpriteNodeMaterial();\n * material.rotationNode = userData( 'rotation', 'float' );\n * ```\n * Since `UserDataNode` is extended from {@link module:ReferenceNode~ReferenceNode}, the node value\n * will automatically be updated when the `rotation` user data field changes.\n *\n * @augments module:ReferenceNode~ReferenceNode\n */\nclass UserDataNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'UserDataNode';\n\n\t}\n\n\t/**\n\t * Constructs a new user data node.\n\t *\n\t * @param {String} property - The property name that should be referenced by the node.\n\t * @param {String} inputType - The node data type of the reference.\n\t * @param {Object?} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.\n\t */\n\tconstructor( property, inputType, userData = null ) {\n\n\t\tsuper( property, inputType, userData );\n\n\t\t/**\n\t\t * A reference to the `userData` object. If not provided, the `userData`\n\t\t * property of the 3D object that uses the node material is evaluated.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.userData = userData;\n\n\t}\n\n\t/**\n\t * Overwritten to make sure {@link module:ReferenceNode~ReferenceNode#reference} points to the correct\n\t * `userData` field.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.\n\t * @return {Object} A reference to the `userData` field.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.userData !== null ? this.userData : state.object.userData;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a user data node.\n *\n * @function\n * @param {String} name - The property name that should be referenced by the node.\n * @param {String} inputType - The node data type of the reference.\n * @param {Object?} userData - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.\n * @returns {UserDataNode}\n */\nconst userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );\n\nconst _objectData = new WeakMap();\n\n/** @module VelocityNode **/\n\n/**\n * A node for representing motion or velocity vectors. Foundation\n * for advanced post processing effects like motion blur or TRAA.\n *\n * The node keeps track of the model, view and projection matrices\n * of the previous frame and uses them to compute offsets in NDC space.\n * These offsets represent the final velocity.\n *\n * @augments TempNode\n */\nclass VelocityNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'VelocityNode';\n\n\t}\n\n\t/**\n\t * Constructs a new vertex color node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * The current projection matrix.\n\t\t *\n\t\t * @type {Matrix4?}\n\t\t * @default null\n\t\t */\n\t\tthis.projectionMatrix = null;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes save data after the update.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Uniform node representing the previous model matrix in world space.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousModelWorldMatrix = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * Uniform node representing the previous projection matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the previous view matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousCameraViewMatrix = uniform( new Matrix4() );\n\n\t}\n\n\t/**\n\t * Sets the given projection matrix.\n\t *\n\t * @param {Matrix4} projectionMatrix - The projection matrix to set.\n\t */\n\tsetProjectionMatrix( projectionMatrix ) {\n\n\t\tthis.projectionMatrix = projectionMatrix;\n\n\t}\n\n\t/**\n\t * Updates velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { frameId, camera, object } ) {\n\n\t\tconst previousModelMatrix = getPreviousMatrix( object );\n\n\t\tthis.previousModelWorldMatrix.value.copy( previousModelMatrix );\n\n\t\t//\n\n\t\tconst cameraData = getData( camera );\n\n\t\tif ( cameraData.frameId !== frameId ) {\n\n\t\t\tcameraData.frameId = frameId;\n\n\t\t\tif ( cameraData.previousProjectionMatrix === undefined ) {\n\n\t\t\t\tcameraData.previousProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.previousCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.currentProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.currentCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\t} else {\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );\n\n\t\t\t}\n\n\t\t\tcameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\tcameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\tthis.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );\n\t\t\tthis.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten to updated velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateAfter( { object } ) {\n\n\t\tgetPreviousMatrix( object ).copy( object.matrixWorld );\n\n\t}\n\n\t/**\n\t * Implements the velocity computation based on the previous and current vertex data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec2>} The motion vector.\n\t */\n\tsetup( /*builder*/ ) {\n\n\t\tconst projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );\n\n\t\tconst previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );\n\n\t\tconst clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\t\tconst clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );\n\n\t\tconst ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );\n\t\tconst ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );\n\n\t\tconst velocity = sub( ndcPositionCurrent, ndcPositionPrevious );\n\n\t\treturn velocity;\n\n\t}\n\n}\n\nfunction getData( object ) {\n\n\tlet objectData = _objectData.get( object );\n\n\tif ( objectData === undefined ) {\n\n\t\tobjectData = {};\n\t\t_objectData.set( object, objectData );\n\n\t}\n\n\treturn objectData;\n\n}\n\nfunction getPreviousMatrix( object, index = 0 ) {\n\n\tconst objectData = getData( object );\n\n\tlet matrix = objectData[ index ];\n\n\tif ( matrix === undefined ) {\n\n\t\tobjectData[ index ] = matrix = new Matrix4();\n\n\t}\n\n\treturn matrix;\n\n}\n\n/**\n * TSL object that represents the velocity of a render pass.\n *\n * @type {VelocityNode}\n */\nconst velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );\n\n/** @module BlendModes **/\n\n/**\n * Represents a \"Color Burn\" blend mode.\n *\n * It's designed to darken the base layer's colors based on the color of the blend layer.\n * It significantly increases the contrast of the base layer, making the colors more vibrant and saturated.\n * The darker the color in the blend layer, the stronger the darkening and contrast effect on the base layer.\n *\n * @method\n * @param {Node<vec3>} base - The base color.\n * @param {Node<vec3>} blend - The blend color. A white (#ffffff) blend color does not alter the base color.\n * @return {Node<vec3>} The result.\n */\nconst blendBurn = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( 1.0, base.oneMinus().div( blend ) ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendBurn',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\n/**\n * Represents a \"Color Dodge\" blend mode.\n *\n * It's designed to lighten the base layer's colors based on the color of the blend layer.\n * It significantly increases the brightness of the base layer, making the colors lighter and more vibrant.\n * The brighter the color in the blend layer, the stronger the lightening and contrast effect on the base layer.\n *\n * @method\n * @param {Node<vec3>} base - The base color.\n * @param {Node<vec3>} blend - The blend color. A black (#000000) blend color does not alter the base color.\n * @return {Node<vec3>} The result.\n */\nconst blendDodge = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( base.div( blend.oneMinus() ), 1.0 );\n\n} ).setLayout( {\n\tname: 'blendDodge',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\n/**\n * Represents a \"Screen\" blend mode.\n *\n * Similar to `blendDodge()`, this mode also lightens the base layer's colors based on the color of the blend layer.\n * The \"Screen\" blend mode is better for general brightening whereas the \"Dodge\" results in more subtle and nuanced\n * effects.\n *\n * @method\n * @param {Node<vec3>} base - The base color.\n * @param {Node<vec3>} blend - The blend color. A black (#000000) blend color does not alter the base color.\n * @return {Node<vec3>} The result.\n */\nconst blendScreen = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn base.oneMinus().mul( blend.oneMinus() ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendScreen',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\n/**\n * Represents a \"Overlay\" blend mode.\n *\n * It's designed to increase the contrast of the base layer based on the color of the blend layer.\n * It amplifies the existing colors and contrast in the base layer, making lighter areas lighter and darker areas darker.\n * The color of the blend layer significantly influences the resulting contrast and color shift in the base layer.\n *\n * @method\n * @param {Node<vec3>} base - The base color.\n * @param {Node<vec3>} blend - The blend color\n * @return {Node<vec3>} The result.\n */\nconst blendOverlay = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn mix( base.mul( 2.0 ).mul( blend ), base.oneMinus().mul( 2.0 ).mul( blend.oneMinus() ).oneMinus(), step( 0.5, base ) );\n\n} ).setLayout( {\n\tname: 'blendOverlay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\n/**\n * This function blends two color based on their alpha values by replicating the behavior of `THREE.NormalBlending`.\n * It assumes both input colors have non-preumiltiplied alpha.\n *\n * @method\n * @param {Node<vec4>} base - The base color.\n * @param {Node<vec4>} blend - The blend color\n * @return {Node<vec4>} The result.\n */\nconst blendColor = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\tconst outAlpha = blend.a.add( base.a.mul( blend.a.oneMinus() ) );\n\n\treturn vec4( blend.rgb.mul( blend.a ).add( base.rgb.mul( base.a ).mul( blend.a.oneMinus() ) ).div( outAlpha ), outAlpha );\n\n} ).setLayout( {\n\tname: 'blendColor',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec4' },\n\t\t{ name: 'blend', type: 'vec4' }\n\t]\n} );\n\n// Deprecated\n\n/**\n * @function\n * @deprecated since r171. Use {@link blendBurn} instead.\n *\n * @param  {...any} params\n * @returns {Function}\n */\nconst burn = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.' );\n\treturn blendBurn( params );\n\n};\n\n/**\n * @function\n * @deprecated since r171. Use {@link blendDodge} instead.\n *\n * @param  {...any} params\n * @returns {Function}\n */\nconst dodge = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.' );\n\treturn blendDodge( params );\n\n};\n\n/**\n * @method\n * @deprecated since r171. Use {@link blendScreen} instead.\n *\n * @param  {...any} params\n * @returns {Function}\n */\nconst screen = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.' );\n\treturn blendScreen( params );\n\n};\n\n/**\n * @method\n * @deprecated since r171. Use {@link blendOverlay} instead.\n *\n * @param  {...any} params\n * @returns {Function}\n */\nconst overlay = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.' );\n\treturn blendOverlay( params );\n\n};\n\n/** @module ColorAdjustment **/\n\n/**\n * Computes a grayscale value for the given RGB color value.\n *\n * @method\n * @param {Node<vec3>} color - The color value to compute the grayscale for.\n * @return {Node<vec3>} The grayscale color.\n */\nconst grayscale = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\treturn luminance( color.rgb );\n\n} );\n\n/**\n * Super-saturates or desaturates the given RGB color.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it.\n * @return {Node<vec3>} The saturated color.\n */\nconst saturation = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\treturn adjustment.mix( luminance( color.rgb ), color.rgb );\n\n} );\n\n/**\n * Selectively enhance the intensity of less saturated RGB colors. Can result\n * in a more natural and visually appealing image with enhanced color depth\n * compared to {@link ColorAdjustment#saturation}.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Controls the intensity of the vibrance effect.\n * @return {Node<vec3>} The updated color.\n */\nconst vibrance = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst average = add( color.r, color.g, color.b ).div( 3.0 );\n\n\tconst mx = color.r.max( color.g.max( color.b ) );\n\tconst amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );\n\n\treturn mix( color.rgb, mx, amt );\n\n} );\n\n/**\n * Updates the hue component of the given RGB color while preserving its luminance and saturation.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise.\n * @return {Node<vec3>} The updated color.\n */\nconst hue = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst k = vec3( 0.57735, 0.57735, 0.57735 );\n\n\tconst cosAngle = adjustment.cos();\n\n\treturn vec3( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );\n\n} );\n\n/**\n * Computes the luminance for the given RGB color value.\n *\n * @method\n * @param {Node<vec3>} color - The color value to compute the luminance for.\n * @param {Node<vec3>?} luminanceCoefficients - The luminance coefficients. By default predefined values of the current working color space are used.\n * @return {Node<vec3>} The luminance.\n */\nconst luminance = (\n\tcolor,\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3() ) )\n) => dot( color, luminanceCoefficients );\n\n/**\n * Color Decision List (CDL) v1.2\n *\n * Compact representation of color grading information, defined by slope, offset, power, and\n * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,\n * or AgX Log), and will return output in the same space. Output may require clamping >=0.\n *\n * @method\n * @param {Node<vec4>} color Input (-Infinity < input < +Infinity)\n * @param {Node<vec3>} slope Slope (0 ≤ slope < +Infinity)\n * @param {Node<vec3>} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)\n * @param {Node<vec3>} power Power (0 < power < +Infinity)\n * @param {Node<float>} saturation Saturation (0 ≤ saturation < +Infinity; typically 0 ≤ saturation < 4)\n * @param {Node<vec3>} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709\n * @return {Node<vec4>} Output, -Infinity < output < +Infinity\n *\n * References:\n * - ASC CDL v1.2\n * - {@link https://blender.stackexchange.com/a/55239/43930}\n * - {@link https://docs.acescentral.com/specifications/acescc/}\n */\nconst cdl = /*@__PURE__*/ Fn( ( [\n\tcolor,\n\tslope = vec3( 1 ),\n\toffset = vec3( 0 ),\n\tpower = vec3( 1 ),\n\tsaturation = float( 1 ),\n\t// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3(), LinearSRGBColorSpace ) )\n] ) => {\n\n\t// NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the\n\t// saturation term. Per the ACEScc specification and Filament, limits may be omitted to support\n\t// values outside [0, 1], requiring a workaround for negative values in the power expression.\n\n\tconst luma = color.rgb.dot( vec3( luminanceCoefficients ) );\n\n\tconst v = max$1( color.rgb.mul( slope ).add( offset ), 0.0 ).toVar();\n\tconst pv = v.pow( power ).toVar();\n\n\tIf( v.r.greaterThan( 0.0 ), () => { v.r.assign( pv.r ); } ); // eslint-disable-line\n\tIf( v.g.greaterThan( 0.0 ), () => { v.g.assign( pv.g ); } ); // eslint-disable-line\n\tIf( v.b.greaterThan( 0.0 ), () => { v.b.assign( pv.b ); } ); // eslint-disable-line\n\n\tv.assign( luma.add( v.sub( luma ).mul( saturation ) ) );\n\n\treturn vec4( v.rgb, color.a );\n\n} );\n\n/** @module PosterizeNode **/\n\n/**\n * Represents a posterize effect which reduces the number of colors\n * in an image, resulting in a more blocky and stylized appearance.\n *\n * @augments TempNode\n */\nclass PosterizeNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PosterizeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new posterize node.\n\t *\n\t * @param {Node} sourceNode - The input color.\n\t * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n\t */\n\tconstructor( sourceNode, stepsNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The input color.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.stepsNode = stepsNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { sourceNode, stepsNode } = this;\n\n\t\treturn sourceNode.mul( stepsNode ).floor().div( stepsNode );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a posterize node.\n *\n * @function\n * @param {Node} sourceNode - The input color.\n * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n * @returns {PosterizeNode}\n */\nconst posterize = /*@__PURE__*/ nodeProxy( PosterizeNode );\n\n/** @module PassNode **/\n\nconst _size = /*@__PURE__*/ new Vector2();\n\n/**\n * Represents the texture of a pass node.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass PassTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass texture node.\n\t *\n\t * @param {PassNode} passNode - The pass node.\n\t * @param {Texture} texture - The output texture.\n\t */\n\tconstructor( passNode, texture ) {\n\n\t\tsuper( texture );\n\n\t\t/**\n\t\t * A reference to the pass node.\n\t\t *\n\t\t * @type {PassNode}\n\t\t */\n\t\tthis.passNode = passNode;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.object.isQuadMesh ) this.passNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.value );\n\n\t}\n\n}\n\n/**\n * An extension of `PassTextureNode` which allows to manage more than one\n * internal texture. Relevant for the `getPreviousTexture()` related API.\n *\n * @augments module:PassTextureNode~PassTextureNode\n */\nclass PassMultipleTextureNode extends PassTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassMultipleTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass texture node.\n\t *\n\t * @param {PassNode} passNode - The pass node.\n\t * @param {String} textureName - The output texture name.\n\t * @param {Boolean} [previousTexture=false] - Whether previous frame data should be used or not.\n\t */\n\tconstructor( passNode, textureName, previousTexture = false ) {\n\n\t\t// null is passed to the super call since this class does not\n\t\t// use an external texture for rendering pass data into. Instead\n\t\t// the texture is managed by the pass node itself\n\n\t\tsuper( passNode, null );\n\n\t\t/**\n\t\t * The output texture name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.textureName = textureName;\n\n\t\t/**\n\t\t * Whether previous frame data should be used or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.previousTexture = previousTexture;\n\n\t}\n\n\t/**\n\t * Updates the texture reference of this node.\n\t */\n\tupdateTexture() {\n\n\t\tthis.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateTexture();\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.textureName, this.previousTexture );\n\n\t}\n\n}\n\n/**\n * Represents a render pass (sometimes called beauty pass) in context of post processing.\n * This pass produces a render for the given scene and camera and can provide multiple outputs\n * via MRT for further processing.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n *\n * @augments TempNode\n */\nclass PassNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass node.\n\t *\n\t * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - A reference to the camera.\n\t * @param {Object} options - Options for the internal render target.\n\t */\n\tconstructor( scope, scene, camera, options = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The scope of the pass. The scope determines whether the node outputs color or depth.\n\t\t *\n\t\t * @type {('color'|'depth')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * A reference to the scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * A reference to the camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * Options for the internal render target.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.options = options;\n\n\t\t/**\n\t\t * The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._pixelRatio = 1;\n\n\t\t/**\n\t\t * The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._width = 1;\n\n\t\t/**\n\t\t * The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._height = 1;\n\n\t\tconst depthTexture = new DepthTexture();\n\t\tdepthTexture.isRenderTargetTexture = true;\n\t\t//depthTexture.type = FloatType;\n\t\tdepthTexture.name = 'depth';\n\n\t\tconst renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );\n\t\trenderTarget.texture.name = 'output';\n\t\trenderTarget.depthTexture = depthTexture;\n\n\t\t/**\n\t\t * The pass's render target.\n\t\t *\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * A dictionary holding the internal result textures.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<String, Texture>}\n\t\t */\n\t\tthis._textures = {\n\t\t\toutput: renderTarget.texture,\n\t\t\tdepth: depthTexture\n\t\t};\n\n\t\t/**\n\t\t * A dictionary holding the internal texture nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<String, TextureNode>}\n\t\t */\n\t\tthis._textureNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the internal depth nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._linearDepthNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the internal viewZ nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._viewZNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the texture data of the previous frame.\n\t\t * Used for computing velocity/motion vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<String, Texture>}\n\t\t */\n\t\tthis._previousTextures = {};\n\n\t\t/**\n\t\t * A dictionary holding the texture nodes of the previous frame.\n\t\t * Used for computing velocity/motion vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<String, TextureNode>}\n\t\t */\n\t\tthis._previousTextureNodes = {};\n\n\t\t/**\n\t\t * The `near` property of the camera as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._cameraNear = uniform( 0 );\n\n\t\t/**\n\t\t * The `far` property of the camera as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._cameraFar = uniform( 0 );\n\n\t\t/**\n\t\t * A MRT node configuring the MRT settings.\n\t\t *\n\t\t * @private\n\t\t * @type {MRTNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._mrt = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPassNode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n\t\t * scene once per frame in its {@link PassNode#updateBefore} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Sets the given MRT node to setup MRT for this pass.\n\t *\n\t * @param {MRTNode} mrt - The MRT object.\n\t * @return {PassNode} A reference to this pass.\n\t */\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the current MRT node.\n\t *\n\t * @return {MRTNode} The current MRT node.\n\t */\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t/**\n\t * The method is overwritten so it always returns `true`.\n\t *\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns the texture for the given output name.\n\t *\n\t * @param {String} name - The output name to get the texture for.\n\t * @return {Texture} The texture.\n\t */\n\tgetTexture( name ) {\n\n\t\tlet texture = this._textures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\tconst refTexture = this.renderTarget.texture;\n\n\t\t\ttexture = refTexture.clone();\n\t\t\ttexture.name = name;\n\n\t\t\tthis._textures[ name ] = texture;\n\n\t\t\tthis.renderTarget.textures.push( texture );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Returns the texture holding the data of the previous frame for the given output name.\n\t *\n\t * @param {String} name - The output name to get the texture for.\n\t * @return {Texture} The texture holding the data of the previous frame.\n\t */\n\tgetPreviousTexture( name ) {\n\n\t\tlet texture = this._previousTextures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\ttexture = this.getTexture( name ).clone();\n\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Switches current and previous textures for the given output name.\n\t *\n\t * @param {String} name - The output name.\n\t */\n\ttoggleTexture( name ) {\n\n\t\tconst prevTexture = this._previousTextures[ name ];\n\n\t\tif ( prevTexture !== undefined ) {\n\n\t\t\tconst texture = this._textures[ name ];\n\n\t\t\tconst index = this.renderTarget.textures.indexOf( texture );\n\t\t\tthis.renderTarget.textures[ index ] = prevTexture;\n\n\t\t\tthis._textures[ name ] = prevTexture;\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t\tthis._textureNodes[ name ].updateTexture();\n\t\t\tthis._previousTextureNodes[ name ].updateTexture();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the texture node for the given output name.\n\t *\n\t * @param {String} [name='output'] - The output name to get the texture node for.\n\t * @return {TextureNode} The texture node.\n\t */\n\tgetTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._textureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._textureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\t/**\n\t * Returns the previous texture node for the given output name.\n\t *\n\t * @param {String} [name='output'] - The output name to get the previous texture node for.\n\t * @return {TextureNode} The previous texture node.\n\t */\n\tgetPreviousTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._previousTextureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\tif ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._previousTextureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\t/**\n\t * Returns a viewZ node of this pass.\n\t *\n\t * @param {String} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n\t * @return {Node} The viewZ node.\n\t */\n\tgetViewZNode( name = 'depth' ) {\n\n\t\tlet viewZNode = this._viewZNodes[ name ];\n\n\t\tif ( viewZNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\n\t\t\tthis._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn viewZNode;\n\n\t}\n\n\t/**\n\t * Returns a linear depth node of this pass.\n\t *\n\t * @param {String} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n\t * @return {Node} The linear depth node.\n\t */\n\tgetLinearDepthNode( name = 'depth' ) {\n\n\t\tlet linearDepthNode = this._linearDepthNodes[ name ];\n\n\t\tif ( linearDepthNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\t\t\tconst viewZNode = this.getViewZNode( name );\n\n\t\t\t// TODO: just if ( builder.camera.isPerspectiveCamera )\n\n\t\t\tthis._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn linearDepthNode;\n\n\t}\n\n\tsetup( { renderer } ) {\n\n\t\tthis.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n\t\t// TODO: Disable MSAA for WebGL backend for now\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tthis.renderTarget.samples = 0;\n\n\t\t}\n\n\t\tthis.renderTarget.texture.type = renderer.getColorBufferType();\n\n\t\treturn this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene, camera } = this;\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tconst size = renderer.getSize( _size );\n\n\t\tthis.setSize( size.width, size.height );\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\tfor ( const name in this._previousTextures ) {\n\n\t\t\tthis.toggleTexture( name );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\n\t\trenderer.render( scene, camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setMRT( currentMRT );\n\n\t}\n\n\t/**\n\t * Sets the size of the pass's render target. Honors the pixel ratio.\n\t *\n\t * @param {Number} width - The width to set.\n\t * @param {Number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t}\n\n\t/**\n\t * Sets the pixel ratio the pass's render target and updates the size.\n\t *\n\t * @param {Number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Frees internal resources. Should be called when the node is no longer in use.\n\t */\n\tdispose() {\n\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\n}\n\nPassNode.COLOR = 'color';\nPassNode.DEPTH = 'depth';\n\n/**\n * TSL function for creating a pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nconst pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );\n\n/**\n * TSL function for creating a pass texture node.\n *\n * @function\n * @param {PassNode} pass - The pass node.\n * @param {Texture} texture - The output texture.\n * @returns {PassTextureNode}\n */\nconst passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );\n\n/**\n * TSL function for creating a depth pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nconst depthPass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera, options ) );\n\n/** @module ToonOutlinePassNode **/\n\n/**\n * Represents a render pass for producing a toon outline effect on compatible objects.\n * Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`\n * will receive the outline.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = toonOutlinePass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n * @augments PassNode\n */\nclass ToonOutlinePassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToonOutlinePassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new outline pass node.\n\t *\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - A reference to the camera.\n\t * @param {Node} colorNode - Defines the outline's color.\n\t * @param {Node} thicknessNode - Defines the outline's thickness.\n\t * @param {Node} alphaNode - Defines the outline's alpha.\n\t */\n\tconstructor( scene, camera, colorNode, thicknessNode, alphaNode ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera );\n\n\t\t/**\n\t\t * Defines the outline's color.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * Defines the outline's thickness.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.thicknessNode = thicknessNode;\n\n\t\t/**\n\t\t * Defines the outline's alpha.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.alphaNode = alphaNode;\n\n\t\t/**\n\t\t * An internal material cache.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakMap<Material, NodeMaterial>}\n\t\t */\n\t\tthis._materialCache = new WeakMap();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\trenderer.setRenderObjectFunction( ( object, scene, camera, geometry, material, group, lightsNode, clippingContext ) => {\n\n\t\t\t// only render outline for supported materials\n\n\t\t\tif ( material.isMeshToonMaterial || material.isMeshToonNodeMaterial ) {\n\n\t\t\t\tif ( material.wireframe === false ) {\n\n\t\t\t\t\tconst outlineMaterial = this._getOutlineMaterial( material );\n\t\t\t\t\trenderer.renderObject( object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// default\n\n\t\t\trenderer.renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext );\n\n\t\t} );\n\n\t\tsuper.updateBefore( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t}\n\n\t/**\n\t * Creates the material used for outline rendering.\n\t *\n\t * @private\n\t * @return {NodeMaterial} The outline material.\n\t */\n\t_createMaterial() {\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.isMeshToonOutlineMaterial = true;\n\t\tmaterial.name = 'Toon_Outline';\n\t\tmaterial.side = BackSide;\n\n\t\t// vertex node\n\n\t\tconst outlineNormal = normalLocal.negate();\n\t\tconst mvp = cameraProjectionMatrix.mul( modelViewMatrix );\n\n\t\tconst ratio = float( 1.0 ); // TODO: support outline thickness ratio for each vertex\n\t\tconst pos = mvp.mul( vec4( positionLocal, 1.0 ) );\n\t\tconst pos2 = mvp.mul( vec4( positionLocal.add( outlineNormal ), 1.0 ) );\n\t\tconst norm = normalize( pos.sub( pos2 ) ); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\n\t\tmaterial.vertexNode = pos.add( norm.mul( this.thicknessNode ).mul( pos.w ).mul( ratio ) );\n\n\t\t// color node\n\n\t\tmaterial.colorNode = vec4( this.colorNode, this.alphaNode );\n\n\t\treturn material;\n\n\t}\n\n\t/**\n\t * For the given toon material, this method returns a corresponding\n\t * outline material.\n\t *\n\t * @private\n\t * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.\n\t * @return {NodeMaterial} The outline material.\n\t */\n\t_getOutlineMaterial( originalMaterial ) {\n\n\t\tlet outlineMaterial = this._materialCache.get( originalMaterial );\n\n\t\tif ( outlineMaterial === undefined ) {\n\n\t\t\toutlineMaterial = this._createMaterial();\n\n\t\t\tthis._materialCache.set( originalMaterial, outlineMaterial );\n\n\t\t}\n\n\t\treturn outlineMaterial;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a toon outline pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Color} color - Defines the outline's color.\n * @param {Number} [thickness=0.003] - Defines the outline's thickness.\n * @param {Number} [alpha=1] - Defines the outline's alpha.\n * @returns {ToonOutlinePassNode}\n */\nconst toonOutlinePass = ( scene, camera, color = new Color( 0, 0, 0 ), thickness = 0.003, alpha = 1 ) => nodeObject( new ToonOutlinePassNode( scene, camera, nodeObject( color ), nodeObject( thickness ), nodeObject( alpha ) ) );\n\n/** @module ToneMappingFunctions **/\n\n/**\n * Linear tone mapping, exposure only.\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\treturn color.mul( exposure ).clamp();\n\n} ).setLayout( {\n\tname: 'linearToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Reinhard tone mapping.\n *\n * Reference: {@link https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tcolor = color.mul( exposure );\n\n\treturn color.div( color.add( 1.0 ) ).clamp();\n\n} ).setLayout( {\n\tname: 'reinhardToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Cineon tone mapping.\n *\n * Reference: {@link http://filmicworlds.com/blog/filmic-tonemapping-operators/}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor = color.mul( exposure );\n\tcolor = color.sub( 0.004 ).max( 0.0 );\n\n\tconst a = color.mul( color.mul( 6.2 ).add( 0.5 ) );\n\tconst b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );\n\n\treturn a.div( b ).pow( 2.2 );\n\n} ).setLayout( {\n\tname: 'cineonToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );\n\tconst b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );\n\n\treturn a.div( b );\n\n} );\n\n/**\n * ACESFilmic tone mapping.\n *\n * Reference: {@link https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\tconst ACESInputMat = mat3(\n\t\t0.59719, 0.35458, 0.04823,\n\t\t0.07600, 0.90834, 0.01566,\n\t\t0.02840, 0.13383, 0.83777\n\t);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tconst ACESOutputMat = mat3(\n\t\t1.60475, - 0.53108, - 0.07367,\n\t\t- 0.10208, 1.10813, - 0.00605,\n\t\t- 0.00327, - 0.07276, 1.07602\n\t);\n\n\tcolor = color.mul( exposure ).div( 0.6 );\n\n\tcolor = ACESInputMat.mul( color );\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit( color );\n\n\tcolor = ACESOutputMat.mul( color );\n\n\t// Clamp to [0, 1]\n\treturn color.clamp();\n\n} ).setLayout( {\n\tname: 'acesFilmicToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\nconst LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, - 0.1246, - 0.0182 ), vec3( - 0.5876, 1.1329, - 0.1006 ), vec3( - 0.0728, - 0.0083, 1.1187 ) );\nconst LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );\n\nconst agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = vec3( x_immutable ).toVar();\n\tconst x2 = vec3( x.mul( x ) ).toVar();\n\tconst x4 = vec3( x2.mul( x2 ) ).toVar();\n\n\treturn float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );\n\n} );\n\n/**\n * AgX tone mapping.\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst colortone = vec3( color ).toVar();\n\tconst AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );\n\tconst AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ), vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ), vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 ) );\n\tconst AgxMinEv = float( - 12.47393 );\n\tconst AgxMaxEv = float( 4.026069 );\n\tcolortone.mulAssign( exposure );\n\tcolortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );\n\tcolortone.assign( AgXInsetMatrix.mul( colortone ) );\n\tcolortone.assign( max$1( colortone, 1e-10 ) );\n\tcolortone.assign( log2( colortone ) );\n\tcolortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\tcolortone.assign( agxDefaultContrastApprox( colortone ) );\n\tcolortone.assign( AgXOutsetMatrix.mul( colortone ) );\n\tcolortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );\n\tcolortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\n\treturn colortone;\n\n} ).setLayout( {\n\tname: 'agxToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Neutral tone mapping.\n *\n * Reference: {@link https://modelviewer.dev/examples/tone-mapping}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst StartCompression = float( 0.8 - 0.04 );\n\tconst Desaturation = float( 0.15 );\n\n\tcolor = color.mul( exposure );\n\n\tconst x = min$1( color.r, min$1( color.g, color.b ) );\n\tconst offset = select( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );\n\n\tcolor.subAssign( offset );\n\n\tconst peak = max$1( color.r, max$1( color.g, color.b ) );\n\n\tIf( peak.lessThan( StartCompression ), () => {\n\n\t\treturn color;\n\n\t} );\n\n\tconst d = sub( 1, StartCompression );\n\tconst newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );\n\tcolor.mulAssign( newPeak.div( peak ) );\n\tconst g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );\n\n\treturn mix( color, vec3( newPeak ), g );\n\n} ).setLayout( {\n\tname: 'neutralToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/** @module CodeNode **/\n\n/**\n * This class represents native code sections. It is the base\n * class for modules like {@link FunctionNode} which allows to implement\n * functions with native shader languages.\n *\n * @augments Node\n */\nclass CodeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CodeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new code node.\n\t *\n\t * @param {String} [code=''] - The native code.\n\t * @param {Array<Node>} [includes=[]] - An array of includes.\n\t * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n\t */\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( 'code' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCodeNode = true;\n\n\t\t/**\n\t\t * The native code.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.code = code;\n\n\t\t/**\n\t\t * An array of includes\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t * @default []\n\t\t */\n\t\tthis.includes = includes;\n\n\t\t/**\n\t\t * The used language.\n\t\t *\n\t\t * @type {('js'|'wgsl'|'glsl')}\n\t\t * @default ''\n\t\t */\n\t\tthis.language = language;\n\n\t}\n\n\t/**\n\t * The method is overwritten so it always returns `true`.\n\t *\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Sets the includes of this code node.\n\t *\n\t * @param {Array<Node>} includes - The includes to set.\n\t * @return {CodeNode} A reference to this node.\n\t */\n\tsetIncludes( includes ) {\n\n\t\tthis.includes = includes;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the includes of this code node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Array<Node>} The includes.\n\t */\n\tgetIncludes( /*builder*/ ) {\n\n\t\treturn this.includes;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst includes = this.getIncludes( builder );\n\n\t\tfor ( const include of includes ) {\n\n\t\t\tinclude.build( builder );\n\n\t\t}\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );\n\t\tnodeCode.code = this.code;\n\n\t\treturn nodeCode.code;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.code = this.code;\n\t\tdata.language = this.language;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.code = data.code;\n\t\tthis.language = data.language;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a code node.\n *\n * @function\n * @param {String} [code=''] - The native code.\n * @param {Array<Node>} [includes=[]] - An array of includes.\n * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n * @returns {CodeNode}\n */\nconst code = /*@__PURE__*/ nodeProxy( CodeNode );\n\n/**\n * TSL function for creating a JS code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst js = ( src, includes ) => code( src, includes, 'js' );\n\n/**\n * TSL function for creating a WGSL code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst wgsl = ( src, includes ) => code( src, includes, 'wgsl' );\n\n/**\n * TSL function for creating a GLSL code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst glsl = ( src, includes ) => code( src, includes, 'glsl' );\n\n/**\n * This class represents a native shader function. It can be used to implement\n * certain aspects of a node material with native shader code. There are two predefined\n * TSL functions for easier usage.\n *\n * - `wgslFn`: Creates a WGSL function node.\n * - `glslFn`: Creates a GLSL function node.\n *\n * A basic example with one include looks like so:\n *\n * ```js\n * const desaturateWGSLFn = wgslFn( `\n *\tfn desaturate( color:vec3<f32> ) -> vec3<f32> {\n *\t\tlet lum = vec3<f32>( 0.299, 0.587, 0.114 );\n *\t\treturn vec3<f32>( dot( lum, color ) );\n *\t}`\n *);\n * const someWGSLFn = wgslFn( `\n *\tfn someFn( color:vec3<f32> ) -> vec3<f32> {\n * \t\treturn desaturate( color );\n * \t}\n * `, [ desaturateWGSLFn ] );\n * material.colorNode = someWGSLFn( { color: texture( map ) } );\n *```\n * @augments CodeNode\n */\nclass FunctionNode extends CodeNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function node.\n\t *\n\t * @param {String} [code=''] - The native code.\n\t * @param {Array<Node>} [includes=[]] - An array of includes.\n\t * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n\t */\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( code, includes, language );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).type;\n\n\t}\n\n\t/**\n\t * Returns the inputs of this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Array<NodeFunctionInput>} The inputs.\n\t */\n\tgetInputs( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).inputs;\n\n\t}\n\n\t/**\n\t * Returns the node function for this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeFunction} The node function.\n\t */\n\tgetNodeFunction( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tlet nodeFunction = nodeData.nodeFunction;\n\n\t\tif ( nodeFunction === undefined ) {\n\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\n\n\t\t\tnodeData.nodeFunction = nodeFunction;\n\n\t\t}\n\n\t\treturn nodeFunction;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tsuper.generate( builder );\n\n\t\tconst nodeFunction = this.getNodeFunction( builder );\n\n\t\tconst name = nodeFunction.name;\n\t\tconst type = nodeFunction.type;\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\n\n\t\tif ( name !== '' ) {\n\n\t\t\t// use a custom property name\n\n\t\t\tnodeCode.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\n\n\t\tconst code = this.getNodeFunction( builder ).getCode( propertyName );\n\n\t\tnodeCode.code = code + '\\n';\n\n\t\tif ( output === 'property' ) {\n\n\t\t\treturn propertyName;\n\n\t\t} else {\n\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nconst nativeFn = ( code, includes = [], language = '' ) => {\n\n\tfor ( let i = 0; i < includes.length; i ++ ) {\n\n\t\tconst include = includes[ i ];\n\n\t\t// TSL Function: glslFn, wgslFn\n\n\t\tif ( typeof include === 'function' ) {\n\n\t\t\tincludes[ i ] = include.functionNode;\n\n\t\t}\n\n\t}\n\n\tconst functionNode = nodeObject( new FunctionNode( code, includes, language ) );\n\n\tconst fn = ( ...params ) => functionNode.call( ...params );\n\tfn.functionNode = functionNode;\n\n\treturn fn;\n\n};\n\nconst glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );\nconst wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );\n\n/** @module ScriptableValueNode **/\n\n/**\n * `ScriptableNode` uses this class to manage script inputs and outputs.\n *\n * @augments Node\n */\nclass ScriptableValueNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableValueNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scriptable node.\n\t *\n\t * @param {Any} [value=null] - The value.\n\t */\n\tconstructor( value = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A reference to the value.\n\t\t *\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * Depending on the type of `_value`, this property might cache parsed data.\n\t\t *\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._cache = null;\n\n\t\t/**\n\t\t * If this node represents an input, this property represents the input type.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.inputType = null;\n\n\t\t/**\n\t\t * If this node represents an output, this property represents the output type.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.outputType = null;\n\n\t\t/**\n\t\t * An event dispatcher for managing events.\n\t\t *\n\t\t * @type {EventDispatcher}\n\t\t */\n\t\tthis.events = new EventDispatcher();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isScriptableValueNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node represents an output or not.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t * @default true\n\t */\n\tget isScriptableOutputNode() {\n\n\t\treturn this.outputType !== null;\n\n\t}\n\n\tset value( val ) {\n\n\t\tif ( this._value === val ) return;\n\n\t\tif ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {\n\n\t\t\tURL.revokeObjectURL( this._cache );\n\n\t\t\tthis._cache = null;\n\n\t\t}\n\n\t\tthis._value = val;\n\n\t\tthis.events.dispatchEvent( { type: 'change' } );\n\n\t\tthis.refresh();\n\n\t}\n\n\t/**\n\t * The node's value.\n\t *\n\t * @type {Any}\n\t */\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\t/**\n\t * Dispatches the `refresh` event.\n\t */\n\trefresh() {\n\n\t\tthis.events.dispatchEvent( { type: 'refresh' } );\n\n\t}\n\n\t/**\n\t * The `value` property usually represents a node or even binary data in form of array buffers.\n\t * In this case, this method tries to return the actual value behind the complex type.\n\t *\n\t * @return {Any} The value.\n\t */\n\tgetValue() {\n\n\t\tconst value = this.value;\n\n\t\tif ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {\n\n\t\t\tthis._cache = URL.createObjectURL( new Blob( [ value.value ] ) );\n\n\t\t} else if ( value && value.value !== null && value.value !== undefined && (\n\t\t\t( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||\n\t\t\t( this.inputType === 'Number' && typeof value.value === 'number' ) ||\n\t\t\t( this.inputType === 'Vector2' && value.value.isVector2 ) ||\n\t\t\t( this.inputType === 'Vector3' && value.value.isVector3 ) ||\n\t\t\t( this.inputType === 'Vector4' && value.value.isVector4 ) ||\n\t\t\t( this.inputType === 'Color' && value.value.isColor ) ||\n\t\t\t( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||\n\t\t\t( this.inputType === 'Matrix4' && value.value.isMatrix4 )\n\t\t) ) {\n\n\t\t\treturn value.value;\n\n\t\t}\n\n\t\treturn this._cache || value;\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the value.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.value && this.value.isNode ? this.value : float();\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tif ( this.value !== null ) {\n\n\t\t\tif ( this.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tdata.value = arrayBufferToBase64( this.value );\n\n\t\t\t} else {\n\n\t\t\t\tdata.value = this.value ? this.value.toJSON( data.meta ).uuid : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdata.value = null;\n\n\t\t}\n\n\t\tdata.inputType = this.inputType;\n\t\tdata.outputType = this.outputType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tlet value = null;\n\n\t\tif ( data.value !== null ) {\n\n\t\t\tif ( data.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tvalue = base64ToArrayBuffer( data.value );\n\n\t\t\t} else if ( data.inputType === 'Texture' ) {\n\n\t\t\t\tvalue = data.meta.textures[ data.value ];\n\n\t\t\t} else {\n\n\t\t\t\tvalue = data.meta.nodes[ data.value ] || null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.inputType = data.inputType;\n\t\tthis.outputType = data.outputType;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a scriptable value node.\n *\n * @function\n * @param {Any} [value=null] - The value.\n * @returns {ScriptableValueNode}\n */\nconst scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode );\n\n/** @module ScriptableNode **/\n\n/**\n * A Map-like data structure for managing resources of scriptable nodes.\n *\n * @augments Map\n */\nclass Resources extends Map {\n\n\tget( key, callback = null, ...params ) {\n\n\t\tif ( this.has( key ) ) return super.get( key );\n\n\t\tif ( callback !== null ) {\n\n\t\t\tconst value = callback( ...params );\n\t\t\tthis.set( key, value );\n\t\t\treturn value;\n\n\t\t}\n\n\t}\n\n}\n\nclass Parameters {\n\n\tconstructor( scriptableNode ) {\n\n\t\tthis.scriptableNode = scriptableNode;\n\n\t}\n\n\tget parameters() {\n\n\t\treturn this.scriptableNode.parameters;\n\n\t}\n\n\tget layout() {\n\n\t\treturn this.scriptableNode.getLayout();\n\n\t}\n\n\tgetInputLayout( id ) {\n\n\t\treturn this.scriptableNode.getInputLayout( id );\n\n\t}\n\n\tget( name ) {\n\n\t\tconst param = this.parameters[ name ];\n\t\tconst value = param ? param.getValue() : null;\n\n\t\treturn value;\n\n\t}\n\n}\n\n/**\n * Defines the resources (e.g. namespaces) of scriptable nodes.\n *\n * @type {Resources}\n */\nconst ScriptableNodeResources = new Resources();\n\n/**\n * This type of node allows to implement nodes with custom scripts. The script\n * section is represented as an instance of `CodeNode` written with JavaScript.\n * The script itself must adhere to a specific structure.\n *\n * - main(): Executed once by default and every time `node.needsUpdate` is set.\n * - layout: The layout object defines the script's interface (inputs and outputs).\n *\n * ```js\n * ScriptableNodeResources.set( 'TSL', TSL );\n *\n * const scriptableNode = scriptable( js( `\n * \tlayout = {\n * \t\toutputType: 'node',\n * \t\telements: [\n * \t\t\t{ name: 'source', inputType: 'node' },\n * \t\t]\n * \t};\n *\n * \tconst { mul, oscSine } = TSL;\n *\n * \tfunction main() {\n * \t\tconst source = parameters.get( 'source' ) || float();\n * \t\treturn mul( source, oscSine() ) );\n * \t}\n *\n * ` ) );\n *\n * scriptableNode.setParameter( 'source', color( 1, 0, 0 ) );\n *\n * const material = new THREE.MeshBasicNodeMaterial();\n * material.colorNode = scriptableNode;\n * ```\n *\n * @augments Node\n */\nclass ScriptableNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scriptable node.\n\t *\n\t * @param {CodeNode?} [codeNode=null] - The code node.\n\t * @param {Object} [parameters={}] - The parameters definition.\n\t */\n\tconstructor( codeNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The code node.\n\t\t *\n\t\t * @type {CodeNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.codeNode = codeNode;\n\n\t\t/**\n\t\t * The parameters definition.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default {}\n\t\t */\n\t\tthis.parameters = parameters;\n\n\t\tthis._local = new Resources();\n\t\tthis._output = scriptableValue();\n\t\tthis._outputs = {};\n\t\tthis._source = this.source;\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\n\t\tthis.onRefresh = this.onRefresh.bind( this );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isScriptableNode = true;\n\n\t}\n\n\t/**\n\t * The source code of the scriptable node.\n\t *\n\t * @type {String}\n\t */\n\tget source() {\n\n\t\treturn this.codeNode ? this.codeNode.code : '';\n\n\t}\n\n\t/**\n\t * Sets the reference of a local script variable.\n\t *\n\t * @param {String} name - The variable name.\n\t * @param {Object} value - The reference to set.\n\t * @return {Resources} The resource map\n\t */\n\tsetLocal( name, value ) {\n\n\t\treturn this._local.set( name, value );\n\n\t}\n\n\t/**\n\t * Gets the value of a local script variable.\n\t *\n\t * @param {String} name - The variable name.\n\t * @return {Object} The value.\n\t */\n\tgetLocal( name ) {\n\n\t\treturn this._local.get( name );\n\n\t}\n\n\t/**\n\t * Event listener for the `refresh` event.\n\t */\n\tonRefresh() {\n\n\t\tthis._refresh();\n\n\t}\n\n\t/**\n\t * Returns an input from the layout with the given id/name.\n\t *\n\t * @param {String} id - The id/name of the input.\n\t * @return {Object} The element entry.\n\t */\n\tgetInputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.inputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns an output from the layout with the given id/name.\n\t *\n\t * @param {String} id - The id/name of the output.\n\t * @return {Object} The element entry.\n\t */\n\tgetOutputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.outputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines a script output for the given name and value.\n\t *\n\t * @param {String} name - The name of the output.\n\t * @param {Node} value - The node value.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tsetOutput( name, value ) {\n\n\t\tconst outputs = this._outputs;\n\n\t\tif ( outputs[ name ] === undefined ) {\n\n\t\t\toutputs[ name ] = scriptableValue( value );\n\n\t\t} else {\n\n\t\t\toutputs[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a script output for the given name.\n\t *\n\t * @param {String} name - The name of the output.\n\t * @return {ScriptableValueNode} The node value.\n\t */\n\tgetOutput( name ) {\n\n\t\treturn this._outputs[ name ];\n\n\t}\n\n\t/**\n\t * Returns a parameter for the given name\n\t *\n\t * @param {String} name - The name of the parameter.\n\t * @return {ScriptableValueNode} The node value.\n\t */\n\tgetParameter( name ) {\n\n\t\treturn this.parameters[ name ];\n\n\t}\n\n\t/**\n\t * Sets a value for the given parameter name.\n\t *\n\t * @param {String} name - The parameter name.\n\t * @param {Any} value - The parameter value.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tsetParameter( name, value ) {\n\n\t\tconst parameters = this.parameters;\n\n\t\tif ( value && value.isScriptableNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( value && value.isScriptableValueNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( parameters[ name ] === undefined ) {\n\n\t\t\tparameters[ name ] = scriptableValue( value );\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else {\n\n\t\t\tparameters[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the value of this node which is the value of\n\t * the default output.\n\t *\n\t * @return {Node} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.getDefaultOutput().getValue();\n\n\t}\n\n\t/**\n\t * Deletes a parameter from the script.\n\t *\n\t * @param {String} name - The parameter to remove.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tdeleteParameter( name ) {\n\n\t\tlet valueNode = this.parameters[ name ];\n\n\t\tif ( valueNode ) {\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.removeEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes all parameters from the script.\n\t *\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tclearParameters() {\n\n\t\tfor ( const name of Object.keys( this.parameters ) ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Calls a function from the script.\n\t *\n\t * @param {String} name - The function name.\n\t * @param {...Any} params - A list of parameters.\n\t * @return {Any} The result of the function call.\n\t */\n\tcall( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method( ...params );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Asynchronously calls a function from the script.\n\t *\n\t * @param {String} name - The function name.\n\t * @param {...Any} params - A list of parameters.\n\t * @return {Promise<Any>} The result of the function call.\n\t */\n\tasync callAsync( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten since the node types is inferred from the script's output.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.getDefaultOutputNode().getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Refreshes the script node.\n\t *\n\t * @param {String?} [output=null] - An optional output.\n\t */\n\trefresh( output = null ) {\n\n\t\tif ( output !== null ) {\n\n\t\t\tthis.getOutput( output ).refresh();\n\n\t\t} else {\n\n\t\t\tthis._refresh();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns an object representation of the script.\n\t *\n\t * @return {Object} The result object.\n\t */\n\tgetObject() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._object !== null ) return this._object;\n\n\t\t//\n\n\t\tconst refresh = () => this.refresh();\n\t\tconst setOutput = ( id, value ) => this.setOutput( id, value );\n\n\t\tconst parameters = new Parameters( this );\n\n\t\tconst THREE = ScriptableNodeResources.get( 'THREE' );\n\t\tconst TSL = ScriptableNodeResources.get( 'TSL' );\n\n\t\tconst method = this.getMethod();\n\t\tconst params = [ parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL ];\n\n\t\tthis._object = method( ...params );\n\n\t\tconst layout = this._object.layout;\n\n\t\tif ( layout ) {\n\n\t\t\tif ( layout.cache === false ) {\n\n\t\t\t\tthis._local.clear();\n\n\t\t\t}\n\n\t\t\t// default output\n\t\t\tthis._output.outputType = layout.outputType || null;\n\n\t\t\tif ( Array.isArray( layout.elements ) ) {\n\n\t\t\t\tfor ( const element of layout.elements ) {\n\n\t\t\t\t\tconst id = element.id || element.name;\n\n\t\t\t\t\tif ( element.inputType ) {\n\n\t\t\t\t\t\tif ( this.getParameter( id ) === undefined ) this.setParameter( id, null );\n\n\t\t\t\t\t\tthis.getParameter( id ).inputType = element.inputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( element.outputType ) {\n\n\t\t\t\t\t\tif ( this.getOutput( id ) === undefined ) this.setOutput( id, null );\n\n\t\t\t\t\t\tthis.getOutput( id ).outputType = element.outputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this._object;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tfor ( const name in this.parameters ) {\n\n\t\t\tlet valueNode = this.parameters[ name ];\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the layout of the script.\n\t *\n\t * @return {Object} The script's layout.\n\t */\n\tgetLayout() {\n\n\t\treturn this.getObject().layout;\n\n\t}\n\n\t/**\n\t * Returns default node output of the script.\n\t *\n\t * @return {Node} The default node output.\n\t */\n\tgetDefaultOutputNode() {\n\n\t\tconst output = this.getDefaultOutput().value;\n\n\t\tif ( output && output.isNode ) {\n\n\t\t\treturn output;\n\n\t\t}\n\n\t\treturn float();\n\n\t}\n\n\t/**\n\t * Returns default output of the script.\n\t *\n\t * @return {ScriptableValueNode} The default output.\n\t */\n\tgetDefaultOutput()\t{\n\n\t\treturn this._exec()._output;\n\n\t}\n\n\t/**\n\t * Returns a function created from the node's script.\n\t *\n\t * @return {Function} The function representing the node's code.\n\t */\n\tgetMethod() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._method !== null ) return this._method;\n\n\t\t//\n\n\t\tconst parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];\n\t\tconst interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];\n\n\t\tconst properties = interfaceProps.join( ', ' );\n\t\tconst declarations = 'var ' + properties + '; var output = {};\\n';\n\t\tconst returns = '\\nreturn { ...output, ' + properties + ' };';\n\n\t\tconst code = declarations + this.codeNode.code + returns;\n\n\t\t//\n\n\t\tthis._method = new Function( ...parametersProps, code );\n\n\t\treturn this._method;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tif ( this._method === null ) return;\n\n\t\tif ( this._object && typeof this._object.dispose === 'function' ) {\n\n\t\t\tthis._object.dispose();\n\n\t\t}\n\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._source = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\t\tthis._output.value = null;\n\t\tthis._outputs = {};\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.getDefaultOutputNode();\n\n\t}\n\n\tgetCacheKey( force ) {\n\n\t\tconst values = [ hashString( this.source ), this.getDefaultOutputNode().getCacheKey( force ) ];\n\n\t\tfor ( const param in this.parameters ) {\n\n\t\t\tvalues.push( this.parameters[ param ].getCacheKey( force ) );\n\n\t\t}\n\n\t\treturn hashArray( values );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.dispose();\n\n\t}\n\n\tget needsUpdate() {\n\n\t\treturn this.source !== this._source;\n\n\t}\n\n\t/**\n\t * Executes the `main` function of the script.\n\t *\n\t * @private\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\t_exec()\t{\n\n\t\tif ( this.codeNode === null ) return this;\n\n\t\tif ( this._needsOutputUpdate === true ) {\n\n\t\t\tthis._value = this.call( 'main' );\n\n\t\t\tthis._needsOutputUpdate = false;\n\n\t\t}\n\n\t\tthis._output.value = this._value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Executes the refresh.\n\t *\n\t * @private\n\t */\n\t_refresh() {\n\n\t\tthis.needsUpdate = true;\n\n\t\tthis._exec();\n\n\t\tthis._output.refresh();\n\n\t}\n\n}\n\n/**\n * TSL function for creating a scriptable node.\n *\n * @function\n * @param {CodeNode?} [codeNode=null] - The code node.\n * @param {Object} [parameters={}] - The parameters definition.\n * @returns {ScriptableNode}\n */\nconst scriptable = /*@__PURE__*/ nodeProxy( ScriptableNode );\n\n/** @module Fog **/\n\n/**\n * Returns a node that represents the `z` coordinate in view space\n * for the current fragment. It's a different representation of the\n * default depth value.\n *\n * This value can be part of a computation that defines how the fog\n * density increases when moving away from the camera.\n *\n * @param {NodeBuilder} builder - The current node builder.\n * @return {Node} The viewZ node.\n */\nfunction getViewZNode( builder ) {\n\n\tlet viewZ;\n\n\tconst getViewZ = builder.context.getViewZ;\n\n\tif ( getViewZ !== undefined ) {\n\n\t\tviewZ = getViewZ( this );\n\n\t}\n\n\treturn ( viewZ || positionView.z ).negate();\n\n}\n\n/**\n * Constructs a new range factor node.\n *\n * @function\n * @param {Node} near - Defines the near value.\n * @param {Node} far - Defines the far value.\n */\nconst rangeFogFactor = Fn( ( [ near, far ], builder ) => {\n\n\tconst viewZ = getViewZNode( builder );\n\n\treturn smoothstep( near, far, viewZ );\n\n} );\n\n/**\n * Represents an exponential squared fog. This type of fog gives\n * a clear view near the camera and a faster than exponentially\n * densening fog farther from the camera.\n *\n * @function\n * @param {Node} density - Defines the fog density.\n */\nconst densityFogFactor = Fn( ( [ density ], builder ) => {\n\n\tconst viewZ = getViewZNode( builder );\n\n\treturn density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();\n\n} );\n\n/**\n * This class can be used to configure a fog for the scene.\n * Nodes of this type are assigned to `Scene.fogNode`.\n *\n * @function\n * @param {Node} color - Defines the color of the fog.\n * @param {Node} factor - Defines how the fog is factored in the scene.\n */\nconst fog = Fn( ( [ color, factor ] ) => {\n\n\treturn vec4( factor.toFloat().mix( output.rgb, color.toVec3() ), output.a );\n\n} );\n\n// Deprecated\n\n/**\n * @function\n * @deprecated since r171. Use `fog( color, rangeFogFactor( near, far ) )` instead.\n *\n * @param {Node} color\n * @param {Node} near\n * @param {Node} far\n * @returns {Function}\n */\nfunction rangeFog( color, near, far ) { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"rangeFog( color, near, far )\" is deprecated. Use \"fog( color, rangeFogFactor( near, far ) )\" instead.' );\n\treturn fog( color, rangeFogFactor( near, far ) );\n\n}\n\n/**\n * @function\n * @deprecated since r171. Use `fog( color, densityFogFactor( density ) )` instead.\n *\n * @param {Node} color\n * @param {Node} density\n * @returns {Function}\n */\nfunction densityFog( color, density ) { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"densityFog( color, density )\" is deprecated. Use \"fog( color, densityFogFactor( density ) )\" instead.' );\n\treturn fog( color, densityFogFactor( density ) );\n\n}\n\n/** @module RangeNode **/\n\nlet min = null;\nlet max = null;\n\n/**\n * `RangeNode` generates random instanced attribute data in a defined range.\n * An exemplary use case for this utility node is to generate random per-instance\n * colors:\n * ```js\n * const material = new MeshBasicNodeMaterial();\n * material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );\n * const mesh = new InstancedMesh( geometry, material, count );\n * ```\n * @augments Node\n */\nclass RangeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RangeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new range node.\n\t *\n\t * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n\t * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n\t */\n\tconstructor( minNode = float(), maxNode = float() ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t *  A node defining the lower bound of the range.\n\t\t *\n\t\t * @type {Node<any>}\n\t\t * @default float()\n\t\t */\n\t\tthis.minNode = minNode;\n\n\t\t/**\n\t\t *  A node defining the upper bound of the range.\n\t\t *\n\t\t * @type {Node<any>}\n\t\t * @default float()\n\t\t */\n\t\tthis.maxNode = maxNode;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the range definition.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Number} The vector length.\n\t */\n\tgetVectorLength( builder ) {\n\n\t\tconst minLength = builder.getTypeLength( getValueType( this.minNode.value ) );\n\t\tconst maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );\n\n\t\treturn minLength > maxLength ? minLength : maxLength;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from range definition.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\tlet output = null;\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\tconst minValue = this.minNode.value;\n\t\t\tconst maxValue = this.maxNode.value;\n\n\t\t\tconst minLength = builder.getTypeLength( getValueType( minValue ) );\n\t\t\tconst maxLength = builder.getTypeLength( getValueType( maxValue ) );\n\n\t\t\tmin = min || new Vector4();\n\t\t\tmax = max || new Vector4();\n\n\t\t\tmin.setScalar( 0 );\n\t\t\tmax.setScalar( 0 );\n\n\t\t\tif ( minLength === 1 ) min.setScalar( minValue );\n\t\t\telse if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b, 1 );\n\t\t\telse min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );\n\n\t\t\tif ( maxLength === 1 ) max.setScalar( maxValue );\n\t\t\telse if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b, 1 );\n\t\t\telse max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );\n\n\t\t\tconst stride = 4;\n\n\t\t\tconst length = stride * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst index = i % stride;\n\n\t\t\t\tconst minElementValue = min.getComponent( index );\n\t\t\t\tconst maxElementValue = max.getComponent( index );\n\n\t\t\t\tarray[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );\n\n\t\t\t}\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( object.count <= 4096 ) {\n\n\t\t\t\toutput = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: Improve anonymous buffer attribute creation removing this part\n\t\t\t\tconst bufferAttribute = new InstancedBufferAttribute( array, 4 );\n\t\t\t\tbuilder.geometry.setAttribute( '__range' + this.id, bufferAttribute );\n\n\t\t\t\toutput = instancedBufferAttribute( bufferAttribute ).convert( nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a range node.\n *\n * @function\n * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n * @returns {RangeNode}\n */\nconst range = /*@__PURE__*/ nodeProxy( RangeNode );\n\n/** @module ComputeBuiltinNode **/\n\n/**\n * `ComputeBuiltinNode` represents a compute-scope builtin value that expose information\n * about the currently running dispatch and/or the device it is running on.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass ComputeBuiltinNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeBuiltinNode';\n\n\t}\n\n\t/**\n\t * Constructs a new compute builtin node.\n\t *\n\t * @param {String} builtinName - The built-in name.\n\t * @param {String} nodeType - The node type.\n\t */\n\tconstructor( builtinName, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The built-in name.\n\t\t *\n\t\t * @private\n\t\t * @type {String}\n\t\t */\n\t\tthis._builtinName = builtinName;\n\n\t}\n\n\t/**\n\t * This method is overwritten since hash is derived from the built-in name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\treturn this.getBuiltinName( builder );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is simply derived from `nodeType`..\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Sets the builtin name.\n\t *\n\t * @param {String} builtinName - The built-in name.\n\t * @return {ComputeBuiltinNode} A reference to this node.\n\t */\n\tsetBuiltinName( builtinName ) {\n\n\t\tthis._builtinName = builtinName;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the builtin name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The builtin name.\n\t */\n\tgetBuiltinName( /*builder*/ ) {\n\n\t\treturn this._builtinName;\n\n\t}\n\n\t/**\n\t * Whether the current node builder has the builtin or not.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\thasBuiltin( builder ) {\n\n\t\tbuilder.hasBuiltin( this._builtinName );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst builtinName = this.getBuiltinName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( builder.shaderStage === 'compute' ) {\n\n\t\t\treturn builder.format( builtinName, nodeType, output );\n\n\t\t} else {\n\n\t\t\tconsole.warn( `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage` );\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._builtinName = this._builtinName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._builtinName = data._builtinName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a compute builtin node.\n *\n * @function\n * @param {String} name - The built-in name.\n * @param {String} nodeType - The node type.\n * @returns {ComputeBuiltinNode}\n */\nconst computeBuiltin = ( name, nodeType ) => nodeObject( new ComputeBuiltinNode( name, nodeType ) );\n\n/**\n * TSL function for creating a `numWorkgroups` builtin node.\n * Represents the number of workgroups dispatched by the compute shader.\n * ```js\n * // Run 512 invocations/threads with a workgroup size of 128.\n * const computeFn = Fn(() => {\n *\n *     // numWorkgroups.x = 4\n *     storageBuffer.element(0).assign(numWorkgroups.x)\n *\n * })().compute(512, [128]);\n *\n * // Run 512 invocations/threads with the default workgroup size of 64.\n * const computeFn = Fn(() => {\n *\n *     // numWorkgroups.x = 8\n *     storageBuffer.element(0).assign(numWorkgroups.x)\n *\n * })().compute(512);\n * ```\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst numWorkgroups = /*@__PURE__*/ computeBuiltin( 'numWorkgroups', 'uvec3' );\n\n/**\n * TSL function for creating a `workgroupId` builtin node.\n * Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.\n * ```js\n * // Execute 12 compute threads with a workgroup size of 3.\n * const computeFn = Fn( () => {\n *\n * \tIf( workgroupId.x.modInt( 2 ).equal( 0 ), () => {\n *\n * \t\tstorageBuffer.element( instanceIndex ).assign( instanceIndex );\n *\n * \t} ).Else( () => {\n *\n * \t\tstorageBuffer.element( instanceIndex ).assign( 0 );\n *\n * \t} );\n *\n * } )().compute( 12, [ 3 ] );\n *\n * // workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];\n * // Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];\n * ```\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst workgroupId = /*@__PURE__*/ computeBuiltin( 'workgroupId', 'uvec3' );\n\n/**\n * TSL function for creating a `globalId` builtin node. A non-linearized 3-dimensional\n * representation of the current invocation's position within a 3D global grid.\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst globalId = /*@__PURE__*/ computeBuiltin( 'globalId', 'uvec3' );\n/**\n * TSL function for creating a `localId` builtin node. A non-linearized 3-dimensional\n * representation of the current invocation's position within a 3D workgroup grid.\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst localId = /*@__PURE__*/ computeBuiltin( 'localId', 'uvec3' );\n\n/**\n * TSL function for creating a `subgroupSize` builtin node. A device dependent variable\n * that exposes the size of the current invocation's subgroup.\n *\n * @function\n * @returns {ComputeBuiltinNode<uint>}\n */\nconst subgroupSize = /*@__PURE__*/ computeBuiltin( 'subgroupSize', 'uint' );\n\n/** @module BarrierNode **/\n\n/**\n * Represents a GPU control barrier that synchronizes compute operations within a given scope.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass BarrierNode extends Node {\n\n\t/**\n\t * Constructs a new barrier node.\n\t *\n\t * @param {String} scope - The scope defines the behavior of the node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tbuilder.addFlowCode( `\\t// ${scope}Barrier \\n` );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( `${scope}Barrier()`, this );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a barrier node.\n *\n * @function\n * @param {String} scope - The scope defines the behavior of the node..\n * @returns {BarrierNode}\n */\nconst barrier = nodeProxy( BarrierNode );\n\n/**\n * TSL function for creating a workgroup barrier. All compute shader\n * invocations must wait for each invocation within a workgroup to\n * complete before the barrier can be surpassed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst workgroupBarrier = () => barrier( 'workgroup' ).append();\n\n/**\n * TSL function for creating a storage barrier. All invocations must\n * wait for each access to variables within the 'storage' address space\n * to complete before the barrier can be passed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst storageBarrier = () => barrier( 'storage' ).append();\n\n/**\n * TSL function for creating a texture barrier. All invocations must\n * wait for each access to variables within the 'texture' address space\n * to complete before the barrier can be passed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst textureBarrier = () => barrier( 'texture' ).append();\n\n/** @module WorkgroupInfoNode **/\n\n/**\n * Represents an element of a 'workgroup' scoped buffer.\n *\n * @augments ArrayElementNode\n */\nclass WorkgroupInfoElementNode extends ArrayElementNode {\n\n\t/**\n\t * Constructs a new workgroup info element node.\n\t *\n\t * @param {Node} workgroupInfoNode - The workgroup info node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( workgroupInfoNode, indexNode ) {\n\n\t\tsuper( workgroupInfoNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWorkgroupInfoElementNode = true;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\t\tsnippet = super.generate( builder );\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\t// TODO: Possibly activate clip distance index on index access rather than from clipping context\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * A node allowing the user to create a 'workgroup' scoped buffer within the\n * context of a compute shader. Typically, workgroup scoped buffers are\n * created to hold data that is transferred from a global storage scope into\n * a local workgroup scope. For invocations within a workgroup, data\n * access speeds on 'workgroup' scoped buffers can be significantly faster\n * than similar access operations on globally accessible storage buffers.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass WorkgroupInfoNode extends Node {\n\n\t/**\n\t * Constructs a new buffer scoped to type scope.\n\t *\n\t * @param {String} scope - TODO.\n\t * @param {String} bufferType - The data type of a 'workgroup' scoped buffer element.\n\t * @param {Number} [bufferCount=0] - The number of elements in the buffer.\n\t */\n\tconstructor( scope, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( bufferType );\n\n\t\t/**\n\t\t * The buffer type.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The buffer count.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferCount = bufferCount;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWorkgroupInfoNode = true;\n\n\t\t/**\n\t\t * The data type of the array buffer.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.elementType = bufferType;\n\n\t\t/**\n\t\t * TODO.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Sets the name/label of this node.\n\t *\n\t * @param {String} name - The name to set.\n\t * @return {WorkgroupInfoNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the scope of this node.\n\t *\n\t * @param {String} scope - The scope to set.\n\t * @return {WorkgroupInfoNode} A reference to this node.\n\t */\n\tsetScope( scope ) {\n\n\t\tthis.scope = scope;\n\n\t\treturn this;\n\n\t}\n\n\n\t/**\n\t * The data type of the array buffer.\n\t *\n\t * @return {String} The element type.\n\t */\n\tgetElementType() {\n\n\t\treturn this.elementType;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation since the input type\n\t * is inferred from the scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn `${this.scope}Array`;\n\n\t}\n\n\t/**\n\t * This method can be used to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {WorkgroupInfoElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new WorkgroupInfoElementNode( this, indexNode ) );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn builder.getScopedArray( this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a workgroup info node.\n * Creates a new 'workgroup' scoped array buffer.\n *\n * @function\n * @param {String} type - The data type of a 'workgroup' scoped buffer element.\n * @param {Number} [count=0] - The number of elements in the buffer.\n * @returns {WorkgroupInfoNode}\n */\nconst workgroupArray = ( type, count ) => nodeObject( new WorkgroupInfoNode( 'Workgroup', type, count ) );\n\n/** @module AtomicFunctionNode **/\n\n/**\n * `AtomicFunctionNode` represents any function that can operate on atomic variable types\n * within a shader. In an atomic function, any modification to an atomic variable will\n * occur as an indivisible step with a defined order relative to other modifications.\n * Accordingly, even if multiple atomic functions are modifying an atomic variable at once\n * atomic operations will not interfere with each other.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments TempNode\n */\nclass AtomicFunctionNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AtomicFunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new atomic function node.\n\t *\n\t * @param {String} method - The signature of the atomic function to construct.\n\t * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n\t * @param {Node} valueNode - The value that mutates the atomic variable.\n\t * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n\t */\n\tconstructor( method, pointerNode, valueNode, storeNode = null ) {\n\n\t\tsuper( 'uint' );\n\n\t\t/**\n\t\t * The signature of the atomic function to construct.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * An atomic variable or element of an atomic buffer.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.pointerNode = pointerNode;\n\n\t\t/**\n\t\t * A value that modifies the atomic variable.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.storeNode = storeNode;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return the type of\n\t * the pointer node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.pointerNode.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the input type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.getInputType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.pointerNode;\n\t\tconst b = this.valueNode;\n\n\t\tconst params = [];\n\n\t\tparams.push( `&${ a.build( builder, inputType ) }` );\n\n\t\tif ( b !== null ) {\n\n\t\t\tparams.push( b.build( builder, inputType ) );\n\n\n\t\t}\n\n\t\tconst methodSnippet = `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tconst varSnippet = this.storeNode.build( builder, inputType );\n\n\t\t\tbuilder.addLineFlowCode( `${varSnippet} = ${methodSnippet}`, this );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( methodSnippet, this );\n\n\t\t}\n\n\t}\n\n}\n\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\n\n/**\n * TSL function for creating an atomic function node.\n *\n * @function\n * @param {String} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicNode = nodeProxy( AtomicFunctionNode );\n\n/**\n * TSL function for appending an atomic function call into the programmatic flow of a compute shader.\n *\n * @function\n * @param {String} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicFunc = ( method, pointerNode, valueNode, storeNode = null ) => {\n\n\tconst node = atomicNode( method, pointerNode, valueNode, storeNode );\n\tnode.append();\n\n\treturn node;\n\n};\n\n/**\n * Loads the value stored in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicLoad = ( pointerNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null, storeNode );\n\n/**\n * Stores a value in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicStore = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode );\n\n/**\n * Increments the value stored in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicAdd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode );\n\n/**\n * Decrements the value stored in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicSub = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the maximum between its current value and a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicMax = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the minimum between its current value and a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicMin = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the bitwise AND of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicAnd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the bitwise OR of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicOr = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the bitwise XOR of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicXor = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode );\n\n/** @module Lights **/\n\nlet uniformsLib;\n\nfunction getLightData( light ) {\n\n\tuniformsLib = uniformsLib || new WeakMap();\n\n\tlet uniforms = uniformsLib.get( light );\n\n\tif ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );\n\n\treturn uniforms;\n\n}\n\n/**\n * TSL function for getting a shadow matrix uniform node for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<mat4>} The shadow matrix uniform node.\n */\nfunction lightShadowMatrix( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\tif ( light.castShadow !== true ) {\n\n\t\t\tlight.shadow.updateMatrices( light );\n\n\t\t}\n\n\t\treturn light.shadow.matrix;\n\n\t} ) );\n\n}\n\n/**\n * TSL function for getting projected uv coordinates for the given light.\n * Relevant when using maps with spot lights.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {Node<vec3>} The projected uvs.\n */\nfunction lightProjectionUV( light ) {\n\n\tconst data = getLightData( light );\n\n\tif ( data.projectionUV === undefined ) {\n\n\t\tconst spotLightCoord = lightShadowMatrix( light ).mul( positionWorld );\n\n\t\tdata.projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );\n\n\n\t}\n\n\treturn data.projectionUV;\n\n}\n\n/**\n * TSL function for getting the position in world space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light's position in world space.\n */\nfunction lightPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );\n\n}\n\n/**\n * TSL function for getting the light target position in world space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light target position in world space.\n */\nfunction lightTargetPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );\n\n}\n\n/**\n * TSL function for getting the position in view space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light's position in view space.\n */\nfunction lightViewPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {\n\n\t\tself.value = self.value || new Vector3();\n\t\tself.value.setFromMatrixPosition( light.matrixWorld );\n\n\t\tself.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t} ) );\n\n}\n\n/**\n * TSL function for getting the light target direction for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {Node<vec3>} The light's target direction.\n */\nconst lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );\n\n/** @module LightsNode **/\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nconst getLightNodeById = ( id, lightNodes ) => {\n\n\tfor ( const lightNode of lightNodes ) {\n\n\t\tif ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {\n\n\t\t\treturn lightNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\nconst _lightsNodeRef = /*@__PURE__*/ new WeakMap();\n\n/**\n * This node represents the scene's lighting and manages the lighting model's life cycle\n * for the current build 3D object. It is responsible for computing the total outgoing\n * light in a given lighting context.\n *\n * @augments Node\n */\nclass LightsNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightsNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lights node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * A node representing the total diffuse light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.totalDiffuseNode = vec3().toVar( 'totalDiffuse' );\n\n\t\t/**\n\t\t * A node representing the total specular light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.totalSpecularNode = vec3().toVar( 'totalSpecular' );\n\n\t\t/**\n\t\t * A node representing the outgoing light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.outgoingLightNode = vec3().toVar( 'outgoingLight' );\n\n\t\t/**\n\t\t * An array representing the lights in the scene.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Light>}\n\t\t */\n\t\tthis._lights = [];\n\n\t\t/**\n\t\t * For each light in the scene, this node will create a\n\t\t * corresponding light node.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<LightingNode>?}\n\t\t * @default null\n\t\t */\n\t\tthis._lightNodes = null;\n\n\t\t/**\n\t\t * A hash for identifying the current light nodes setup.\n\t\t *\n\t\t * @private\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis._lightNodesHash = null;\n\n\t\t/**\n\t\t * `LightsNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default {@link Node#customCacheKey} implementation by including the\n\t * light IDs into the cache key.\n\t *\n\t * @return {Number} The custom cache key.\n\t */\n\tcustomCacheKey() {\n\n\t\tconst lightIDs = [];\n\t\tconst lights = this._lights;\n\n\t\tfor ( let i = 0; i < lights.length; i ++ ) {\n\n\t\t\tlightIDs.push( lights[ i ].id );\n\n\t\t}\n\n\t\treturn hashArray( lightIDs );\n\n\t}\n\n\t/**\n\t * Computes a hash value for identifying the current light nodes setup.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {String} The computed hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this._lightNodesHash === null ) {\n\n\t\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\t\tconst hash = [];\n\n\t\t\tfor ( const lightNode of this._lightNodes ) {\n\n\t\t\t\thash.push( lightNode.getSelf().getHash() );\n\n\t\t\t}\n\n\t\t\tthis._lightNodesHash = 'lights-' + hash.join( ',' );\n\n\t\t}\n\n\t\treturn this._lightNodesHash;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst properties = builder.getDataFromNode( this );\n\n\t\tfor ( const node of properties.nodes ) {\n\n\t\t\tnode.build( builder );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates lighting nodes for each scene light. This makes it possible to further\n\t * process lights in the node system.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t */\n\tsetupLightsNode( builder ) {\n\n\t\tconst lightNodes = [];\n\n\t\tconst previousLightNodes = this._lightNodes;\n\n\t\tconst lights = sortLights( this._lights );\n\t\tconst nodeLibrary = builder.renderer.library;\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tif ( light.isNode ) {\n\n\t\t\t\tlightNodes.push( nodeObject( light ) );\n\n\t\t\t} else {\n\n\t\t\t\tlet lightNode = null;\n\n\t\t\t\tif ( previousLightNodes !== null ) {\n\n\t\t\t\t\tlightNode = getLightNodeById( light.id, previousLightNodes ); // reuse existing light node\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightNode === null ) {\n\n\t\t\t\t\t// find the corresponding node type for a given light\n\n\t\t\t\t\tconst lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );\n\n\t\t\t\t\tif ( lightNodeClass === null ) {\n\n\t\t\t\t\t\tconsole.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet lightNode = null;\n\n\t\t\t\t\tif ( ! _lightsNodeRef.has( light ) ) {\n\n\t\t\t\t\t\tlightNode = nodeObject( new lightNodeClass( light ) );\n\t\t\t\t\t\t_lightsNodeRef.set( light, lightNode );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlightNode = _lightsNodeRef.get( light );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlightNodes.push( lightNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._lightNodes = lightNodes;\n\n\t}\n\n\t/**\n\t * Setups the internal lights by building all respective\n\t * light nodes.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.\n\t */\n\tsetupLights( builder, lightNodes ) {\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The implementation makes sure that for each light in the scene\n\t * there is a corresponding light node. By building the light nodes\n\t * and evaluating the lighting model the outgoing light is computed.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec3>} A node representing the outgoing light.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\tconst context = builder.context;\n\t\tconst lightingModel = context.lightingModel;\n\n\t\tlet outgoingLightNode = this.outgoingLightNode;\n\n\t\tif ( lightingModel ) {\n\n\t\t\tconst { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;\n\n\t\t\tcontext.outgoingLight = outgoingLightNode;\n\n\t\t\tconst stack = builder.addStack();\n\n\t\t\t//\n\n\t\t\tconst properties = builder.getDataFromNode( this );\n\t\t\tproperties.nodes = stack.nodes;\n\n\t\t\t//\n\n\t\t\tlightingModel.start( context, stack, builder );\n\n\t\t\t// lights\n\n\t\t\tthis.setupLights( builder, _lightNodes );\n\n\t\t\t//\n\n\t\t\tlightingModel.indirect( context, stack, builder );\n\n\t\t\t//\n\n\t\t\tconst { backdrop, backdropAlpha } = context;\n\t\t\tconst { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;\n\n\t\t\tlet totalDiffuse = directDiffuse.add( indirectDiffuse );\n\n\t\t\tif ( backdrop !== null ) {\n\n\t\t\t\tif ( backdropAlpha !== null ) {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdrop );\n\n\t\t\t\t}\n\n\t\t\t\tcontext.material.transparent = true;\n\n\t\t\t}\n\n\t\t\ttotalDiffuseNode.assign( totalDiffuse );\n\t\t\ttotalSpecularNode.assign( directSpecular.add( indirectSpecular ) );\n\n\t\t\toutgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );\n\n\t\t\t//\n\n\t\t\tlightingModel.finish( context, stack, builder );\n\n\t\t\t//\n\n\t\t\toutgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t/**\n\t * Configures this node with an array of lights.\n\t *\n\t * @param {Array<Light>} lights - An array of lights.\n\t * @return {LightsNode} A reference to this node.\n\t */\n\tsetLights( lights ) {\n\n\t\tthis._lights = lights;\n\n\t\tthis._lightNodes = null;\n\t\tthis._lightNodesHash = null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns an array of the scene's lights.\n\t *\n\t * @return {Array<Light>} The scene's lights.\n\t */\n\tgetLights() {\n\n\t\treturn this._lights;\n\n\t}\n\n\t/**\n\t * Whether the scene has lights or not.\n\t *\n\t * @type {Boolean}\n\t */\n\tget hasLights() {\n\n\t\treturn this._lights.length > 0;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `LightsNode` and configuring\n * it with the given array of lights.\n *\n * @function\n * @param {Array<Light>} lights - An array of lights.\n * @return {LightsNode} The created lights node.\n */\nconst lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );\n\n/** @module ShadowBaseNode **/\n\n/**\n * Base class for all shadow nodes.\n *\n * Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.\n * Lighting nodes might share the same shadow node type or use specific ones depending on\n * their requirements.\n *\n * @augments Node\n */\nclass ShadowBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow base node.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t */\n\tconstructor( light ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The shadow casting light.\n\t\t *\n\t\t * @type {Light}\n\t\t */\n\t\tthis.light = light;\n\n\t\t/**\n\t\t * Overwritten since shadows are updated by default per render.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowBaseNode = true;\n\n\t}\n\n\t/**\n\t * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.\n\t *\n\t * @param {(NodeBuilder|{Material})} object - A configuration object that must at least hold a material reference.\n\t */\n\tsetupShadowPosition( { material } ) {\n\n\t\t// Use assign inside an Fn()\n\n\t\tshadowPositionWorld.assign( material.shadowPositionNode || positionWorld );\n\n\t}\n\n\t/**\n\t * Can be called when the shadow isn't required anymore. That can happen when\n\t * a lighting node stops casting shadows by setting {@link Object3D#castShadow}\n\t * to `false`.\n\t */\n\tdispose() {\n\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t}\n\n}\n\n/**\n * TSL object that represents the vertex position in world space during the shadow pass.\n *\n * @type {Node<vec3>}\n */\nconst shadowPositionWorld = /*@__PURE__*/ vec3().toVar( 'shadowPositionWorld' );\n\n/** @module RendererUtils **/\n\n/**\n * Saves the state of the given renderer and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveRendererState( renderer, state = {} ) {\n\n\tstate.toneMapping = renderer.toneMapping;\n\tstate.toneMappingExposure = renderer.toneMappingExposure;\n\tstate.outputColorSpace = renderer.outputColorSpace;\n\tstate.renderTarget = renderer.getRenderTarget();\n\tstate.activeCubeFace = renderer.getActiveCubeFace();\n\tstate.activeMipmapLevel = renderer.getActiveMipmapLevel();\n\tstate.renderObjectFunction = renderer.getRenderObjectFunction();\n\tstate.pixelRatio = renderer.getPixelRatio();\n\tstate.mrt = renderer.getMRT();\n\tstate.clearColor = renderer.getClearColor( state.clearColor || new Color() );\n\tstate.clearAlpha = renderer.getClearAlpha();\n\tstate.autoClear = renderer.autoClear;\n\tstate.scissorTest = renderer.getScissorTest();\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given renderer and stores it into the given state object.\n * Besides, the function also resets the state of the renderer to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetRendererState( renderer, state ) {\n\n\tstate = saveRendererState( renderer, state );\n\n\trenderer.setMRT( null );\n\trenderer.setRenderObjectFunction( null );\n\trenderer.setClearColor( 0x000000, 1 );\n\trenderer.autoClear = true;\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given renderer from the given state object.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} state - The state to restore.\n */\nfunction restoreRendererState( renderer, state ) {\n\n\trenderer.toneMapping = state.toneMapping;\n\trenderer.toneMappingExposure = state.toneMappingExposure;\n\trenderer.outputColorSpace = state.outputColorSpace;\n\trenderer.setRenderTarget( state.renderTarget, state.activeCubeFace, state.activeMipmapLevel );\n\trenderer.setRenderObjectFunction( state.renderObjectFunction );\n\trenderer.setPixelRatio( state.pixelRatio );\n\trenderer.setMRT( state.mrt );\n\trenderer.setClearColor( state.clearColor, state.clearAlpha );\n\trenderer.autoClear = state.autoClear;\n\trenderer.setScissorTest( state.scissorTest );\n\n}\n\n/**\n * Saves the state of the given scene and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveSceneState( scene, state = {} ) {\n\n\tstate.background = scene.background;\n\tstate.backgroundNode = scene.backgroundNode;\n\tstate.overrideMaterial = scene.overrideMaterial;\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given scene and stores it into the given state object.\n * Besides, the function also resets the state of the scene to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetSceneState( scene, state ) {\n\n\tstate = saveSceneState( scene, state );\n\n\tscene.background = null;\n\tscene.backgroundNode = null;\n\tscene.overrideMaterial = null;\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given scene from the given state object.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} state - The state to restore.\n */\nfunction restoreSceneState( scene, state ) {\n\n\tscene.background = state.background;\n\tscene.backgroundNode = state.backgroundNode;\n\tscene.overrideMaterial = state.overrideMaterial;\n\n}\n\n/**\n * Saves the state of the given renderer and scene and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveRendererAndSceneState( renderer, scene, state = {} ) {\n\n\tstate = saveRendererState( renderer, state );\n\tstate = saveSceneState( scene, state );\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given renderer and scene and stores it into the given state object.\n * Besides, the function also resets the state of the renderer and scene to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetRendererAndSceneState( renderer, scene, state ) {\n\n\tstate = resetRendererState( renderer, state );\n\tstate = resetSceneState( scene, state );\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given renderer and scene from the given state object.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} state - The state to restore.\n */\nfunction restoreRendererAndSceneState( renderer, scene, state ) {\n\n\trestoreRendererState( renderer, state );\n\trestoreSceneState( scene, state );\n\n}\n\nvar RendererUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tresetRendererAndSceneState: resetRendererAndSceneState,\n\tresetRendererState: resetRendererState,\n\tresetSceneState: resetSceneState,\n\trestoreRendererAndSceneState: restoreRendererAndSceneState,\n\trestoreRendererState: restoreRendererState,\n\trestoreSceneState: restoreSceneState,\n\tsaveRendererAndSceneState: saveRendererAndSceneState,\n\tsaveRendererState: saveRendererState,\n\tsaveSceneState: saveSceneState\n});\n\n/** @module ShadowNode **/\n\nconst shadowMaterialLib = /*@__PURE__*/ new WeakMap();\nconst linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {\n\n\tlet dist = positionWorld.sub( position ).length();\n\tdist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );\n\tdist = dist.saturate(); // clamp to [ 0, 1 ]\n\n\treturn dist;\n\n} );\n\nconst linearShadowDistance = ( light ) => {\n\n\tconst camera = light.shadow.camera;\n\n\tconst nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );\n\tconst farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );\n\n\tconst referencePosition = objectPosition( light );\n\n\treturn linearDistance( referencePosition, nearDistance, farDistance );\n\n};\n\nconst getShadowMaterial = ( light ) => {\n\n\tlet material = shadowMaterialLib.get( light );\n\n\tif ( material === undefined ) {\n\n\t\tconst depthNode = light.isPointLight ? linearShadowDistance( light ) : null;\n\n\t\tmaterial = new NodeMaterial();\n\t\tmaterial.colorNode = vec4( 0, 0, 0, 1 );\n\t\tmaterial.depthNode = depthNode;\n\t\tmaterial.isShadowPassMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n\t\tmaterial.name = 'ShadowMaterial';\n\t\tmaterial.fog = false;\n\n\t\tshadowMaterialLib.set( light, material );\n\n\t}\n\n\treturn material;\n\n};\n\n/**\n * A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map\n * with a binary `[0,1]` result.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nconst BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {\n\n\treturn texture( depthTexture, shadowCoord.xy ).compare( shadowCoord.z );\n\n} );\n\n/**\n * A shadow filtering function performing PCF filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nconst PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {\n\n\tconst depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx0 = texelSize.x.negate().mul( radius );\n\tconst dy0 = texelSize.y.negate().mul( radius );\n\tconst dx1 = texelSize.x.mul( radius );\n\tconst dy1 = texelSize.y.mul( radius );\n\tconst dx2 = dx0.div( 2 );\n\tconst dy2 = dy0.div( 2 );\n\tconst dx3 = dx1.div( 2 );\n\tconst dy3 = dy1.div( 2 );\n\n\treturn add(\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy, shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t).mul( 1 / 17 );\n\n} );\n\n/**\n * A shadow filtering function performing PCF soft filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nconst PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {\n\n\tconst depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx = texelSize.x;\n\tconst dy = texelSize.y;\n\n\tconst uv = shadowCoord.xy;\n\tconst f = fract( uv.mul( mapSize ).add( 0.5 ) );\n\tuv.subAssign( f.mul( texelSize ) );\n\n\treturn add(\n\t\tdepthCompare( uv, shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( texelSize ), shadowCoord.z ),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tf.y\n\t\t)\n\t).mul( 1 / 9 );\n\n} );\n\n/**\n * A shadow filtering function performing VSM filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nconst VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {\n\n\tconst occlusion = float( 1 ).toVar();\n\n\tconst distribution = texture( depthTexture ).sample( shadowCoord.xy ).rg;\n\n\tconst hardShadow = step( shadowCoord.z, distribution.x );\n\n\tIf( hardShadow.notEqual( float( 1.0 ) ), () => {\n\n\t\tconst distance = shadowCoord.z.sub( distribution.x );\n\t\tconst variance = max$1( 0, distribution.y.mul( distribution.y ) );\n\t\tlet softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality\n\t\tsoftnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );\n\t\tocclusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );\n\n\t} );\n\n\treturn occlusion;\n\n} );\n\n/**\n * Represents the shader code for the first VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {\n\n\tconst mean = float( 0 ).toVar();\n\tconst squaredMean = float( 0 ).toVar();\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tconst depth = shadowPass.sample( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) ).x;\n\t\tmean.addAssign( depth );\n\t\tsquaredMean.addAssign( depth.mul( depth ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\n/**\n * Represents the shader code for the second VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {\n\n\tconst mean = float( 0 ).toVar();\n\tconst squaredMean = float( 0 ).toVar();\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tconst distribution = shadowPass.sample( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );\n\t\tmean.addAssign( distribution.x );\n\t\tsquaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\nconst _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];\n\n//\n\nlet _rendererState;\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\n\n/**\n * Represents the default shadow implementation for lighting nodes.\n *\n * @augments module:ShadowBaseNode~ShadowBaseNode\n */\nclass ShadowNode extends ShadowBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNode';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow node.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t * @param {LightShadow?} [shadow=null] - An optional light shadow.\n\t */\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * The light shadow which defines the properties light's\n\t\t * shadow.\n\t\t *\n\t\t * @type {LightShadow?}\n\t\t * @default null\n\t\t */\n\t\tthis.shadow = shadow || light.shadow;\n\n\t\t/**\n\t\t * A reference to the shadow map which is a render target.\n\t\t *\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis.shadowMap = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Render target for the\n\t\t * first VSM render pass.\n\t\t *\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmShadowMapVertical = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Render target for the\n\t\t * second VSM render pass.\n\t\t *\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Node material which\n\t\t * is used to render the first VSM pass.\n\t\t *\n\t\t * @type {NodeMaterial?}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmMaterialVertical = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Node material which\n\t\t * is used to render the second VSM pass.\n\t\t *\n\t\t * @type {NodeMaterial?}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t/**\n\t\t * A reference to the output node which defines the\n\t\t * final result of this shadow node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._node = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowNode = true;\n\n\t}\n\n\t/**\n\t * Setups the shadow filtering.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Object} inputs - A configuration object that defines the shadow filtering.\n\t * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n\t * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n\t * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n\t * @param {LightShadow} inputs.shadow - The light shadow.\n\t * @return {Node<float>} The result node of the shadow filtering.\n\t */\n\tsetupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow } ) {\n\n\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\tconst shadowNode = filterFn( { depthTexture, shadowCoord, shadow } );\n\n\t\treturn frustumTest.select( shadowNode, float( 1 ) );\n\n\t}\n\n\t/**\n\t * Setups the shadow coordinates.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n\t * @return {Node<vec3>} The shadow coordinates.\n\t */\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\tconst { shadow } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tlet shadowCoord = shadowPosition;\n\t\tlet coordZ;\n\n\t\tif ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {\n\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tcoordZ = shadowCoord.z;\n\n\t\t\tif ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tcoordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst w = shadowCoord.w;\n\t\t\tshadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z\n\n\t\t\t// The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n\t\t\t// updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n\t\t\t// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n\t\t\tconst cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );\n\t\t\tconst cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );\n\n\t\t\tcoordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );\n\n\t\t}\n\n\t\tshadowCoord = vec3(\n\t\t\tshadowCoord.x,\n\t\t\tshadowCoord.y.oneMinus(), // follow webgpu standards\n\t\t\tcoordZ.add( bias )\n\t\t);\n\n\t\treturn shadowCoord;\n\n\t}\n\n\t/**\n\t * Returns the shadow filtering function for the given shadow type.\n\t *\n\t * @param {Number} type - The shadow type.\n\t * @return {Function} The filtering function.\n\t */\n\tgetShadowFilterFn( type ) {\n\n\t\treturn _shadowFilterLib[ type ];\n\n\t}\n\n\t/**\n\t * Setups the shadow output node.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec3>} The shadow output node.\n\t */\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst { light, shadow } = this;\n\n\t\tconst shadowMapType = renderer.shadowMap.type;\n\n\t\tconst depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );\n\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\tconst shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\t\tshadowMap.depthTexture = depthTexture;\n\n\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t// VSM\n\n\t\tif ( shadowMapType === VSMShadowMap ) {\n\n\t\t\tdepthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n\t\t\tthis.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );\n\t\t\tthis.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );\n\n\t\t\tconst shadowPassVertical = texture( depthTexture );\n\t\t\tconst shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );\n\n\t\t\tconst samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\t\t\tlet material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMVertical';\n\n\t\t\tmaterial = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMHorizontal';\n\n\t\t}\n\n\t\t//\n\n\t\tconst shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );\n\t\tconst normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tconst shadowPosition = lightShadowMatrix( light ).mul( shadowPositionWorld.add( transformedNormalWorld.mul( normalBias ) ) );\n\t\tconst shadowCoord = this.setupShadowCoord( builder, shadowPosition );\n\n\t\t//\n\n\t\tconst filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;\n\n\t\tif ( filterFn === null ) {\n\n\t\t\tthrow new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );\n\n\t\t}\n\n\t\tconst shadowDepthTexture = ( shadowMapType === VSMShadowMap ) ? this.vsmShadowMapHorizontal.texture : depthTexture;\n\n\t\tconst shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow } );\n\n\t\tconst shadowColor = texture( shadowMap.texture, shadowCoord );\n\t\tconst shadowOutput = mix( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();\n\n\t\tthis.shadowMap = shadowMap;\n\t\tthis.shadow.map = shadowMap;\n\n\t\treturn shadowOutput;\n\n\t}\n\n\t/**\n\t * The implementation performs the setup of the output node. An output is only\n\t * produces if shadow mapping is globally enabled in the renderer.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {ShaderCallNodeInternal} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( builder.renderer.shadowMap.enabled === false ) return;\n\n\t\treturn Fn( () => {\n\n\t\t\tlet node = this._node;\n\n\t\t\tthis.setupShadowPosition( builder );\n\n\t\t\tif ( node === null ) {\n\n\t\t\t\tthis._node = node = this.setupShadow( builder );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.shadowNode ) { // @deprecated, r171\n\n\t\t\t\tconsole.warn( 'THREE.NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.' );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.receivedShadowNode ) {\n\n\t\t\t\tnode = builder.material.receivedShadowNode( node );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Renders the shadow. The logic of this function could be included\n\t * into {@link ShadowNode#updateShadow} however more specialized shadow\n\t * nodes might require a custom shadow map rendering. By having a\n\t * dedicated method, it's easier to overwrite the default behavior.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tshadow.updateMatrices( light );\n\n\t\tshadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\trenderer.render( scene, shadow.camera );\n\n\t}\n\n\t/**\n\t * Updates the shadow.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateShadow( frame ) {\n\n\t\tconst { shadowMap, light, shadow } = this;\n\t\tconst { renderer, scene, camera } = frame;\n\n\t\tconst shadowType = renderer.shadowMap.type;\n\n\t\tconst depthVersion = shadowMap.depthTexture.version;\n\t\tthis._depthVersionCached = depthVersion;\n\n\t\tshadow.camera.layers.mask = camera.layers.mask;\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst useVelocity = currentMRT ? currentMRT.has( 'velocity' ) : false;\n\n\t\t_rendererState = resetRendererAndSceneState( renderer, scene, _rendererState );\n\n\t\tscene.overrideMaterial = getShadowMaterial( light );\n\n\t\trenderer.setRenderObjectFunction( ( object, scene, _camera, geometry, material, group, ...params ) => {\n\n\t\t\tif ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {\n\n\t\t\t\tif ( useVelocity ) {\n\n\t\t\t\t\tgetDataFromObject( object ).useVelocity = true;\n\n\t\t\t\t}\n\n\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group );\n\n\t\t\t\trenderer.renderObject( object, scene, _camera, geometry, material, group, ...params );\n\n\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.setRenderTarget( shadowMap );\n\n\t\tthis.renderShadow( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\t// vsm blur pass\n\n\t\tif ( light.isPointLight !== true && shadowType === VSMShadowMap ) {\n\n\t\t\tthis.vsmPass( renderer );\n\n\t\t}\n\n\t\trestoreRendererAndSceneState( renderer, scene, _rendererState );\n\n\t}\n\n\t/**\n\t * For VSM additional render passes are required.\n\t *\n\t * @param {Renderer} renderer - A reference to the current renderer.\n\t */\n\tvsmPass( renderer ) {\n\n\t\tconst { shadow } = this;\n\n\t\tthis.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\t\tthis.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapVertical );\n\t\t_quadMesh.material = this.vsmMaterialVertical;\n\t\t_quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapHorizontal );\n\t\t_quadMesh.material = this.vsmMaterialHorizontal;\n\t\t_quadMesh.render( renderer );\n\n\t}\n\n\t/**\n\t * Frees the internal resources of this shadow node.\n\t */\n\tdispose() {\n\n\t\tthis.shadowMap.dispose();\n\t\tthis.shadowMap = null;\n\n\t\tif ( this.vsmShadowMapVertical !== null ) {\n\n\t\t\tthis.vsmShadowMapVertical.dispose();\n\t\t\tthis.vsmShadowMapVertical = null;\n\n\t\t\tthis.vsmMaterialVertical.dispose();\n\t\t\tthis.vsmMaterialVertical = null;\n\n\t\t}\n\n\t\tif ( this.vsmShadowMapHorizontal !== null ) {\n\n\t\t\tthis.vsmShadowMapHorizontal.dispose();\n\t\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t\tthis.vsmMaterialHorizontal.dispose();\n\t\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t}\n\n\t\tsuper.dispose();\n\n\t}\n\n\t/**\n\t * The implementation performs the update of the shadow map if necessary.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { shadow } = this;\n\n\t\tconst needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.updateShadow( frame );\n\n\t\t\tif ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {\n\n\t\t\t\tshadow.needsUpdate = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `ShadowNode`.\n *\n * @function\n * @param {Light} light - The shadow casting light.\n * @param {LightShadow} shadow - The light shadow.\n * @return {ShadowNode} The created shadow node.\n */\nconst shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );\n\n/**\n * Base class for analytic light nodes.\n *\n * @augments LightingNode\n */\nclass AnalyticLightNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AnalyticLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new analytic light node.\n\t *\n\t * @param {Light?} [light=null] - The light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light source.\n\t\t *\n\t\t * @type {Light?}\n\t\t * @default null\n\t\t */\n\t\tthis.light = light;\n\n\t\t/**\n\t\t * The light's color value.\n\t\t *\n\t\t * @type {Color}\n\t\t */\n\t\tthis.color = new Color();\n\n\t\t/**\n\t\t * The light's color node. Points to `colorNode` of the light source, if set. Otherwise\n\t\t * it creates a uniform node based on {@link AnalyticLightNode#color}.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.\n\t\t * The final color node is represented by a different node when using shadows.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.baseColorNode = null;\n\n\t\t/**\n\t\t * Represents the light's shadow.\n\t\t *\n\t\t * @type {ShadowNode?}\n   \t\t * @default null\n\t\t */\n\t\tthis.shadowNode = null;\n\n\t\t/**\n\t\t * Represents the light's shadow color.\n\t\t *\n\t\t * @type {Node?}\n   \t\t * @default null\n\t\t */\n\t\tthis.shadowColorNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isAnalyticLightNode = true;\n\n\t\t/**\n\t\t * Overwritten since analytic light nodes are updated\n\t\t * once per frame.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Overwrites the default {@link Node#customCacheKey} implementation by including the\n\t * `light.id` and `light.castShadow` into the cache key.\n\t *\n\t * @return {Number} The custom cache key.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn hash$1( this.light.id, this.light.castShadow ? 1 : 0 );\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\t/**\n\t * Setups the shadow node for this light. The method exists so concrete light classes\n\t * can setup different types of shadow nodes.\n\t *\n\t * @return {ShadowNode} The created shadow node.\n\t */\n\tsetupShadowNode() {\n\n\t\treturn shadow( this.light );\n\n\t}\n\n\t/**\n\t * Setups the shadow for this light. This method is only executed if the light\n\t * cast shadows and the current build object receives shadows. It incorporates\n\t * shadows into the lighting computation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.shadowMap.enabled === false ) return;\n\n\t\tlet shadowColorNode = this.shadowColorNode;\n\n\t\tif ( shadowColorNode === null ) {\n\n\t\t\tconst customShadowNode = this.light.shadow.shadowNode;\n\n\t\t\tlet shadowNode;\n\n\t\t\tif ( customShadowNode !== undefined ) {\n\n\t\t\t\tshadowNode = nodeObject( customShadowNode );\n\n\t\t\t} else {\n\n\t\t\t\tshadowNode = this.setupShadowNode( builder );\n\n\t\t\t}\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\tthis.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );\n\n\t\t\tthis.baseColorNode = this.colorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.colorNode = shadowColorNode;\n\n\t}\n\n\t/**\n\t * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.\n\t * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or\n\t * invocate the respective interface methods.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tthis.colorNode = this.baseColorNode || this.colorNode;\n\n\t\tif ( this.light.castShadow ) {\n\n\t\t\tif ( builder.object.receiveShadow ) {\n\n\t\t\t\tthis.setupShadow( builder );\n\n\t\t\t}\n\n\t\t} else if ( this.shadowNode !== null ) {\n\n\t\t\tthis.shadowNode.dispose();\n\t\t\tthis.shadowNode = null;\n\t\t\tthis.shadowColorNode = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The update method is used to update light uniforms per frame.\n\t * Potentially overwritten in concrete light nodes to update light\n\t * specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\n/** @module LightUtils **/\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.lightDistance - The distance of the light's position to the current fragment position.\n * @param {Node<float>} inputs.cutoffDistance - The light's cutoff distance.\n * @param {Node<float>} inputs.decayExponent - The light's decay exponent.\n * @return {Node<float>} The distance falloff.\n */\nconst getDistanceAttenuation = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { lightDistance, cutoffDistance, decayExponent } = inputs;\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\tconst distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();\n\n\treturn cutoffDistance.greaterThan( 0 ).select(\n\t\tdistanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),\n\t\tdistanceFalloff\n\t);\n\n} ); // validated\n\n/** @module PointShadowNode **/\n\nconst _clearColor$2 = /*@__PURE__*/ new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nconst cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {\n\n\tconst v = pos.toVar();\n\n\t// Number of texels to avoid at the edge of each square\n\n\tconst absV = abs( v );\n\n\t// Intersect unit cube\n\n\tconst scaleToCube = div( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );\n\tabsV.mulAssign( scaleToCube );\n\n\t// Apply scale to avoid seams\n\n\t// two texels less per square (one texel will do for NEAREST)\n\tv.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );\n\n\t// Unwrap\n\n\t// space: -1 ... 1 range for each square\n\t//\n\t// #X##\t\tdim    := ( 4 , 2 )\n\t//  # #\t\tcenter := ( 1 , 1 )\n\n\tconst planar = vec2( v.xy ).toVar();\n\n\tconst almostATexel = texelSizeY.mul( 1.5 );\n\tconst almostOne = almostATexel.oneMinus();\n\n\tIf( absV.z.greaterThanEqual( almostOne ), () => {\n\n\t\tIf( v.z.greaterThan( 0.0 ), () => {\n\n\t\t\tplanar.x.assign( sub( 4.0, v.x ) );\n\n\t\t} );\n\n\t} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signX = sign( v.x );\n\t\tplanar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );\n\n\t} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signY = sign( v.y );\n\t\tplanar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );\n\t\tplanar.y.assign( v.z.mul( signY ).sub( 2.0 ) );\n\n\t} );\n\n\t// Transform to UV space\n\n\t// scale := 0.5 / dim\n\t// translate := ( center + 0.5 ) / dim\n\treturn vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();\n\n} ).setLayout( {\n\tname: 'cubeToUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'pos', type: 'vec3' },\n\t\t{ name: 'texelSizeY', type: 'float' }\n\t]\n} );\n\nconst BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {\n\n\treturn texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );\n\n} );\n\nconst PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {\n\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\tconst offset = vec2( - 1.0, 1.0 ).mul( radius ).mul( texelSize.y );\n\n\treturn texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )\n\t\t.mul( 1.0 / 9.0 );\n\n} );\n\nconst pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {\n\n\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t// the vector from the light to the world-space position of the fragment.\n\tconst lightToPosition = shadowCoord.xyz.toVar();\n\tconst lightToPositionLength = lightToPosition.length();\n\n\tconst cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );\n\tconst cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );\n\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\tconst mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );\n\n\tconst result = float( 1.0 ).toVar();\n\n\tIf( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tconst dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?\n\t\tdp.addAssign( bias );\n\n\t\t// bd3D = base direction 3D\n\t\tconst bd3D = lightToPosition.normalize();\n\t\tconst texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );\n\n\t\t// percentage-closer filtering\n\t\tresult.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );\n\n\t} );\n\n\treturn result;\n\n} );\n\nconst _viewport = /*@__PURE__*/ new Vector4();\nconst _viewportSize = /*@__PURE__*/ new Vector2();\nconst _shadowMapSize = /*@__PURE__*/ new Vector2();\n\n\n/**\n * Represents the shadow implementation for point light nodes.\n *\n * @augments module:ShadowNode~ShadowNode\n */\nclass PointShadowNode extends ShadowNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointShadowNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point shadow node.\n\t *\n\t * @param {PointLight} light - The shadow casting point light.\n\t * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.\n\t */\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light, shadow );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return point light shadow specific\n\t * filtering functions.\n\t *\n\t * @param {Number} type - The shadow type.\n\t * @return {Function} The filtering function.\n\t */\n\tgetShadowFilterFn( type ) {\n\n\t\treturn type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation so the unaltered shadow position is used.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n\t * @return {Node<vec3>} The shadow coordinates.\n\t */\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\treturn shadowPosition;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to only use point light specific\n\t * shadow filter functions.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Object} inputs - A configuration object that defines the shadow filtering.\n\t * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n\t * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.\n\t * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n\t * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n\t * @param {LightShadow} inputs.shadow - The light shadow.\n\t * @return {Node<float>} The result node of the shadow filtering.\n\t */\n\tsetupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {\n\n\t\treturn pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation with point light specific\n\t * rendering code.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\tshadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );\n\n\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t//\n\n\t\tconst previousAutoClear = renderer.autoClear;\n\n\t\tconst previousClearColor = renderer.getClearColor( _clearColor$2 );\n\t\tconst previousClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.autoClear = false;\n\t\trenderer.setClearColor( shadow.clearColor, shadow.clearAlpha );\n\t\trenderer.clear();\n\n\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\tconst x = _viewportSize.x * viewport.x;\n\t\t\tconst y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );\n\n\t\t\t_viewport.set(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t);\n\n\t\t\tshadowMap.viewport.copy( _viewport );\n\n\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\trenderer.render( scene, shadow.camera );\n\n\t\t}\n\n\t\t//\n\n\t\trenderer.autoClear = previousAutoClear;\n\t\trenderer.setClearColor( previousClearColor, previousClearAlpha );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `PointShadowNode`.\n *\n * @function\n * @param {PointLight} light - The shadow casting point light.\n * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.\n * @return {PointShadowNode} The created point shadow node.\n */\nconst pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );\n\nconst directPointLight = Fn( ( { color, lightViewPosition, cutoffDistance, decayExponent }, builder ) => {\n\n\tconst lightingModel = builder.context.lightingModel;\n\n\tconst lVector = lightViewPosition.sub( positionView ); // @TODO: Add it into LightNode\n\n\tconst lightDirection = lVector.normalize();\n\tconst lightDistance = lVector.length();\n\n\tconst lightAttenuation = getDistanceAttenuation( {\n\t\tlightDistance,\n\t\tcutoffDistance,\n\t\tdecayExponent\n\t} );\n\n\tconst lightColor = color.mul( lightAttenuation );\n\n\tconst reflectedLight = builder.context.reflectedLight;\n\n\tlightingModel.direct( {\n\t\tlightDirection,\n\t\tlightColor,\n\t\treflectedLight\n\t}, builder.stack, builder );\n\n} );\n\n/**\n * Module for representing point lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass PointLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point light node.\n\t *\n\t * @param {PointLight?} [light=null] - The point light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the cutoff distance.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the decay exponent.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.decayExponentNode = uniform( 2 ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated point light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\t/**\n\t * Overwritten to setup point light specific shadow.\n\t *\n\t * @return {PointShadowNode}\n\t */\n\tsetupShadowNode() {\n\n\t\treturn pointShadow( this.light );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tdirectPointLight( {\n\t\t\tcolor: this.colorNode,\n\t\t\tlightViewPosition: lightViewPosition( this.light ),\n\t\t\tcutoffDistance: this.cutoffDistanceNode,\n\t\t\tdecayExponent: this.decayExponentNode\n\t\t} ).append();\n\n\t}\n\n}\n\n/** @module Procedural **/\n\n/**\n * Creates a 2x2 checkerboard pattern that can be used as procedural texture data.\n *\n * @method\n * @param {Node<vec2>} coord - The uv coordinates.\n * @return {Node<float>} The result data.\n */\nconst checker = /*@__PURE__*/ Fn( ( [ coord = uv() ] ) => {\n\n\tconst uv = coord.mul( 2.0 );\n\n\tconst cx = uv.x.floor();\n\tconst cy = uv.y.floor();\n\tconst result = cx.add( cy ).mod( 2.0 );\n\n\treturn result.sign();\n\n} );\n\n/** @module Shapes **/\n\n/**\n * Generates a circle based on the uv coordinates.\n *\n * @method\n * @param {Node<vec2>} coord - The uv to generate the circle.\n * @return {Node<float>} The circle shape.\n */\nconst shapeCircle = Fn( ( [ coord = uv() ], { renderer, material } ) => {\n\n\tconst alpha = float( 1 ).toVar();\n\tconst len2 = lengthSq( coord.mul( 2 ).sub( 1 ) );\n\n\tif ( material.alphaToCoverage && renderer.samples > 1 ) {\n\n\t\tconst dlen = float( len2.fwidth() ).toVar();\n\n\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t} else {\n\n\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t}\n\n\treturn alpha;\n\n} );\n\n// Three.js Transpiler\n// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\n\n\nconst mx_select = /*@__PURE__*/ Fn( ( [ b_immutable, t_immutable, f_immutable ] ) => {\n\n\tconst f = float( f_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst b = bool( b_immutable ).toVar();\n\n\treturn select( b, t, f );\n\n} ).setLayout( {\n\tname: 'mx_select',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'b', type: 'bool' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'f', type: 'float' }\n\t]\n} );\n\nconst mx_negate_if = /*@__PURE__*/ Fn( ( [ val_immutable, b_immutable ] ) => {\n\n\tconst b = bool( b_immutable ).toVar();\n\tconst val = float( val_immutable ).toVar();\n\n\treturn select( b, val.negate(), val );\n\n} ).setLayout( {\n\tname: 'mx_negate_if',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'val', type: 'float' },\n\t\t{ name: 'b', type: 'bool' }\n\t]\n} );\n\nconst mx_floor = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\n\treturn int( floor( x ) );\n\n} ).setLayout( {\n\tname: 'mx_floor',\n\ttype: 'int',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst mx_floorfrac = /*@__PURE__*/ Fn( ( [ x_immutable, i ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\ti.assign( mx_floor( x ) );\n\n\treturn x.sub( float( i ) );\n\n} );\n\nconst mx_bilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp = /*@__PURE__*/ overloadingFn( [ mx_bilerp_0, mx_bilerp_1 ] );\n\nconst mx_trilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = float( v7_immutable ).toVar();\n\tconst v6 = float( v6_immutable ).toVar();\n\tconst v5 = float( v5_immutable ).toVar();\n\tconst v4 = float( v4_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 'v4', type: 'float' },\n\t\t{ name: 'v5', type: 'float' },\n\t\t{ name: 'v6', type: 'float' },\n\t\t{ name: 'v7', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = vec3( v7_immutable ).toVar();\n\tconst v6 = vec3( v6_immutable ).toVar();\n\tconst v5 = vec3( v5_immutable ).toVar();\n\tconst v4 = vec3( v4_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 'v4', type: 'vec3' },\n\t\t{ name: 'v5', type: 'vec3' },\n\t\t{ name: 'v6', type: 'vec3' },\n\t\t{ name: 'v7', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp = /*@__PURE__*/ overloadingFn( [ mx_trilerp_0, mx_trilerp_1 ] );\n\nconst mx_gradient_float_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 7 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 4 ) ), x, y ) ).toVar();\n\tconst v = float( mul( 2.0, mx_select( h.lessThan( uint( 4 ) ), y, x ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 15 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 8 ) ), x, y ) ).toVar();\n\tconst v = float( mx_select( h.lessThan( uint( 4 ) ), y, mx_select( h.equal( uint( 12 ) ).or( h.equal( uint( 14 ) ) ), x, z ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float = /*@__PURE__*/ overloadingFn( [ mx_gradient_float_0, mx_gradient_float_1 ] );\n\nconst mx_gradient_vec3_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y ), mx_gradient_float( hash.y, x, y ), mx_gradient_float( hash.z, x, y ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y, z ), mx_gradient_float( hash.y, x, y, z ), mx_gradient_float( hash.z, x, y, z ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3 = /*@__PURE__*/ overloadingFn( [ mx_gradient_vec3_0, mx_gradient_vec3_1 ] );\n\nconst mx_gradient_scale2d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale3d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale2d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale2d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale2d_0, mx_gradient_scale2d_1 ] );\n\nconst mx_gradient_scale3d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale3d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale3d_0, mx_gradient_scale3d_1 ] );\n\nconst mx_rotl32 = /*@__PURE__*/ Fn( ( [ x_immutable, k_immutable ] ) => {\n\n\tconst k = int( k_immutable ).toVar();\n\tconst x = uint( x_immutable ).toVar();\n\n\treturn x.shiftLeft( k ).bitOr( x.shiftRight( int( 32 ).sub( k ) ) );\n\n} ).setLayout( {\n\tname: 'mx_rotl32',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'uint' },\n\t\t{ name: 'k', type: 'int' }\n\t]\n} );\n\nconst mx_bjmix = /*@__PURE__*/ Fn( ( [ a, b, c ] ) => {\n\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 4 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 6 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 8 ) ) );\n\tb.addAssign( a );\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 16 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 19 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 4 ) ) );\n\tb.addAssign( a );\n\n} );\n\nconst mx_bjfinal = /*@__PURE__*/ Fn( ( [ a_immutable, b_immutable, c_immutable ] ) => {\n\n\tconst c = uint( c_immutable ).toVar();\n\tconst b = uint( b_immutable ).toVar();\n\tconst a = uint( a_immutable ).toVar();\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 14 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 11 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 25 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 16 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 4 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 14 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 24 ) ) );\n\n\treturn c;\n\n} ).setLayout( {\n\tname: 'mx_bjfinal',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'a', type: 'uint' },\n\t\t{ name: 'b', type: 'uint' },\n\t\t{ name: 'c', type: 'uint' }\n\t]\n} );\n\nconst mx_bits_to_01 = /*@__PURE__*/ Fn( ( [ bits_immutable ] ) => {\n\n\tconst bits = uint( bits_immutable ).toVar();\n\n\treturn float( bits ).div( float( uint( int( 0xffffffff ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bits_to_01',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'bits', type: 'uint' }\n\t]\n} );\n\nconst mx_fade = /*@__PURE__*/ Fn( ( [ t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\n\treturn t.mul( t ).mul( t ).mul( t.mul( t.mul( 6.0 ).sub( 15.0 ) ).add( 10.0 ) );\n\n} ).setLayout( {\n\tname: 'mx_fade',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_hash_int_0 = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 1 ) ).toVar();\n\tconst seed = uint( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ).toVar();\n\n\treturn mx_bjfinal( seed.add( uint( x ) ), seed, seed );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_0',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 2 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_1',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_2 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 3 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_2',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_3 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable ] ) => {\n\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 4 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_3',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_4 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable ] ) => {\n\n\tconst yy = int( yy_immutable ).toVar();\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 5 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\tb.addAssign( uint( yy ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_4',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' },\n\t\t{ name: 'yy', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int = /*@__PURE__*/ overloadingFn( [ mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4 ] );\n\nconst mx_hash_vec3_0 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_0',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y, z ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_1',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3 = /*@__PURE__*/ overloadingFn( [ mx_hash_vec3_0, mx_hash_vec3_1 ] );\n\nconst mx_perlin_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = float( mx_bilerp( mx_gradient_float( mx_hash_int( X, Y ), fx, fy ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = float( mx_trilerp( mx_gradient_float( mx_hash_int( X, Y, Z ), fx, fy, fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_float = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_float_0, mx_perlin_noise_float_1 ] );\n\nconst mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = vec3( mx_bilerp( mx_gradient_vec3( mx_hash_vec3( X, Y ), fx, fy ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = vec3( mx_trilerp( mx_gradient_vec3( mx_hash_vec3( X, Y, Z ), fx, fy, fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1 ] );\n\nconst mx_cell_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_float_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_2',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_float_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz, iw ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_3',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3 ] );\n\nconst mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_2',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3 ] );\n\nconst mx_fractal_noise_float$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = float( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_float( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_float',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = vec3( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_vec3( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\n\treturn vec2( mx_fractal_noise_float$1( p, octaves, lacunarity, diminish ), mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec2',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst c = vec3( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) ).toVar();\n\tconst f = float( mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) ).toVar();\n\n\treturn vec4( c, f );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec4',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_worley_distance_0 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst tmp = vec3( mx_cell_noise_vec3( vec2( x.add( xoff ), y.add( yoff ) ) ) ).toVar();\n\tconst off = vec2( tmp.x, tmp.y ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec2( vec2( float( x ), float( y ) ).add( off ) ).toVar();\n\tconst diff = vec2( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( abs( diff.x ), abs( diff.y ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance_1 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst zoff = int( zoff_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst off = vec3( mx_cell_noise_vec3( vec3( x.add( xoff ), y.add( yoff ), z.add( zoff ) ) ) ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec3( vec3( float( x ), float( y ), float( z ) ).add( off ) ).toVar();\n\tconst diff = vec3( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) ).add( abs( diff.z ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( max$1( abs( diff.x ), abs( diff.y ) ), abs( diff.z ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'zoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance = /*@__PURE__*/ overloadingFn( [ mx_worley_distance_0, mx_worley_distance_1 ] );\n\nconst mx_worley_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_0',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\t\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_float_0, mx_worley_noise_float_1 ] );\n\nconst mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_1',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec2_0, mx_worley_noise_vec2_1 ] );\n\nconst mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec3_0, mx_worley_noise_vec3_1 ] );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\n\nconst mx_hsvtorgb = /*@__PURE__*/ Fn( ( [ hsv ] ) => {\n\n\tconst s = hsv.y;\n\tconst v = hsv.z;\n\n\tconst result = vec3().toVar();\n\n\tIf( s.lessThan( 0.0001 ), () => {\n\n\t\tresult.assign( vec3( v, v, v ) );\n\n\t} ).Else( () => {\n\n\t\tlet h = hsv.x;\n\t\th = h.sub( floor( h ) ).mul( 6.0 ).toVar(); // TODO: check what .toVar() is needed in node system cache\n\t\tconst hi = int( trunc( h ) );\n\t\tconst f = h.sub( float( hi ) );\n\t\tconst p = v.mul( s.oneMinus() );\n\t\tconst q = v.mul( s.mul( f ).oneMinus() );\n\t\tconst t = v.mul( s.mul( f.oneMinus() ).oneMinus() );\n\n\t\tIf( hi.equal( int( 0 ) ), () => {\n\n\t\t\tresult.assign( vec3( v, t, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 1 ) ), () => {\n\n\t\t\tresult.assign( vec3( q, v, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 2 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, v, t ) );\n\n\t\t} ).ElseIf( hi.equal( int( 3 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, q, v ) );\n\n\t\t} ).ElseIf( hi.equal( int( 4 ) ), () => {\n\n\t\t\tresult.assign( vec3( t, p, v ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tresult.assign( vec3( v, p, q ) );\n\n\t\t} );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hsvtorgb',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hsv', type: 'vec3' }\n\t]\n} );\n\nconst mx_rgbtohsv = /*@__PURE__*/ Fn( ( [ c_immutable ] ) => {\n\n\tconst c = vec3( c_immutable ).toVar();\n\tconst r = float( c.x ).toVar();\n\tconst g = float( c.y ).toVar();\n\tconst b = float( c.z ).toVar();\n\tconst mincomp = float( min$1( r, min$1( g, b ) ) ).toVar();\n\tconst maxcomp = float( max$1( r, max$1( g, b ) ) ).toVar();\n\tconst delta = float( maxcomp.sub( mincomp ) ).toVar();\n\tconst h = float().toVar(), s = float().toVar(), v = float().toVar();\n\tv.assign( maxcomp );\n\n\tIf( maxcomp.greaterThan( 0.0 ), () => {\n\n\t\ts.assign( delta.div( maxcomp ) );\n\n\t} ).Else( () => {\n\n\t\ts.assign( 0.0 );\n\n\t} );\n\n\tIf( s.lessThanEqual( 0.0 ), () => {\n\n\t\th.assign( 0.0 );\n\n\t} ).Else( () => {\n\n\t\tIf( r.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( g.sub( b ).div( delta ) );\n\n\t\t} ).ElseIf( g.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( add( 2.0, b.sub( r ).div( delta ) ) );\n\n\t\t} ).Else( () => {\n\n\t\t\th.assign( add( 4.0, r.sub( g ).div( delta ) ) );\n\n\t\t} );\n\n\t\th.mulAssign( 1.0 / 6.0 );\n\n\t\tIf( h.lessThan( 0.0 ), () => {\n\n\t\t\th.addAssign( 1.0 );\n\n\t\t} );\n\n\t} );\n\n\treturn vec3( h, s, v );\n\n} ).setLayout( {\n\tname: 'mx_rgbtohsv',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'c', type: 'vec3' }\n\t]\n} );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\n\nconst mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn( ( [ color_immutable ] ) => {\n\n\tconst color = vec3( color_immutable ).toVar();\n\tconst isAbove = bvec3( greaterThan( color, vec3( 0.04045 ) ) ).toVar();\n\tconst linSeg = vec3( color.div( 12.92 ) ).toVar();\n\tconst powSeg = vec3( pow( max$1( color.add( vec3( 0.055 ) ), vec3( 0.0 ) ).div( 1.055 ), vec3( 2.4 ) ) ).toVar();\n\n\treturn mix( linSeg, powSeg, isAbove );\n\n} ).setLayout( {\n\tname: 'mx_srgb_texture_to_lin_rec709',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst mx_aastep = ( threshold, value ) => {\n\n\tthreshold = float( threshold );\n\tvalue = float( value );\n\n\tconst afwidth = vec2( value.dFdx(), value.dFdy() ).length().mul( 0.70710678118654757 );\n\n\treturn smoothstep( threshold.sub( afwidth ), threshold.add( afwidth ), value );\n\n};\n\nconst _ramp = ( a, b, uv, p ) => mix( a, b, uv[ p ].clamp() );\nconst mx_ramplr = ( valuel, valuer, texcoord = uv() ) => _ramp( valuel, valuer, texcoord, 'x' );\nconst mx_ramptb = ( valuet, valueb, texcoord = uv() ) => _ramp( valuet, valueb, texcoord, 'y' );\n\nconst _split = ( a, b, center, uv, p ) => mix( a, b, mx_aastep( center, uv[ p ] ) );\nconst mx_splitlr = ( valuel, valuer, center, texcoord = uv() ) => _split( valuel, valuer, center, texcoord, 'x' );\nconst mx_splittb = ( valuet, valueb, center, texcoord = uv() ) => _split( valuet, valueb, center, texcoord, 'y' );\n\nconst mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv() ) => uv_geo.mul( uv_scale ).add( uv_offset );\n\nconst mx_safepower = ( in1, in2 = 1 ) => {\n\n\tin1 = float( in1 );\n\n\treturn in1.abs().pow( in2 ).mul( in1.sign() );\n\n};\n\nconst mx_contrast = ( input, amount = 1, pivot = .5 ) => float( input ).sub( pivot ).mul( amount ).add( pivot );\n\nconst mx_noise_float = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_float( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\n//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec3 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec4 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => {\n\n\ttexcoord = texcoord.convert( 'vec2|vec3' ); // overloading type\n\n\tconst noise_vec4 = vec4( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( texcoord.add( vec2( 19, 73 ) ) ) );\n\n\treturn noise_vec4.mul( amplitude ).add( pivot );\n\n};\n\nconst mx_worley_noise_float = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_float$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec2 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec2$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec3 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec3$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\n\nconst mx_cell_noise_float = ( texcoord = uv() ) => mx_cell_noise_float$1( texcoord.convert( 'vec2|vec3' ) );\n\nconst mx_fractal_noise_float = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_float$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec2 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec2$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec3 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec3$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec4 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec4$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\n\n/** @module getParallaxCorrectNormal **/\n\n/**\n * This computes a parallax corrected normal which is used for box-projected cube mapping (BPCEM).\n *\n * Reference: {@link https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html}\n *\n * ```js\n * const uvNode = getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) );\n * material.envNode = pmremTexture( renderTarget.texture, uvNode );\n * ```\n * @function\n * @param {Node<vec3>} normal - The normal to correct.\n * @param {Node<vec3>} cubeSize - The cube size should reflect the size of the environment (BPCEM is usually applied in closed environments like rooms).\n * @param {Node<vec3>} cubePos - The cube position.\n * @return {Node<vec3>} The parallax corrected normal.\n */\nconst getParallaxCorrectNormal = /*@__PURE__*/ Fn( ( [ normal, cubeSize, cubePos ] ) => {\n\n\tconst nDir = normalize( normal ).toVar( 'nDir' );\n\tconst rbmax = sub( float( 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmax' );\n\tconst rbmin = sub( float( - 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmin' );\n\tconst rbminmax = vec3().toVar( 'rbminmax' );\n\trbminmax.x = nDir.x.greaterThan( float( 0 ) ).select( rbmax.x, rbmin.x );\n\trbminmax.y = nDir.y.greaterThan( float( 0 ) ).select( rbmax.y, rbmin.y );\n\trbminmax.z = nDir.z.greaterThan( float( 0 ) ).select( rbmax.z, rbmin.z );\n\n\tconst correction = min$1( min$1( rbminmax.x, rbminmax.y ), rbminmax.z ).toVar( 'correction' );\n\tconst boxIntersection = positionWorld.add( nDir.mul( correction ) ).toVar( 'boxIntersection' );\n\treturn boxIntersection.sub( cubePos );\n\n} );\n\nconst getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {\n\n\t// normal is assumed to have unit length\n\n\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tlet result = shCoefficients.element( 0 ).mul( 0.886227 );\n\n\t// band 1\n\tresult = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );\n\n\t// band 2\n\tresult = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );\n\tresult = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );\n\n\treturn result;\n\n} );\n\n// constants\n\nvar TSL = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBRDF_GGX: BRDF_GGX,\n\tBRDF_Lambert: BRDF_Lambert,\n\tBasicShadowFilter: BasicShadowFilter,\n\tBreak: Break,\n\tConst: Const,\n\tContinue: Continue,\n\tDFGApprox: DFGApprox,\n\tD_GGX: D_GGX,\n\tDiscard: Discard,\n\tEPSILON: EPSILON,\n\tF_Schlick: F_Schlick,\n\tFn: Fn,\n\tINFINITY: INFINITY,\n\tIf: If,\n\tLoop: Loop,\n\tNodeAccess: NodeAccess,\n\tNodeShaderStage: NodeShaderStage,\n\tNodeType: NodeType,\n\tNodeUpdateType: NodeUpdateType,\n\tPCFShadowFilter: PCFShadowFilter,\n\tPCFSoftShadowFilter: PCFSoftShadowFilter,\n\tPI: PI,\n\tPI2: PI2,\n\tReturn: Return,\n\tSchlick_to_F0: Schlick_to_F0,\n\tScriptableNodeResources: ScriptableNodeResources,\n\tShaderNode: ShaderNode,\n\tTBNViewMatrix: TBNViewMatrix,\n\tVSMShadowFilter: VSMShadowFilter,\n\tV_GGX_SmithCorrelated: V_GGX_SmithCorrelated,\n\tVar: Var,\n\tabs: abs,\n\tacesFilmicToneMapping: acesFilmicToneMapping,\n\tacos: acos,\n\tadd: add,\n\taddMethodChaining: addMethodChaining,\n\taddNodeElement: addNodeElement,\n\tagxToneMapping: agxToneMapping,\n\tall: all,\n\talphaT: alphaT,\n\tand: and,\n\tanisotropy: anisotropy,\n\tanisotropyB: anisotropyB,\n\tanisotropyT: anisotropyT,\n\tany: any,\n\tappend: append,\n\tarray: array,\n\tarrayBuffer: arrayBuffer,\n\tasin: asin,\n\tassign: assign,\n\tatan: atan,\n\tatan2: atan2,\n\tatomicAdd: atomicAdd,\n\tatomicAnd: atomicAnd,\n\tatomicFunc: atomicFunc,\n\tatomicLoad: atomicLoad,\n\tatomicMax: atomicMax,\n\tatomicMin: atomicMin,\n\tatomicOr: atomicOr,\n\tatomicStore: atomicStore,\n\tatomicSub: atomicSub,\n\tatomicXor: atomicXor,\n\tattenuationColor: attenuationColor,\n\tattenuationDistance: attenuationDistance,\n\tattribute: attribute,\n\tattributeArray: attributeArray,\n\tbackgroundBlurriness: backgroundBlurriness,\n\tbackgroundIntensity: backgroundIntensity,\n\tbackgroundRotation: backgroundRotation,\n\tbatch: batch,\n\tbillboarding: billboarding,\n\tbitAnd: bitAnd,\n\tbitNot: bitNot,\n\tbitOr: bitOr,\n\tbitXor: bitXor,\n\tbitangentGeometry: bitangentGeometry,\n\tbitangentLocal: bitangentLocal,\n\tbitangentView: bitangentView,\n\tbitangentWorld: bitangentWorld,\n\tbitcast: bitcast,\n\tblendBurn: blendBurn,\n\tblendColor: blendColor,\n\tblendDodge: blendDodge,\n\tblendOverlay: blendOverlay,\n\tblendScreen: blendScreen,\n\tblur: blur,\n\tbool: bool,\n\tbuffer: buffer,\n\tbufferAttribute: bufferAttribute,\n\tbumpMap: bumpMap,\n\tburn: burn,\n\tbvec2: bvec2,\n\tbvec3: bvec3,\n\tbvec4: bvec4,\n\tbypass: bypass,\n\tcache: cache,\n\tcall: call,\n\tcameraFar: cameraFar,\n\tcameraIndex: cameraIndex,\n\tcameraNear: cameraNear,\n\tcameraNormalMatrix: cameraNormalMatrix,\n\tcameraPosition: cameraPosition,\n\tcameraProjectionMatrix: cameraProjectionMatrix,\n\tcameraProjectionMatrixInverse: cameraProjectionMatrixInverse,\n\tcameraViewMatrix: cameraViewMatrix,\n\tcameraWorldMatrix: cameraWorldMatrix,\n\tcbrt: cbrt,\n\tcdl: cdl,\n\tceil: ceil,\n\tchecker: checker,\n\tcineonToneMapping: cineonToneMapping,\n\tclamp: clamp,\n\tclearcoat: clearcoat,\n\tclearcoatRoughness: clearcoatRoughness,\n\tcode: code,\n\tcolor: color,\n\tcolorSpaceToWorking: colorSpaceToWorking,\n\tcolorToDirection: colorToDirection,\n\tcompute: compute,\n\tcond: cond,\n\tcontext: context,\n\tconvert: convert,\n\tconvertColorSpace: convertColorSpace,\n\tconvertToTexture: convertToTexture,\n\tcos: cos,\n\tcross: cross,\n\tcubeTexture: cubeTexture,\n\tdFdx: dFdx,\n\tdFdy: dFdy,\n\tdashSize: dashSize,\n\tdefaultBuildStages: defaultBuildStages,\n\tdefaultShaderStages: defaultShaderStages,\n\tdefined: defined,\n\tdegrees: degrees,\n\tdeltaTime: deltaTime,\n\tdensityFog: densityFog,\n\tdensityFogFactor: densityFogFactor,\n\tdepth: depth,\n\tdepthPass: depthPass,\n\tdifference: difference,\n\tdiffuseColor: diffuseColor,\n\tdirectPointLight: directPointLight,\n\tdirectionToColor: directionToColor,\n\tdispersion: dispersion,\n\tdistance: distance,\n\tdiv: div,\n\tdodge: dodge,\n\tdot: dot,\n\tdrawIndex: drawIndex,\n\tdynamicBufferAttribute: dynamicBufferAttribute,\n\telement: element,\n\temissive: emissive,\n\tequal: equal,\n\tequals: equals,\n\tequirectUV: equirectUV,\n\texp: exp,\n\texp2: exp2,\n\texpression: expression,\n\tfaceDirection: faceDirection,\n\tfaceForward: faceForward,\n\tfaceforward: faceforward,\n\tfloat: float,\n\tfloor: floor,\n\tfog: fog,\n\tfract: fract,\n\tframeGroup: frameGroup,\n\tframeId: frameId,\n\tfrontFacing: frontFacing,\n\tfwidth: fwidth,\n\tgain: gain,\n\tgapSize: gapSize,\n\tgetConstNodeType: getConstNodeType,\n\tgetCurrentStack: getCurrentStack,\n\tgetDirection: getDirection,\n\tgetDistanceAttenuation: getDistanceAttenuation,\n\tgetGeometryRoughness: getGeometryRoughness,\n\tgetNormalFromDepth: getNormalFromDepth,\n\tgetParallaxCorrectNormal: getParallaxCorrectNormal,\n\tgetRoughness: getRoughness,\n\tgetScreenPosition: getScreenPosition,\n\tgetShIrradianceAt: getShIrradianceAt,\n\tgetTextureIndex: getTextureIndex,\n\tgetViewPosition: getViewPosition,\n\tglobalId: globalId,\n\tglsl: glsl,\n\tglslFn: glslFn,\n\tgrayscale: grayscale,\n\tgreaterThan: greaterThan,\n\tgreaterThanEqual: greaterThanEqual,\n\thash: hash,\n\thighpModelNormalViewMatrix: highpModelNormalViewMatrix,\n\thighpModelViewMatrix: highpModelViewMatrix,\n\thue: hue,\n\tinstance: instance,\n\tinstanceIndex: instanceIndex,\n\tinstancedArray: instancedArray,\n\tinstancedBufferAttribute: instancedBufferAttribute,\n\tinstancedDynamicBufferAttribute: instancedDynamicBufferAttribute,\n\tinstancedMesh: instancedMesh,\n\tint: int,\n\tinverseSqrt: inverseSqrt,\n\tinversesqrt: inversesqrt,\n\tinvocationLocalIndex: invocationLocalIndex,\n\tinvocationSubgroupIndex: invocationSubgroupIndex,\n\tior: ior,\n\tiridescence: iridescence,\n\tiridescenceIOR: iridescenceIOR,\n\tiridescenceThickness: iridescenceThickness,\n\tivec2: ivec2,\n\tivec3: ivec3,\n\tivec4: ivec4,\n\tjs: js,\n\tlabel: label,\n\tlength: length,\n\tlengthSq: lengthSq,\n\tlessThan: lessThan,\n\tlessThanEqual: lessThanEqual,\n\tlightPosition: lightPosition,\n\tlightProjectionUV: lightProjectionUV,\n\tlightShadowMatrix: lightShadowMatrix,\n\tlightTargetDirection: lightTargetDirection,\n\tlightTargetPosition: lightTargetPosition,\n\tlightViewPosition: lightViewPosition,\n\tlightingContext: lightingContext,\n\tlights: lights,\n\tlinearDepth: linearDepth,\n\tlinearToneMapping: linearToneMapping,\n\tlocalId: localId,\n\tlog: log,\n\tlog2: log2,\n\tlogarithmicDepthToViewZ: logarithmicDepthToViewZ,\n\tloop: loop,\n\tluminance: luminance,\n\tmat2: mat2,\n\tmat3: mat3,\n\tmat4: mat4,\n\tmatcapUV: matcapUV,\n\tmaterialAO: materialAO,\n\tmaterialAlphaTest: materialAlphaTest,\n\tmaterialAnisotropy: materialAnisotropy,\n\tmaterialAnisotropyVector: materialAnisotropyVector,\n\tmaterialAttenuationColor: materialAttenuationColor,\n\tmaterialAttenuationDistance: materialAttenuationDistance,\n\tmaterialClearcoat: materialClearcoat,\n\tmaterialClearcoatNormal: materialClearcoatNormal,\n\tmaterialClearcoatRoughness: materialClearcoatRoughness,\n\tmaterialColor: materialColor,\n\tmaterialDispersion: materialDispersion,\n\tmaterialEmissive: materialEmissive,\n\tmaterialIOR: materialIOR,\n\tmaterialIridescence: materialIridescence,\n\tmaterialIridescenceIOR: materialIridescenceIOR,\n\tmaterialIridescenceThickness: materialIridescenceThickness,\n\tmaterialLightMap: materialLightMap,\n\tmaterialLineDashOffset: materialLineDashOffset,\n\tmaterialLineDashSize: materialLineDashSize,\n\tmaterialLineGapSize: materialLineGapSize,\n\tmaterialLineScale: materialLineScale,\n\tmaterialLineWidth: materialLineWidth,\n\tmaterialMetalness: materialMetalness,\n\tmaterialNormal: materialNormal,\n\tmaterialOpacity: materialOpacity,\n\tmaterialPointSize: materialPointSize,\n\tmaterialReference: materialReference,\n\tmaterialReflectivity: materialReflectivity,\n\tmaterialRefractionRatio: materialRefractionRatio,\n\tmaterialRotation: materialRotation,\n\tmaterialRoughness: materialRoughness,\n\tmaterialSheen: materialSheen,\n\tmaterialSheenRoughness: materialSheenRoughness,\n\tmaterialShininess: materialShininess,\n\tmaterialSpecular: materialSpecular,\n\tmaterialSpecularColor: materialSpecularColor,\n\tmaterialSpecularIntensity: materialSpecularIntensity,\n\tmaterialSpecularStrength: materialSpecularStrength,\n\tmaterialThickness: materialThickness,\n\tmaterialTransmission: materialTransmission,\n\tmax: max$1,\n\tmaxMipLevel: maxMipLevel,\n\tmediumpModelViewMatrix: mediumpModelViewMatrix,\n\tmetalness: metalness,\n\tmin: min$1,\n\tmix: mix,\n\tmixElement: mixElement,\n\tmod: mod,\n\tmodInt: modInt,\n\tmodelDirection: modelDirection,\n\tmodelNormalMatrix: modelNormalMatrix,\n\tmodelPosition: modelPosition,\n\tmodelScale: modelScale,\n\tmodelViewMatrix: modelViewMatrix,\n\tmodelViewPosition: modelViewPosition,\n\tmodelViewProjection: modelViewProjection,\n\tmodelWorldMatrix: modelWorldMatrix,\n\tmodelWorldMatrixInverse: modelWorldMatrixInverse,\n\tmorphReference: morphReference,\n\tmrt: mrt,\n\tmul: mul,\n\tmx_aastep: mx_aastep,\n\tmx_cell_noise_float: mx_cell_noise_float,\n\tmx_contrast: mx_contrast,\n\tmx_fractal_noise_float: mx_fractal_noise_float,\n\tmx_fractal_noise_vec2: mx_fractal_noise_vec2,\n\tmx_fractal_noise_vec3: mx_fractal_noise_vec3,\n\tmx_fractal_noise_vec4: mx_fractal_noise_vec4,\n\tmx_hsvtorgb: mx_hsvtorgb,\n\tmx_noise_float: mx_noise_float,\n\tmx_noise_vec3: mx_noise_vec3,\n\tmx_noise_vec4: mx_noise_vec4,\n\tmx_ramplr: mx_ramplr,\n\tmx_ramptb: mx_ramptb,\n\tmx_rgbtohsv: mx_rgbtohsv,\n\tmx_safepower: mx_safepower,\n\tmx_splitlr: mx_splitlr,\n\tmx_splittb: mx_splittb,\n\tmx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,\n\tmx_transform_uv: mx_transform_uv,\n\tmx_worley_noise_float: mx_worley_noise_float,\n\tmx_worley_noise_vec2: mx_worley_noise_vec2,\n\tmx_worley_noise_vec3: mx_worley_noise_vec3,\n\tnegate: negate,\n\tneutralToneMapping: neutralToneMapping,\n\tnodeArray: nodeArray,\n\tnodeImmutable: nodeImmutable,\n\tnodeObject: nodeObject,\n\tnodeObjects: nodeObjects,\n\tnodeProxy: nodeProxy,\n\tnormalFlat: normalFlat,\n\tnormalGeometry: normalGeometry,\n\tnormalLocal: normalLocal,\n\tnormalMap: normalMap,\n\tnormalView: normalView,\n\tnormalWorld: normalWorld,\n\tnormalize: normalize,\n\tnot: not,\n\tnotEqual: notEqual,\n\tnumWorkgroups: numWorkgroups,\n\tobjectDirection: objectDirection,\n\tobjectGroup: objectGroup,\n\tobjectPosition: objectPosition,\n\tobjectScale: objectScale,\n\tobjectViewPosition: objectViewPosition,\n\tobjectWorldMatrix: objectWorldMatrix,\n\toneMinus: oneMinus,\n\tor: or,\n\torthographicDepthToViewZ: orthographicDepthToViewZ,\n\toscSawtooth: oscSawtooth,\n\toscSine: oscSine,\n\toscSquare: oscSquare,\n\toscTriangle: oscTriangle,\n\toutput: output,\n\toutputStruct: outputStruct,\n\toverlay: overlay,\n\toverloadingFn: overloadingFn,\n\tparabola: parabola,\n\tparallaxDirection: parallaxDirection,\n\tparallaxUV: parallaxUV,\n\tparameter: parameter,\n\tpass: pass,\n\tpassTexture: passTexture,\n\tpcurve: pcurve,\n\tperspectiveDepthToViewZ: perspectiveDepthToViewZ,\n\tpmremTexture: pmremTexture,\n\tpointUV: pointUV,\n\tpointWidth: pointWidth,\n\tpositionGeometry: positionGeometry,\n\tpositionLocal: positionLocal,\n\tpositionPrevious: positionPrevious,\n\tpositionView: positionView,\n\tpositionViewDirection: positionViewDirection,\n\tpositionWorld: positionWorld,\n\tpositionWorldDirection: positionWorldDirection,\n\tposterize: posterize,\n\tpow: pow,\n\tpow2: pow2,\n\tpow3: pow3,\n\tpow4: pow4,\n\tproperty: property,\n\tradians: radians,\n\trand: rand,\n\trange: range,\n\trangeFog: rangeFog,\n\trangeFogFactor: rangeFogFactor,\n\treciprocal: reciprocal,\n\treference: reference,\n\treferenceBuffer: referenceBuffer,\n\treflect: reflect,\n\treflectVector: reflectVector,\n\treflectView: reflectView,\n\treflector: reflector,\n\trefract: refract,\n\trefractVector: refractVector,\n\trefractView: refractView,\n\treinhardToneMapping: reinhardToneMapping,\n\tremainder: remainder,\n\tremap: remap,\n\tremapClamp: remapClamp,\n\trenderGroup: renderGroup,\n\trenderOutput: renderOutput,\n\trendererReference: rendererReference,\n\trotate: rotate,\n\trotateUV: rotateUV,\n\troughness: roughness,\n\tround: round,\n\trtt: rtt,\n\tsRGBTransferEOTF: sRGBTransferEOTF,\n\tsRGBTransferOETF: sRGBTransferOETF,\n\tsampler: sampler,\n\tsaturate: saturate,\n\tsaturation: saturation,\n\tscreen: screen,\n\tscreenCoordinate: screenCoordinate,\n\tscreenSize: screenSize,\n\tscreenUV: screenUV,\n\tscriptable: scriptable,\n\tscriptableValue: scriptableValue,\n\tselect: select,\n\tsetCurrentStack: setCurrentStack,\n\tshaderStages: shaderStages,\n\tshadow: shadow,\n\tshadowPositionWorld: shadowPositionWorld,\n\tshapeCircle: shapeCircle,\n\tsharedUniformGroup: sharedUniformGroup,\n\tsheen: sheen,\n\tsheenRoughness: sheenRoughness,\n\tshiftLeft: shiftLeft,\n\tshiftRight: shiftRight,\n\tshininess: shininess,\n\tsign: sign,\n\tsin: sin,\n\tsinc: sinc,\n\tskinning: skinning,\n\tskinningReference: skinningReference,\n\tsmoothstep: smoothstep,\n\tsmoothstepElement: smoothstepElement,\n\tspecularColor: specularColor,\n\tspecularF90: specularF90,\n\tspherizeUV: spherizeUV,\n\tsplit: split,\n\tspritesheetUV: spritesheetUV,\n\tsqrt: sqrt,\n\tstack: stack,\n\tstep: step,\n\tstorage: storage,\n\tstorageBarrier: storageBarrier,\n\tstorageObject: storageObject,\n\tstorageTexture: storageTexture,\n\tstring: string,\n\tstruct: struct,\n\tsub: sub,\n\tsubgroupIndex: subgroupIndex,\n\tsubgroupSize: subgroupSize,\n\ttan: tan,\n\ttangentGeometry: tangentGeometry,\n\ttangentLocal: tangentLocal,\n\ttangentView: tangentView,\n\ttangentWorld: tangentWorld,\n\ttemp: temp,\n\ttexture: texture,\n\ttexture3D: texture3D,\n\ttextureBarrier: textureBarrier,\n\ttextureBicubic: textureBicubic,\n\ttextureCubeUV: textureCubeUV,\n\ttextureLoad: textureLoad,\n\ttextureSize: textureSize,\n\ttextureStore: textureStore,\n\tthickness: thickness,\n\ttime: time,\n\ttimerDelta: timerDelta,\n\ttimerGlobal: timerGlobal,\n\ttimerLocal: timerLocal,\n\ttoOutputColorSpace: toOutputColorSpace,\n\ttoWorkingColorSpace: toWorkingColorSpace,\n\ttoneMapping: toneMapping,\n\ttoneMappingExposure: toneMappingExposure,\n\ttoonOutlinePass: toonOutlinePass,\n\ttransformDirection: transformDirection,\n\ttransformNormal: transformNormal,\n\ttransformNormalToView: transformNormalToView,\n\ttransformedBentNormalView: transformedBentNormalView,\n\ttransformedBitangentView: transformedBitangentView,\n\ttransformedBitangentWorld: transformedBitangentWorld,\n\ttransformedClearcoatNormalView: transformedClearcoatNormalView,\n\ttransformedNormalView: transformedNormalView,\n\ttransformedNormalWorld: transformedNormalWorld,\n\ttransformedTangentView: transformedTangentView,\n\ttransformedTangentWorld: transformedTangentWorld,\n\ttransmission: transmission,\n\ttranspose: transpose,\n\ttriNoise3D: triNoise3D,\n\ttriplanarTexture: triplanarTexture,\n\ttriplanarTextures: triplanarTextures,\n\ttrunc: trunc,\n\ttslFn: tslFn,\n\tuint: uint,\n\tuniform: uniform,\n\tuniformArray: uniformArray,\n\tuniformGroup: uniformGroup,\n\tuniforms: uniforms,\n\tuserData: userData,\n\tuv: uv,\n\tuvec2: uvec2,\n\tuvec3: uvec3,\n\tuvec4: uvec4,\n\tvarying: varying,\n\tvaryingProperty: varyingProperty,\n\tvec2: vec2,\n\tvec3: vec3,\n\tvec4: vec4,\n\tvectorComponents: vectorComponents,\n\tvelocity: velocity,\n\tvertexColor: vertexColor,\n\tvertexIndex: vertexIndex,\n\tvertexStage: vertexStage,\n\tvibrance: vibrance,\n\tviewZToLogarithmicDepth: viewZToLogarithmicDepth,\n\tviewZToOrthographicDepth: viewZToOrthographicDepth,\n\tviewZToPerspectiveDepth: viewZToPerspectiveDepth,\n\tviewport: viewport,\n\tviewportBottomLeft: viewportBottomLeft,\n\tviewportCoordinate: viewportCoordinate,\n\tviewportDepthTexture: viewportDepthTexture,\n\tviewportLinearDepth: viewportLinearDepth,\n\tviewportMipTexture: viewportMipTexture,\n\tviewportResolution: viewportResolution,\n\tviewportSafeUV: viewportSafeUV,\n\tviewportSharedTexture: viewportSharedTexture,\n\tviewportSize: viewportSize,\n\tviewportTexture: viewportTexture,\n\tviewportTopLeft: viewportTopLeft,\n\tviewportUV: viewportUV,\n\twgsl: wgsl,\n\twgslFn: wgslFn,\n\tworkgroupArray: workgroupArray,\n\tworkgroupBarrier: workgroupBarrier,\n\tworkgroupId: workgroupId,\n\tworkingToColorSpace: workingToColorSpace,\n\txor: xor\n});\n\nconst _clearColor$1 = /*@__PURE__*/ new Color4();\n\n/**\n * This renderer module manages the background.\n *\n * @private\n * @augments DataMap\n */\nclass Background extends DataMap {\n\n\t/**\n\t * Constructs a new background management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t */\n\tconstructor( renderer, nodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t}\n\n\t/**\n\t * Updates the background for the given scene. Depending on how `Scene.background`\n\t * or `Scene.backgroundNode` are configured, this method might configure a simple clear\n\t * or add a mesh to the render list for rendering the background as a textured plane\n\t * or skybox.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {RenderList} renderList - The current render list.\n\t * @param {RenderContext} renderContext - The current render context.\n\t */\n\tupdate( scene, renderList, renderContext ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst background = this.nodes.getBackgroundNode( scene ) || scene.background;\n\n\t\tlet forceClear = false;\n\n\t\tif ( background === null ) {\n\n\t\t\t// no background settings, use clear color configuration from the renderer\n\n\t\t\trenderer._clearColor.getRGB( _clearColor$1, LinearSRGBColorSpace );\n\t\t\t_clearColor$1.a = renderer._clearColor.a;\n\n\t\t} else if ( background.isColor === true ) {\n\n\t\t\t// background is an opaque color\n\n\t\t\tbackground.getRGB( _clearColor$1, LinearSRGBColorSpace );\n\t\t\t_clearColor$1.a = 1;\n\n\t\t\tforceClear = true;\n\n\t\t} else if ( background.isNode === true ) {\n\n\t\t\tconst sceneData = this.get( scene );\n\t\t\tconst backgroundNode = background;\n\n\t\t\t_clearColor$1.copy( renderer._clearColor );\n\n\t\t\tlet backgroundMesh = sceneData.backgroundMesh;\n\n\t\t\tif ( backgroundMesh === undefined ) {\n\n\t\t\t\tconst backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {\n\t\t\t\t\t// @TODO: Add Texture2D support using node context\n\t\t\t\t\tgetUV: () => backgroundRotation.mul( normalWorld ),\n\t\t\t\t\tgetTextureLevel: () => backgroundBlurriness\n\t\t\t\t} );\n\n\t\t\t\tlet viewProj = modelViewProjection;\n\t\t\t\tviewProj = viewProj.setZ( viewProj.w );\n\n\t\t\t\tconst nodeMaterial = new NodeMaterial();\n\t\t\t\tnodeMaterial.name = 'Background.material';\n\t\t\t\tnodeMaterial.side = BackSide;\n\t\t\t\tnodeMaterial.depthTest = false;\n\t\t\t\tnodeMaterial.depthWrite = false;\n\t\t\t\tnodeMaterial.fog = false;\n\t\t\t\tnodeMaterial.lights = false;\n\t\t\t\tnodeMaterial.vertexNode = viewProj;\n\t\t\t\tnodeMaterial.colorNode = backgroundMeshNode;\n\n\t\t\t\tsceneData.backgroundMeshNode = backgroundMeshNode;\n\t\t\t\tsceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );\n\t\t\t\tbackgroundMesh.frustumCulled = false;\n\t\t\t\tbackgroundMesh.name = 'Background.mesh';\n\n\t\t\t\tbackgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst backgroundCacheKey = backgroundNode.getCacheKey();\n\n\t\t\tif ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {\n\n\t\t\t\tsceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );\n\t\t\t\tsceneData.backgroundMeshNode.needsUpdate = true;\n\n\t\t\t\tbackgroundMesh.material.needsUpdate = true;\n\n\t\t\t\tsceneData.backgroundCacheKey = backgroundCacheKey;\n\n\t\t\t}\n\n\t\t\trenderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Renderer: Unsupported background configuration.', background );\n\n\t\t}\n\n\t\t//\n\n\t\tconst environmentBlendMode = renderer.xr.getEnvironmentBlendMode();\n\n\t\tif ( environmentBlendMode === 'additive' ) {\n\n\t\t\t_clearColor$1.set( 0, 0, 0, 1 );\n\n\t\t} else if ( environmentBlendMode === 'alpha-blend' ) {\n\n\t\t\t_clearColor$1.set( 0, 0, 0, 0 );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderer.autoClear === true || forceClear === true ) {\n\n\t\t\tconst clearColorValue = renderContext.clearColorValue;\n\n\t\t\tclearColorValue.r = _clearColor$1.r;\n\t\t\tclearColorValue.g = _clearColor$1.g;\n\t\t\tclearColorValue.b = _clearColor$1.b;\n\t\t\tclearColorValue.a = _clearColor$1.a;\n\n\t\t\t// premultiply alpha\n\n\t\t\tif ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {\n\n\t\t\t\tclearColorValue.r *= clearColorValue.a;\n\t\t\t\tclearColorValue.g *= clearColorValue.a;\n\t\t\t\tclearColorValue.b *= clearColorValue.a;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\trenderContext.depthClearValue = renderer._clearDepth;\n\t\t\trenderContext.stencilClearValue = renderer._clearStencil;\n\n\t\t\trenderContext.clearColor = renderer.autoClearColor === true;\n\t\t\trenderContext.clearDepth = renderer.autoClearDepth === true;\n\t\t\trenderContext.clearStencil = renderer.autoClearStencil === true;\n\n\t\t} else {\n\n\t\t\trenderContext.clearColor = false;\n\t\t\trenderContext.clearDepth = false;\n\t\t\trenderContext.clearStencil = false;\n\n\t\t}\n\n\t}\n\n}\n\nlet _id$6 = 0;\n\n/**\n * A bind group represents a collection of bindings and thus a collection\n * or resources. Bind groups are assigned to pipelines to provide them\n * with the required resources (like uniform buffers or textures).\n *\n * @private\n */\nclass BindGroup {\n\n\t/**\n\t * Constructs a new bind group.\n\t *\n\t * @param {String} name - The bind group's name.\n\t * @param {Array<Binding>} bindings - An array of bindings.\n\t * @param {Number} index - The group index.\n\t * @param {Array<Binding>} bindingsReference - An array of reference bindings.\n\t */\n\tconstructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {\n\n\t\t/**\n\t\t * The bind group's name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * An array of bindings.\n\t\t *\n\t\t * @type {Array<Binding>}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * The group index.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.index = index;\n\n\t\t/**\n\t\t * An array of reference bindings.\n\t\t *\n\t\t * @type {Array<Binding>}\n\t\t */\n\t\tthis.bindingsReference = bindingsReference;\n\n\t\t/**\n\t\t * The group's ID.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$6 ++;\n\n\t}\n\n}\n\n/**\n * This module represents the state of a node builder after it was\n * used to build the nodes for a render object. The state holds the\n * results of the build for further processing in the renderer.\n *\n * Render objects with identical cache keys share the same node builder state.\n *\n * @private\n */\nclass NodeBuilderState {\n\n\t/**\n\t * Constructs a new node builder state.\n\t *\n\t * @param {String?} vertexShader - The native vertex shader code.\n\t * @param {String?} fragmentShader - The native fragment shader code.\n\t * @param {String?} computeShader - The native compute shader code.\n\t * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.\n\t * @param {Array<BindGroup>} bindings - An array of bind groups.\n\t * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.\n\t * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.\n\t * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.\n\t * @param {NodeMaterialObserver} observer - A node material observer.\n\t * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.\n\t */\n\tconstructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, observer, transforms = [] ) {\n\n\t\t/**\n\t\t * The native vertex shader code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.vertexShader = vertexShader;\n\n\t\t/**\n\t\t * The native fragment shader code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.fragmentShader = fragmentShader;\n\n\t\t/**\n\t\t * The native compute shader code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.computeShader = computeShader;\n\n\t\t/**\n\t\t * An array with transform attribute objects.\n\t\t * Only relevant when using compute shaders with WebGL 2.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transforms = transforms;\n\n\t\t/**\n\t\t * An array of node attributes representing\n\t\t * the attributes of the shaders.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.nodeAttributes = nodeAttributes;\n\n\t\t/**\n\t\t * An array of bind groups representing the uniform or storage\n\t\t * buffers, texture or samplers of the shader.\n\t\t *\n\t\t * @type {Array<BindGroup>}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * An array of nodes that implement their `update()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateNodes = updateNodes;\n\n\t\t/**\n\t\t * An array of nodes that implement their `updateBefore()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateBeforeNodes = updateBeforeNodes;\n\n\t\t/**\n\t\t * An array of nodes that implement their `updateAfter()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateAfterNodes = updateAfterNodes;\n\n\t\t/**\n\t\t * A node material observer.\n\t\t *\n\t\t * @type {NodeMaterialObserver}\n\t\t */\n\t\tthis.observer = observer;\n\n\t\t/**\n\t\t * How often this state is used by render objects.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n\t/**\n\t * This method is used to create a array of bind groups based\n\t * on the existing bind groups of this state. Shared groups are\n\t * not cloned.\n\t *\n\t * @return {Array<BindGroup>} A array of bind groups.\n\t */\n\tcreateBindings() {\n\n\t\tconst bindings = [];\n\n\t\tfor ( const instanceGroup of this.bindings ) {\n\n\t\t\tconst shared = instanceGroup.bindings[ 0 ].groupNode.shared; // All bindings in the group must have the same groupNode.\n\n\t\t\tif ( shared !== true ) {\n\n\t\t\t\tconst bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );\n\t\t\t\tbindings.push( bindingsGroup );\n\n\t\t\t\tfor ( const instanceBinding of instanceGroup.bindings ) {\n\n\t\t\t\t\tbindingsGroup.bindings.push( instanceBinding.clone() );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbindings.push( instanceGroup );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader attributes that are going to be generated\n * by the builder. Arrays of node attributes is maintained in {@link NodeBuilder#attributes}\n * and {@link NodeBuilder#bufferAttributes} for this purpose.\n */\nclass NodeAttribute {\n\n\t/**\n\t * Constructs a new node attribute.\n\t *\n\t * @param {String} name - The name of the attribute.\n\t * @param {String} type - The type of the attribute.\n\t * @param {Node?} node - An optional reference to the node.\n\t */\n\tconstructor( name, type, node = null ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeAttribute = true;\n\n\t\t/**\n\t\t * The name of the attribute.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the attribute.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * An optional reference to the node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.node = node;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader uniforms that are going to be generated\n * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}\n * for this purpose.\n */\nclass NodeUniform {\n\n\t/**\n\t * Constructs a new node uniform.\n\t *\n\t * @param {String} name - The name of the uniform.\n\t * @param {String} type - The type of the uniform.\n\t * @param {UniformNode} node - An reference to the node.\n\t */\n\tconstructor( name, type, node ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeUniform = true;\n\n\t\t/**\n\t\t * The name of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * An reference to the node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\t/**\n\t * The value of the uniform node.\n\t *\n\t * @type {Any}\n\t */\n\tget value() {\n\n\t\treturn this.node.value;\n\n\t}\n\n\tset value( val ) {\n\n\t\tthis.node.value = val;\n\n\t}\n\n\t/**\n\t * The id of the uniform node.\n\t *\n\t * @type {Number}\n\t */\n\tget id() {\n\n\t\treturn this.node.id;\n\n\t}\n\n\t/**\n\t * The uniform node's group.\n\t *\n\t * @type {UniformGroupNode}\n\t */\n\tget groupNode() {\n\n\t\treturn this.node.groupNode;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader variables that are going to be generated\n * by the builder. A dictionary of node variables is maintained in {@link NodeBuilder#vars} for\n * this purpose.\n */\nclass NodeVar {\n\n\t/**\n\t * Constructs a new node variable.\n\t *\n\t * @param {String} name - The name of the variable.\n\t * @param {String} type - The type of the variable.\n\t * @param {Boolean} [readOnly=false] - The read-only flag.\n\t * @param {Number?} [count=null] - The size.\n\t */\n\tconstructor( name, type, readOnly = false, count = null ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeVar = true;\n\n\t\t/**\n\t\t * The name of the variable.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the variable.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t *  The read-only flag.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.readOnly = readOnly;\n\n\t\t/**\n\t\t * The size.\n\t\t *\n\t\t * @type {Number?}\n\t\t */\n\t\tthis.count = count;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader varyings that are going to be generated\n * by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for\n * this purpose.\n *\n * @augments NodeVar\n */\nclass NodeVarying extends NodeVar {\n\n\t/**\n\t * Constructs a new node varying.\n\t *\n\t * @param {String} name - The name of the varying.\n\t * @param {String} type - The type of the varying.\n\t */\n\tconstructor( name, type ) {\n\n\t\tsuper( name, type );\n\n\t\t/**\n\t\t * Whether this varying requires interpolation or not. This property can be used\n\t\t * to check if the varying can be optimized for a variable.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsInterpolation = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeVarying = true;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent user-defined, native shader code portions that are going to be\n * injected by the builder. A dictionary of node codes is maintained in {@link NodeBuilder#codes}\n * for this purpose.\n */\nclass NodeCode {\n\n\t/**\n\t * Constructs a new code node.\n\t *\n\t * @param {String} name - The name of the code.\n\t * @param {String} type - The node type.\n\t * @param {String} [code=''] - The native shader code.\n\t */\n\tconstructor( name, type, code = '' ) {\n\n\t\t/**\n\t\t * The name of the code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The node type.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The native shader code.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.code = code;\n\n\t\tObject.defineProperty( this, 'isNodeCode', { value: true } );\n\n\t}\n\n}\n\nlet _id$5 = 0;\n\n/**\n * This utility class is used in {@link NodeBuilder} as an internal\n * cache data structure for node data.\n */\nclass NodeCache {\n\n\t/**\n\t * Constructs a new node cache.\n\t *\n\t * @param {NodeCache?} parent - A reference to a parent cache.\n\t */\n\tconstructor( parent = null ) {\n\n\t\t/**\n\t\t * The id of the cache.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t */\n\t\tthis.id = _id$5 ++;\n\n\t\t/**\n\t\t * A weak map for managing node data.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.nodesData = new WeakMap();\n\n\t\t/**\n\t\t * Reference to a parent node cache.\n\t\t *\n\t\t * @type {NodeCache?}\n\t\t * @default null\n\t\t */\n\t\tthis.parent = parent;\n\n\t}\n\n\t/**\n\t * Returns the data for the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @return {Object?} The data for the node.\n\t */\n\tgetData( node ) {\n\n\t\tlet data = this.nodesData.get( node );\n\n\t\tif ( data === undefined && this.parent !== null ) {\n\n\t\t\tdata = this.parent.getData( node );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Sets the data for a given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {Object} data - The data that should be cached.\n\t */\n\tsetData( node, data ) {\n\n\t\tthis.nodesData.set( node, data );\n\n\t}\n\n}\n\nclass StructType {\n\n\tconstructor( name, members ) {\n\n\t\tthis.name = name;\n\t\tthis.members = members;\n\t\tthis.output = false;\n\n\t}\n\n}\n\n/**\n * Abstract base class for uniforms.\n *\n * @abstract\n * @private\n */\nclass Uniform {\n\n\t/**\n\t * Constructs a new uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Any} value - The uniform's value.\n\t */\n\tconstructor( name, value ) {\n\n\t\t/**\n\t\t * The uniform's name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The uniform's value.\n\t\t *\n\t\t * @type {Any}\n\t\t */\n\t\tthis.value = value;\n\n\t\t/**\n\t\t * Used to build the uniform buffer according to the STD140 layout.\n\t\t * Derived uniforms will set this property to a data type specific\n\t\t * value.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.boundary = 0;\n\n\t\t/**\n\t\t * The item size. Derived uniforms will set this property to a data\n\t\t * type specific value.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.itemSize = 0;\n\n\t\t/**\n\t\t * This property is set by {@link UniformsGroup} and marks\n\t\t * the start position in the uniform buffer.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.offset = 0;\n\n\t}\n\n\t/**\n\t * Sets the uniform's value.\n\t *\n\t * @param {Any} value - The value to set.\n\t */\n\tsetValue( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * Returns the uniform's value.\n\t *\n\t * @return {Any} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.value;\n\n\t}\n\n}\n\n/**\n * Represents a Number uniform.\n *\n * @private\n * @augments Uniform\n */\nclass NumberUniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Number} value - The uniform's value.\n\t */\n\tconstructor( name, value = 0 ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNumberUniform = true;\n\n\t\tthis.boundary = 4;\n\t\tthis.itemSize = 1;\n\n\t}\n\n}\n\n/**\n * Represents a Vector2 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector2Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Vector2} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector2() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector2Uniform = true;\n\n\t\tthis.boundary = 8;\n\t\tthis.itemSize = 2;\n\n\t}\n\n}\n\n/**\n * Represents a Vector3 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector3Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Vector3} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector3() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector3Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\n/**\n * Represents a Vector4 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector4Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Vector4} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector4() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector4Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 4;\n\n\t}\n\n}\n\n/**\n * Represents a Color uniform.\n *\n * @private\n * @augments Uniform\n */\nclass ColorUniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Color} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Color() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isColorUniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\n/**\n * Represents a Matrix2 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix2Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Matrix2} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Matrix2() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMatrix2Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 4;\n\n\t}\n\n}\n\n\n/**\n * Represents a Matrix3 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix3Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Matrix3} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Matrix3() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMatrix3Uniform = true;\n\n\t\tthis.boundary = 48;\n\t\tthis.itemSize = 12;\n\n\t}\n\n}\n\n/**\n * Represents a Matrix4 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix4Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Matrix4} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Matrix4() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMatrix4Uniform = true;\n\n\t\tthis.boundary = 64;\n\t\tthis.itemSize = 16;\n\n\t}\n\n}\n\n/**\n * A special form of Number uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments NumberUniform\n */\nclass NumberNodeUniform extends NumberUniform {\n\n\t/**\n\t * Constructs a new node-based Number uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Number} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector2 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector2Uniform\n */\nclass Vector2NodeUniform extends Vector2Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector2 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector2} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector3 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector3Uniform\n */\nclass Vector3NodeUniform extends Vector3Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector3 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector3} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector4 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector4Uniform\n */\nclass Vector4NodeUniform extends Vector4Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector4 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector4} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Color uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments ColorUniform\n */\nclass ColorNodeUniform extends ColorUniform {\n\n\t/**\n\t * Constructs a new node-based Color uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Color} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n\n/**\n * A special form of Matrix2 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix2Uniform\n */\nclass Matrix2NodeUniform extends Matrix2Uniform {\n\n\t/**\n\t * Constructs a new node-based Matrix2 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Matrix2} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Matrix3 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix3Uniform\n */\nclass Matrix3NodeUniform extends Matrix3Uniform {\n\n\t/**\n\t * Constructs a new node-based Matrix3 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Matrix3} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Matrix4 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix4Uniform\n */\nclass Matrix4NodeUniform extends Matrix4Uniform {\n\n\t/**\n\t * Constructs a new node-based Matrix4 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Matrix4} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\nconst _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 )\n];\n\n// maps blur materials to their uniforms dictionary\n\nconst _uniformsMap = new WeakMap();\n\n// WebGPU Face indices\nconst _faceLib = [\n\t3, 1, 5,\n\t0, 4, 2\n];\n\nconst _direction = /*@__PURE__*/ getDirection( uv(), attribute( 'faceIndex' ) ).normalize();\nconst _outputDirection = /*@__PURE__*/ vec3( _direction.x, _direction.y, _direction.z );\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\t\tthis._lodMeshes = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\t\tthis._backgroundBox = null;\n\n\t}\n\n\tget _hasInitialized() {\n\n\t\treturn this._renderer.hasInitialized();\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t *\n\t * @param {Scene} scene - The scene to be captured.\n\t * @param {Number} [sigma=0] - The blur radius in radians.\n\t * @param {Number} [near=0.1] - The near plane distance.\n\t * @param {Number} [far=100] - The far plane distance.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see fromSceneAsync\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {\n\n\t\tthis._setSize( 256 );\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromSceneAsync( scene, sigma, near, far, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t *\n\t * @param {Scene} scene - The scene to be captured.\n\t * @param {Number} [sigma=0] - The blur radius in radians.\n\t * @param {Number} [near=0.1] - The near plane distance.\n\t * @param {Number} [far=100] - The far plane distance.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} The resulting PMREM.\n\t * @see fromScene\n\t */\n\tasync fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this.fromScene( scene, sigma, near, far, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} equirectangular - The equirectangular texture to be converted.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see fromEquirectangularAsync\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( equirectangular );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} equirectangular - The equirectangular texture to be converted.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} The resulting PMREM.\n\t * @see fromEquirectangular\n\t */\n\tasync fromEquirectangularAsync( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} cubemap - The cubemap texture to be converted.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see fromCubemapAsync\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( cubemap );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromCubemapAsync( cubemap, renderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} cubemap - The cubemap texture to be converted.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} The resulting PMREM.\n\t * @see fromCubemap\n\t */\n\tasync fromCubemapAsync( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t *\n\t * @returns {Promise}\n\t */\n\tasync compileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tawait this._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t *\n\t * @returns {Promise}\n\t */\n\tasync compileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tawait this._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\t\tif ( this._backgroundBox !== null ) {\n\n\t\t\tthis._backgroundBox.geometry.dispose();\n\t\t\tthis._backgroundBox.material.dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_setSizeFromTexture( texture ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t}\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tthis._setSizeFromTexture( texture );\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t//depthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\tasync _compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tawait this._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst cubeCamera = _cubeCamera;\n\t\tcubeCamera.near = near;\n\t\tcubeCamera.far = far;\n\n\t\t// px, py, pz, nx, ny, nz\n\t\tconst upSign = [ 1, 1, 1, 1, - 1, 1 ];\n\t\tconst forwardSign = [ 1, - 1, 1, - 1, 1, - 1 ];\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.autoClear = false;\n\n\t\tlet backgroundBox = this._backgroundBox;\n\n\t\tif ( backgroundBox === null ) {\n\n\t\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\t\tname: 'PMREM.Background',\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tdepthTest: false\n\t\t\t} );\n\n\t\t\tbackgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\t}\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundBox.material.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundBox.material.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\trenderer.clear();\n\n\t\tif ( useSolidColor ) {\n\n\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial( texture );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial( texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tmaterial.fragmentNode.value = texture;\n\n\t\tconst mesh = this._lodMeshes[ 0 ];\n\t\tmesh.material = material;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t *\n\t * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.\n\t * @param {Number} lodIn - The input level-of-detail.\n\t * @param {Number} lodOut - The output level-of-detail.\n\t * @param {Number} sigma - The blur radius in radians.\n\t * @param {Vector3} [poleAxis] - The pole axis.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error( 'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = this._lodMeshes[ lodOut ];\n\t\tblurMesh.material = blurMaterial;\n\n\t\tconst blurUniforms = _uniformsMap.get( blurMaterial );\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\ttargetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;\n\n\t\tblurUniforms.envMap.value = targetIn.texture;\n\t\tblurUniforms.samples.value = samples;\n\t\tblurUniforms.weights.array = weights;\n\t\tblurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms.poleAxis.value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms.dTheta.value = radiansPerPixel;\n\t\tblurUniforms.mipInt.value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\tconst lodMeshes = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\n\t\t\tconst faceIdx = _faceLib[ face ];\n\t\t\tposition.set( coordinates, positionSize * vertices * faceIdx );\n\t\t\tuv.set( uv1, uvSize * vertices * faceIdx );\n\t\t\tconst fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * faceIdx );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\t\tlodMeshes.push( new Mesh( planes, null ) );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas, lodMeshes };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new RenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.texture.isPMREMTexture = true;\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getMaterial( type ) {\n\n\tconst material = new NodeMaterial();\n\tmaterial.depthTest = false;\n\tmaterial.depthWrite = false;\n\tmaterial.blending = NoBlending;\n\tmaterial.name = `PMREM_${ type }`;\n\n\treturn material;\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );\n\tconst poleAxis = uniform( new Vector3( 0, 1, 0 ) );\n\tconst dTheta = uniform( 0 );\n\tconst n = float( MAX_SAMPLES );\n\tconst latitudinal = uniform( 0 ); // false, bool\n\tconst samples = uniform( 1 ); // int\n\tconst envMap = texture( null );\n\tconst mipInt = uniform( 0 ); // int\n\tconst CUBEUV_TEXEL_WIDTH = float( 1 / width );\n\tconst CUBEUV_TEXEL_HEIGHT = float( 1 / height );\n\tconst CUBEUV_MAX_MIP = float( lodMax );\n\n\tconst materialUniforms = {\n\t\tn,\n\t\tlatitudinal,\n\t\tweights,\n\t\tpoleAxis,\n\t\toutputDirection: _outputDirection,\n\t\tdTheta,\n\t\tsamples,\n\t\tenvMap,\n\t\tmipInt,\n\t\tCUBEUV_TEXEL_WIDTH,\n\t\tCUBEUV_TEXEL_HEIGHT,\n\t\tCUBEUV_MAX_MIP\n\t};\n\n\tconst material = _getMaterial( 'blur' );\n\tmaterial.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );\n\n\t_uniformsMap.set( material, materialUniforms );\n\n\treturn material;\n\n}\n\nfunction _getCubemapMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'cubemap' );\n\tmaterial.fragmentNode = cubeTexture( envTexture, _outputDirection );\n\n\treturn material;\n\n}\n\nfunction _getEquirectMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'equirect' );\n\tmaterial.fragmentNode = texture( envTexture, equirectUV( _outputDirection ), 0 );\n\n\treturn material;\n\n}\n\nconst rendererCache = new WeakMap();\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tif ( /e/g.test( value ) ) {\n\n\t\treturn String( value ).replace( /\\+/g, '' );\n\n\t} else {\n\n\t\tvalue = Number( value );\n\n\t\treturn value + ( value % 1 ? '' : '.0' );\n\n\t}\n\n};\n\n/**\n * Base class for builders which generate a shader program based\n * on a 3D object and its node material definition.\n */\nclass NodeBuilder {\n\n\t/**\n\t * Constructs a new node builder.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The current renderer.\n\t * @param {NodeParser} parser - A reference to a node parser.\n\t */\n\tconstructor( object, renderer, parser ) {\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The material of the 3D object.\n\t\t *\n\t\t * @type {Material?}\n\t\t */\n\t\tthis.material = ( object && object.material ) || null;\n\n\t\t/**\n\t\t * The geometry of the 3D object.\n\t\t *\n\t\t * @type {BufferGeometry?}\n\t\t */\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\n\t\t/**\n\t\t * The current renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * A reference to a node parser.\n\t\t *\n\t\t * @type {NodeParser}\n\t\t */\n\t\tthis.parser = parser;\n\n\t\t/**\n\t\t * The scene the 3D object belongs to.\n\t\t *\n\t\t * @type {Scene?}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = null;\n\n\t\t/**\n\t\t * The camera the 3D object is rendered with.\n\t\t *\n\t\t * @type {Camera?}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * A list of all nodes the builder is processing\n\t\t * for this 3D object.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = [];\n\n\t\t/**\n\t\t * A list of all sequential nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.sequentialNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#update} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#updateBefore} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateBeforeNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#updateAfter} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateAfterNodes = [];\n\n\t\t/**\n\t\t * A dictionary that assigns each node to a unique hash.\n\t\t *\n\t\t * @type {Object<Number,Node>}\n\t\t */\n\t\tthis.hashNodes = {};\n\n\t\t/**\n\t\t * A reference to a node material observer.\n\t\t *\n\t\t * @type {NodeMaterialObserver?}\n\t\t * @default null\n\t\t */\n\t\tthis.observer = null;\n\n\t\t/**\n\t\t * A reference to the current lights node.\n\t\t *\n\t\t * @type {LightsNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.lightsNode = null;\n\n\t\t/**\n\t\t * A reference to the current environment node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.environmentNode = null;\n\n\t\t/**\n\t\t * A reference to the current fog node.\n\t\t *\n\t\t * @type {FogNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.fogNode = null;\n\n\t\t/**\n\t\t * The current clipping context.\n\t\t *\n\t\t * @type {ClippingContext?}\n\t\t */\n\t\tthis.clippingContext = null;\n\n\t\t/**\n\t\t * The generated vertex shader.\n\t\t *\n\t\t * @type {String?}\n\t\t */\n\t\tthis.vertexShader = null;\n\n\t\t/**\n\t\t * The generated fragment shader.\n\t\t *\n\t\t * @type {String?}\n\t\t */\n\t\tthis.fragmentShader = null;\n\n\t\t/**\n\t\t * The generated compute shader.\n\t\t *\n\t\t * @type {String?}\n\t\t */\n\t\tthis.computeShader = null;\n\n\t\t/**\n\t\t * Nodes used in the primary flow of code generation.\n\t\t *\n\t\t * @type {Object<String,Array<Node>>}\n\t\t */\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\n\t\t/**\n\t\t * Nodes code from `.flowNodes`.\n\t\t *\n\t\t * @type {Object<String,String>}\n\t\t */\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: '' };\n\n\t\t/**\n\t\t * This dictionary holds the node uniforms of the builder.\n\t\t * The uniforms are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the output structs of the builder.\n\t\t * The structs are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the bindings for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.bindings = { vertex: {}, fragment: {}, compute: {} };\n\n\t\t/**\n\t\t * This dictionary maintains the binding indices per bind group.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.bindingsIndexes = {};\n\n\t\t/**\n\t\t * Reference to the array of bind groups.\n\t\t *\n\t\t * @type {Array<BindGroup>?}\n\t\t */\n\t\tthis.bindGroups = null;\n\n\t\t/**\n\t\t * This array holds the node attributes of this builder\n\t\t * created via {@link AttributeNode}.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.attributes = [];\n\n\t\t/**\n\t\t * This array holds the node attributes of this builder\n\t\t * created via {@link BufferAttributeNode}.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.bufferAttributes = [];\n\n\t\t/**\n\t\t * This array holds the node varyings of this builder.\n\t\t *\n\t\t * @type {Array<NodeVarying>}\n\t\t */\n\t\tthis.varyings = [];\n\n\t\t/**\n\t\t * This dictionary holds the (native) node codes of this builder.\n\t\t * The codes are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object<String,Array<NodeCode>>}\n\t\t */\n\t\tthis.codes = {};\n\n\t\t/**\n\t\t * This dictionary holds the node variables of this builder.\n\t\t * The variables are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object<String,Array<NodeVar>>}\n\t\t */\n\t\tthis.vars = {};\n\n\t\t/**\n\t\t * Current code flow.\n\t\t * All code generated in this stack will be stored in `.flow`.\n\t\t *\n\t\t * @type {{code: String}}\n\t\t */\n\t\tthis.flow = { code: '' };\n\n\t\t/**\n\t\t * A chain of nodes.\n\t\t * Used to check recursive calls in node-graph.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.chaining = [];\n\n\t\t/**\n\t\t * The current stack.\n\t\t * This reflects the current process in the code block hierarchy,\n\t\t * it is useful to know if the current process is inside a conditional for example.\n\t\t *\n\t\t * @type {StackNode}\n\t\t */\n\t\tthis.stack = stack();\n\n\t\t/**\n\t\t * List of stack nodes.\n\t\t * The current stack hierarchy is stored in an array.\n\t\t *\n\t\t * @type {Array<StackNode>}\n\t\t */\n\t\tthis.stacks = [];\n\n\t\t/**\n\t\t * A tab value. Used for shader string generation.\n\t\t *\n\t\t * @type {String}\n\t\t * @default '\\t'\n\t\t */\n\t\tthis.tab = '\\t';\n\n\t\t/**\n\t\t * Reference to the current function node.\n\t\t *\n\t\t * @type {FunctionNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.currentFunctionNode = null;\n\n\t\t/**\n\t\t * The builder's context.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.context = {\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\t/**\n\t\t * The builder's cache.\n\t\t *\n\t\t * @type {NodeCache}\n\t\t */\n\t\tthis.cache = new NodeCache();\n\n\t\t/**\n\t\t * Since the {@link NodeBuilder#cache} might be temporarily\n\t\t * overwritten by other caches, this member retains the reference\n\t\t * to the builder's own cache.\n\t\t *\n\t\t * @type {NodeCache}\n\t\t * @default this.cache\n\t\t */\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\t/**\n\t\t * The current shader stage.\n\t\t *\n\t\t * @type {('vertex'|'fragment'|'compute'|'any')?}\n\t\t */\n\t\tthis.shaderStage = null;\n\n\t\t/**\n\t\t * The current build stage.\n\t\t *\n\t\t * @type {('setup'|'analyze'|'generate')?}\n\t\t */\n\t\tthis.buildStage = null;\n\n\t\t/**\n\t\t * Whether comparison in shader code are generated with methods or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useComparisonMethod = false;\n\n\t}\n\n\t/**\n\t * Returns the bind groups of the current renderer.\n\t *\n\t * @return {ChainMap} The cache.\n\t */\n\tgetBindGroupsCache() {\n\n\t\tlet bindGroupsCache = rendererCache.get( this.renderer );\n\n\t\tif ( bindGroupsCache === undefined ) {\n\n\t\t\tbindGroupsCache = new ChainMap();\n\n\t\t\trendererCache.set( this.renderer, bindGroupsCache );\n\n\t\t}\n\n\t\treturn bindGroupsCache;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link RenderTarget} with the given\n\t * dimensions and options.\n\t *\n\t * @param {Number} width - The width of the render target.\n\t * @param {Number} height - The height of the render target.\n\t * @param {Object} options - The options of the render target.\n\t * @return {RenderTarget} The render target.\n\t */\n\tcreateRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link CubeRenderTarget} with the given\n\t * dimensions and options.\n\t *\n\t * @param {Number} size - The size of the cube render target.\n\t * @param {Object} options - The options of the cube render target.\n\t * @return {CubeRenderTarget} The cube render target.\n\t */\n\tcreateCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link PMREMGenerator}.\n\t *\n\t * @return {PMREMGenerator} The PMREM generator.\n\t */\n\tcreatePMREMGenerator() {\n\n\t\t// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n\t\treturn new PMREMGenerator( this.renderer );\n\n\t}\n\n\t/**\n\t * Whether the given node is included in the internal array of nodes or not.\n\t *\n\t * @param {Node} node - The node to test.\n\t * @return {Boolean} Whether the given node is included in the internal array of nodes or not.\n\t */\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t/**\n\t * Returns the output struct name which is required by\n\t * {@link module:OutputStructNode}.\n\t *\n\t * @abstract\n\t * @return {String} The name of the output struct.\n\t */\n\tgetOutputStructName() {}\n\n\t/**\n\t * Returns a bind group for the given group name and binding.\n\t *\n\t * @private\n\t * @param {String} groupName - The group name.\n\t * @param {Array<NodeUniformsGroup>} bindings - List of bindings.\n\t * @return {BindGroup} The bind group\n\t */\n\t_getBindGroup( groupName, bindings ) {\n\n\t\tconst bindGroupsCache = this.getBindGroupsCache();\n\n\t\t//\n\n\t\tconst bindingsArray = [];\n\n\t\tlet sharedGroup = true;\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tbindingsArray.push( binding );\n\n\t\t\tsharedGroup = sharedGroup && binding.groupNode.shared !== true;\n\n\t\t}\n\n\t\t//\n\n\t\tlet bindGroup;\n\n\t\tif ( sharedGroup ) {\n\n\t\t\tbindGroup = bindGroupsCache.get( bindingsArray );\n\n\t\t\tif ( bindGroup === undefined ) {\n\n\t\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t\t\tbindGroupsCache.set( bindingsArray, bindGroup );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\t/**\n\t * Returns an array of node uniform groups for the given group name and shader stage.\n\t *\n\t * @param {String} groupName - The group name.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {Array<NodeUniformsGroup>} The array of node uniform groups.\n\t */\n\tgetBindGroupArray( groupName, shaderStage ) {\n\n\t\tconst bindings = this.bindings[ shaderStage ];\n\n\t\tlet bindGroup = bindings[ groupName ];\n\n\t\tif ( bindGroup === undefined ) {\n\n\t\t\tif ( this.bindingsIndexes[ groupName ] === undefined ) {\n\n\t\t\t\tthis.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };\n\n\t\t\t}\n\n\t\t\tbindings[ groupName ] = bindGroup = [];\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\t/**\n\t * Returns a list bindings of all shader stages separated by groups.\n\t *\n\t * @return {Array<BindGroup>} The list of bindings.\n\t */\n\tgetBindings() {\n\n\t\tlet bindingsGroups = this.bindGroups;\n\n\t\tif ( bindingsGroups === null ) {\n\n\t\t\tconst groups = {};\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tfor ( const groupName in bindings[ shaderStage ] ) {\n\n\t\t\t\t\tconst uniforms = bindings[ shaderStage ][ groupName ];\n\n\t\t\t\t\tconst groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );\n\t\t\t\t\tgroupUniforms.push( ...uniforms );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingsGroups = [];\n\n\t\t\tfor ( const groupName in groups ) {\n\n\t\t\t\tconst group = groups[ groupName ];\n\n\t\t\t\tconst bindingsGroup = this._getBindGroup( groupName, group );\n\n\t\t\t\tbindingsGroups.push( bindingsGroup );\n\n\t\t\t}\n\n\t\t\tthis.bindGroups = bindingsGroups;\n\n\t\t}\n\n\t\treturn bindingsGroups;\n\n\t}\n\n\t/**\n\t * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.\n\t */\n\tsortBindingGroups() {\n\n\t\tconst bindingsGroups = this.getBindings();\n\n\t\tbindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );\n\n\t\tfor ( let i = 0; i < bindingsGroups.length; i ++ ) {\n\n\t\t\tconst bindingGroup = bindingsGroups[ i ];\n\t\t\tthis.bindingsIndexes[ bindingGroup.name ].group = i;\n\n\t\t\tbindingGroup.index = i;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The builder maintains each node in a hash-based dictionary.\n\t * This method sets the given node (value) with the given hash (key) into this dictionary.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {Number} hash - The hash of the node.\n\t */\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\t/**\n\t * Adds a node to this builder.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * It is used to add Nodes that will be used as FRAME and RENDER events,\n\t * and need to follow a certain sequence in the calls to work correctly.\n\t * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddSequentialNode( node ) {\n\n\t\tif ( this.sequentialNodes.includes( node ) === false ) {\n\n\t\t\tthis.sequentialNodes.push( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks the update types of nodes\n\t */\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const node of this.sequentialNodes ) {\n\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\t\t\tconst updateAfterType = node.getUpdateAfterType();\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateAfterType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateAfterNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * A reference the current node which is the\n\t * last node in the chain of nodes.\n\t *\n\t * @type {Node}\n\t */\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\t/**\n\t * Whether the given texture is filtered or not.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {Boolean} Whether the given texture is filtered or not.\n\t */\n\tisFilteredTexture( texture ) {\n\n\t\treturn ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );\n\n\t}\n\n\t/**\n\t * Adds the given node to the internal node chain.\n\t * This is used to check recursive calls in node-graph.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\t/**\n\t * Removes the given node from the internal node chain.\n\t *\n\t * @param {Node} node - The node to remove.\n\t */\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name. E.g.\n\t * the method name `textureDimensions` matches the WGSL name but must be\n\t * resolved to `textureSize` in GLSL.\n\t *\n\t * @abstract\n\t * @param {String} method - The method name to resolve.\n\t * @return {String} The resolved method name.\n\t */\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\t/**\n\t * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.\n\t *\n\t * @param {Number} hash - The hash of the node.\n\t * @return {Node} The found node.\n\t */\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\t/**\n\t * Adds the Node to a target flow so that it can generate code in the 'generate' process.\n\t *\n\t * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.\n\t * @param {Node} node - The node to add.\n\t * @return {Node} The node.\n\t */\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Sets builder's context.\n\t *\n\t * @param {Object} context - The context to set.\n\t */\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\t/**\n\t * Returns the builder's current context.\n\t *\n\t * @return {Object} The builder's current context.\n\t */\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Gets a context used in shader construction that can be shared across different materials.\n\t * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.\n\t *\n\t * @return {Object} The builder's current context without material.\n\t */\n\tgetSharedContext() {\n\n\t\t({ ...this.context });\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Sets builder's cache.\n\t *\n\t * @param {NodeCache} cache - The cache to set.\n\t */\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\t/**\n\t * Returns the builder's current cache.\n\t *\n\t * @return {NodeCache} The builder's current cache.\n\t */\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\t/**\n\t * Returns a cache for the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n\t * @return {NodeCache} The cache.\n\t */\n\tgetCacheFromNode( node, parent = true ) {\n\n\t\tconst data = this.getDataFromNode( node );\n\t\tif ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );\n\n\t\treturn data.cache;\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @abstract\n\t * @param {String} name - The requested feature.\n\t * @return {Boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the vertexIndex input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {String} The instanceIndex shader string.\n\t */\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the instanceIndex input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {String} The instanceIndex shader string.\n\t */\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the drawIndex input variable as a native shader string.\n\t * Only relevant for WebGL and its `WEBGL_multi_draw` extension.\n\t *\n\t * @abstract\n\t * @return {String} The drawIndex shader string.\n\t */\n\tgetDrawIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the frontFacing input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {String} The frontFacing shader string.\n\t */\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the fragCoord input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {String} The fragCoord shader string.\n\t */\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not. WebGL needs\n\t * this method evaluate to `true`, WebGPU to `false`.\n\t *\n\t * @abstract\n\t * @return {Boolean} Whether to flip texture data along its vertical axis or not.\n\t */\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Calling this method increases the usage count for the given node by one.\n\t *\n\t * @param {Node} node - The node to increase the usage count for.\n\t * @return {Number} The updated usage count.\n\t */\n\tincreaseUsage( node ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tnodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n\n\t\treturn nodeData.usageCount;\n\n\t}\n\n\t/**\n\t * Generates a texture sample shader string for the given texture data.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The texture property name.\n\t * @param {String} uvSnippet - Snippet defining the texture coordinates.\n\t * @return {String} The generated shader string.\n\t */\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates a texture LOD shader string for the given texture data.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The texture property name.\n\t * @param {String} uvSnippet - Snippet defining the texture coordinates.\n\t * @param {String?} depthSnippet - Snippet defining the 0-based texture array index to sample.\n\t * @param {String} levelSnippet - Snippet defining the mip level.\n\t * @return {String} The generated shader string.\n\t */\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, depthSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates the array declaration string.\n\t *\n\t * @param {String} type - The type.\n\t * @param {Number?} [count] - The count.\n\t * @return {String} The generated value as a shader string.\n\t */\n\tgenerateArrayDeclaration( type, count ) {\n\n\t\treturn this.getType( type ) + '[ ' + count + ' ]';\n\n\t}\n\n\t/**\n\t * Generates the array shader string for the given type and value.\n\t *\n\t * @param {String} type - The type.\n\t * @param {Number?} [count] - The count.\n\t * @param {Array<Node>?} [values=null] - The default values.\n\t * @return {String} The generated value as a shader string.\n\t */\n\tgenerateArray( type, count, values = null ) {\n\n\t\tlet snippet = this.generateArrayDeclaration( type, count ) + '( ';\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst value = values ? values[ i ] : null;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tsnippet += value.build( this, type );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet += this.generateConst( type );\n\n\t\t\t}\n\n\t\t\tif ( i < count - 1 ) snippet += ', ';\n\n\t\t}\n\n\t\tsnippet += ' )';\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the struct shader string.\n\t *\n\t * @param {String} type - The type.\n\t * @param {Array<Object>} [membersLayout] - The count.\n\t * @param {Array<Node>?} [values=null] - The default values.\n\t * @return {String} The generated value as a shader string.\n\t */\n\tgenerateStruct( type, membersLayout, values = null ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of membersLayout ) {\n\n\t\t\tconst { name, type } = member;\n\n\t\t\tif ( values && values[ name ] && values[ name ].isNode ) {\n\n\t\t\t\tsnippets.push( values[ name ].build( this, type ) );\n\n\t\t\t} else {\n\n\t\t\t\tsnippets.push( this.generateConst( type ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn type + '( ' + snippets.join( ', ' ) + ' )';\n\n\t}\n\n\n\t/**\n\t * Generates the shader string for the given type and value.\n\t *\n\t * @param {String} type - The type.\n\t * @param {Any?} [value=null] - The value.\n\t * @return {String} The generated value as a shader string.\n\t */\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\t/**\n\t * It might be necessary to convert certain data types to different ones\n\t * so this method can be used to hide the conversion.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The updated type.\n\t */\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\t/**\n\t * Whether the given attribute name is defined in the geometry or not.\n\t *\n\t * @param {String} name - The attribute name.\n\t * @return {Boolean} Whether the given attribute name is defined in the geometry.\n\t */\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\t/**\n\t * Returns a node attribute for the given name and type.\n\t *\n\t * @param {String} name - The attribute's name.\n\t * @param {String} type - The attribute's type.\n\t * @return {NodeAttribute} The node attribute.\n\t */\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Returns for the given node and shader stage the property name for the shader.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The property name.\n\t */\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\t/**\n\t * Whether the given type is a vector type or not.\n\t *\n\t * @param {String} type - The type to check.\n\t * @return {Boolean} Whether the given type is a vector type or not.\n\t */\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\t/**\n\t * Whether the given type is a matrix type or not.\n\t *\n\t * @param {String} type - The type to check.\n\t * @return {Boolean} Whether the given type is a matrix type or not.\n\t */\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\t/**\n\t * Whether the given type is a reference type or not.\n\t *\n\t * @param {String} type - The type to check.\n\t * @return {Boolean} Whether the given type is a reference type or not.\n\t */\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to check.\n\t * @return {Boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the component type of a given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {String} The component type.\n\t */\n\tgetComponentTypeFromTexture( texture ) {\n\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tif ( type === IntType ) return 'int';\n\t\t\tif ( type === UnsignedIntType ) return 'uint';\n\n\t\t}\n\n\t\treturn 'float';\n\n\t}\n\n\t/**\n\t * Returns the element type for a given type.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The element type.\n\t */\n\tgetElementType( type ) {\n\n\t\tif ( type === 'mat2' ) return 'vec2';\n\t\tif ( type === 'mat3' ) return 'vec3';\n\t\tif ( type === 'mat4' ) return 'vec4';\n\n\t\treturn this.getComponentType( type );\n\n\t}\n\n\t/**\n\t * Returns the component type for a given type.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The component type.\n\t */\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\t/**\n\t * Returns the vector type for a given type.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The vector type.\n\t */\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\t/**\n\t * Returns the data type for the given the length and component type.\n\t *\n\t * @param {Number} length - The length.\n\t * @param {String} [componentType='float'] - The component type.\n\t * @return {String} The type.\n\t */\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tlet baseType = getTypeFromLength( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\t// fix edge case for mat2x2 being same size as vec4\n\t\tif ( /mat2/.test( componentType ) === true ) {\n\n\t\t\tbaseType = baseType.replace( 'vec', 'mat' );\n\n\t\t}\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\t/**\n\t * Returns the type for a given typed array.\n\t *\n\t * @param {TypedArray} array - The typed array.\n\t * @return {String} The type.\n\t */\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\t/**\n\t * Returns the type for a given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @return {String} The type.\n\t */\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\t/**\n\t * Returns the length for the given data type.\n\t *\n\t * @param {String} type - The data type.\n\t * @return {Number} The length.\n\t */\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Returns the vector type for a given matrix type.\n\t *\n\t * @param {String} type - The matrix type.\n\t * @return {String} The vector type.\n\t */\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\t/**\n\t * For a given type this method changes the component type to the\n\t * given value. E.g. `vec4` should be changed to the new component type\n\t * `uint` which results in `uvec4`.\n\t *\n\t * @param {String} type - The type.\n\t * @param {String} newComponentType - The new component type.\n\t * @return {String} The new type.\n\t */\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\t/**\n\t * Returns the integer type pendant for the given type.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The integer type.\n\t */\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\t/**\n\t * Adds a stack node to the internal stack.\n\t *\n\t * @return {StackNode} The added stack node.\n\t */\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tthis.stacks.push( getCurrentStack() || this.stack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\t/**\n\t * Removes the last stack node from the internal stack.\n\t *\n\t * @return {StackNode} The removed stack node.\n\t */\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\t/**\n\t * The builder maintains (cached) data for each node during the building process. This method\n\t * can be used to get these data for a specific shader stage and cache.\n\t *\n\t * @param {Node} node - The node to get the data for.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {NodeCache?} cache - An optional cache.\n\t * @return {Object} The node data.\n\t */\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\t/**\n\t * Returns the properties for the given node and shader stage.\n\t *\n\t * @param {Node} node - The node to get the properties for.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.\n\t * @return {Object} The node properties.\n\t */\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.\n\t *\n\t * @param {BufferAttributeNode} node - The buffer attribute node.\n\t * @param {String} type - The node type.\n\t * @return {NodeAttribute} The node attribute.\n\t */\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link StructType} for the given output struct node.\n\t *\n\t * @param {OutputStructNode} node - The output struct node.\n\t * @param {Array<Object>} membersLayout - The output struct types.\n\t * @param {String?} [name=null] - The name of the struct.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {StructType} The struct type attribute.\n\t */\n\tgetStructTypeFromNode( node, membersLayout, name = null, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet structType = nodeData.structType;\n\n\t\tif ( structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tif ( name === null ) name = 'StructType' + index;\n\n\t\t\tstructType = new StructType( name, membersLayout );\n\n\t\t\tthis.structs[ shaderStage ].push( structType );\n\n\t\t\tnodeData.structType = structType;\n\n\t\t}\n\n\t\treturn structType;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link StructType} for the given output struct node.\n\t *\n\t * @param {OutputStructNode} node - The output struct node.\n\t * @param {Array<Object>} membersLayout - The output struct types.\n\t * @return {StructType} The struct type attribute.\n\t */\n\tgetOutputStructTypeFromNode( node, membersLayout ) {\n\n\t\tconst structType = this.getStructTypeFromNode( node, membersLayout, 'OutputType', 'fragment' );\n\t\tstructType.output = true;\n\n\t\treturn structType;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeUniform} for the given uniform node.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {String} type - The uniform type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {String?} name - The name of the uniform.\n\t * @return {NodeUniform} The node uniform.\n\t */\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\t/**\n\t * Returns the array length.\n\t *\n\t * @param {Node} node - The node.\n\t * @return {Number?} The array length.\n\t */\n\tgetArrayCount( node ) {\n\n\t\tlet count = null;\n\n\t\tif ( node.isArrayNode ) count = node.count;\n\t\telse if ( node.isVarNode && node.node.isArrayNode ) count = node.node.count;\n\n\t\treturn count;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeVar} for the given variable node.\n\t *\n\t * @param {VarNode} node - The variable node.\n\t * @param {String?} name - The variable's name.\n\t * @param {String} [type=node.getNodeType( this )] - The variable's type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {Boolean} [readOnly=false] - Whether the variable is read-only or not.\n\t *\n\t * @return {NodeVar} The node variable.\n\t */\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage, readOnly = false ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst idNS = readOnly ? '_const' : '_var';\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\t\t\tconst id = this.vars[ idNS ] || ( this.vars[ idNS ] = 0 );\n\n\t\t\tif ( name === null ) {\n\n\t\t\t\tname = ( readOnly ? 'nodeConst' : 'nodeVar' ) + id;\n\n\t\t\t\tthis.vars[ idNS ] ++;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst count = this.getArrayCount( node );\n\n\t\t\tnodeVar = new NodeVar( name, type, readOnly, count );\n\n\t\t\tif ( ! readOnly ) {\n\n\t\t\t\tvars.push( nodeVar );\n\n\t\t\t}\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\t/**\n\t * Returns whether a Node or its flow is deterministic, useful for use in `const`.\n\t *\n\t * @param {Node} node - The varying node.\n\t * @return {Boolean} Returns true if deterministic.\n\t */\n\tisDeterministic( node ) {\n\n\t\tif ( node.isMathNode ) {\n\n\t\t\treturn this.isDeterministic( node.aNode ) &&\n\t\t\t\t( node.bNode ? this.isDeterministic( node.bNode ) : true ) &&\n\t\t\t\t( node.cNode ? this.isDeterministic( node.cNode ) : true );\n\n\t\t} else if ( node.isOperatorNode ) {\n\n\t\t\treturn this.isDeterministic( node.aNode ) &&\n\t\t\t\t( node.bNode ? this.isDeterministic( node.bNode ) : true );\n\n\t\t} else if ( node.isArrayNode ) {\n\n\t\t\tif ( node.values !== null ) {\n\n\t\t\t\tfor ( const n of node.values ) {\n\n\t\t\t\t\tif ( ! this.isDeterministic( n ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else if ( node.isConstNode ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeVarying} for the given varying node.\n\t *\n\t * @param {(VaryingNode|PropertyNode)} node - The varying node.\n\t * @param {String?} name - The varying's name.\n\t * @param {String} [type=node.getNodeType( this )] - The varying's type.\n\t * @return {NodeVar} The node varying.\n\t */\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\tnodeVarying = new NodeVarying( name, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeCode} for the given code node.\n\t *\n\t * @param {CodeNode} node - The code node.\n\t * @param {String} type - The node type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {NodeCode} The node code.\n\t */\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\t/**\n\t * Adds a code flow based on the code-block hierarchy.\n\n\t * This is used so that code-blocks like If,Else create their variables locally if the Node\n\t * is only used inside one of these conditionals in the current shader stage.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.\n\t */\n\taddFlowCodeHierarchy( node, nodeBlock ) {\n\n\t\tconst { flowCodes, flowCodeBlock } = this.getDataFromNode( node );\n\n\t\tlet needsFlowCode = true;\n\t\tlet nodeBlockHierarchy = nodeBlock;\n\n\t\twhile ( nodeBlockHierarchy ) {\n\n\t\t\tif ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {\n\n\t\t\t\tneedsFlowCode = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;\n\n\t\t}\n\n\t\tif ( needsFlowCode ) {\n\n\t\t\tfor ( const flowCode of flowCodes ) {\n\n\t\t\t\tthis.addLineFlowCode( flowCode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Add a inline-code to the current flow code-block.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {String} code - The code to add.\n\t * @param {Node} nodeBlock - Current ConditionalNode\n\t */\n\taddLineFlowCodeBlock( node, code, nodeBlock ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tconst flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );\n\t\tconst codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );\n\n\t\tflowCodes.push( code );\n\t\tcodeBlock.set( nodeBlock, true );\n\n\t}\n\n\t/**\n\t * Add a inline-code to the current flow.\n\t *\n\t * @param {String} code - The code to add.\n\t * @param {Node?} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddLineFlowCode( code, node = null ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tif ( node !== null && this.context.nodeBlock ) {\n\n\t\t\tthis.addLineFlowCodeBlock( node, code, this.context.nodeBlock );\n\n\t\t}\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a code to the current code flow.\n\t *\n\t * @param {String} code - Shader code.\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Add tab in the code that will be generated so that other snippets respect the current tabulation.\n\t * Typically used in codes with If,Else.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a tab.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the current flow data based on a Node.\n\t *\n\t * @param {Node} node - Node that the flow was started.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {Object} The flow data.\n\t */\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\t/**\n\t * Executes the node flow based on a root node to generate the final shader code.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @return {Object} The code flow.\n\t */\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t * It is a similar type of method like {@link NodeBuilder#getMethod}.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.\n\t * @return {FunctionNode} The build function node.\n\t */\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\t/**\n\t * Generates a code flow based on a TSL function: Fn().\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.\n\t * @return {Object}\n\t */\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tconst inputs = {\n\t\t\t[ Symbol.iterator ]() {\n\n\t\t\t\tlet index = 0;\n\t\t\t\tconst values = Object.values( this );\n\t\t\t\treturn {\n\t\t\t\t\tnext: () => ( {\n\t\t\t\t\t\tvalue: values[ index ],\n\t\t\t\t\t\tdone: index ++ >= values.length\n\t\t\t\t\t} )\n\t\t\t\t};\n\n\t\t\t}\n\t\t};\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {String?} output - Expected output type. For example 'vec3'.\n\t * @return {Object}\n\t */\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousCache = this.cache;\n\t\tconst previousBuildStage = this.buildStage;\n\t\tconst previousStack = this.stack;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\t\tthis.cache = new NodeCache();\n\t\tthis.stack = stack();\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.cache = previousCache;\n\t\tthis.stack = previousStack;\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t * It is a similar type of method like {@link NodeBuilder#getMethod}.\n\t *\n\t * @abstract\n\t * @param {String} op - The operator name to resolve.\n\t * @return {String} The resolved operator name.\n\t */\n\tgetFunctionOperator( /* op */ ) {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Generates a code flow based on a child Node.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {String?} output - Expected output type. For example 'vec3'.\n\t * @return {Object} The code flow.\n\t */\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\t/**\n\t * Executes a flow of code in a different stage.\n\t *\n\t * Some nodes like `varying()` have the ability to compute code in vertex-stage and\n\t * return the value in fragment-stage even if it is being executed in an input fragment.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @param {Node} node - The node to execute.\n\t * @param {String?} output - Expected output type. For example 'vec3'.\n\t * @param {String?} propertyName - The property name to assign the result.\n\t * @return {Object}\n\t */\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Returns an array holding all node attributes of this node builder.\n\t *\n\t * @return {Array<NodeAttribute>} The node attributes of this builder.\n\t */\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\t/**\n\t * Returns the attribute definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The attribute code section.\n\t */\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the varying definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The varying code section.\n\t */\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns a single variable definition as a shader string for the given variable type and name.\n\t *\n\t * @param {String} type - The variable's type.\n\t * @param {String} name - The variable's name.\n\t * @param {Number?} [count=null] - The array length.\n\t * @return {String} The shader string.\n\t */\n\tgetVar( type, name, count = null ) {\n\n\t\treturn `${ count !== null ? this.generateArrayDeclaration( type, count ) : this.getType( type ) } ${ name }`;\n\n\t}\n\n\t/**\n\t * Returns the variable definitions as a shader string for the given shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The variable code section.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the uniform definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The uniform code section.\n\t */\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the native code definitions as a shader string for the given shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The native code section.\n\t */\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Returns the hash of this node builder.\n\t *\n\t * @return {String} The hash.\n\t */\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\t/**\n\t * Sets the current shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')?} shaderStage - The shader stage to set.\n\t */\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\t/**\n\t * Returns the current shader stage.\n\t *\n\t * @return {('vertex'|'fragment'|'compute'|'any')?} The current shader stage.\n\t */\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\t/**\n\t * Sets the current build stage.\n\t *\n\t * @param {('setup'|'analyze'|'generate')?} buildStage - The build stage to set.\n\t */\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\t/**\n\t * Returns the current build stage.\n\t *\n\t * @return {('setup'|'analyze'|'generate')?} The current build stage.\n\t */\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t *\n\t * @abstract\n\t */\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Central build method which controls the build for the given object.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\tbuild() {\n\n\t\tconst { object, material, renderer } = this;\n\n\t\tif ( material !== null ) {\n\n\t\t\tlet nodeMaterial = renderer.library.fromMaterial( material );\n\n\t\t\tif ( nodeMaterial === null ) {\n\n\t\t\t\tconsole.error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t\t\tnodeMaterial = new NodeMaterial();\n\n\t\t\t}\n\n\t\t\tnodeMaterial.build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a uniform representation which is later used for UBO generation and rendering.\n\t *\n\t * @param {NodeUniform} uniformNode - The uniform node.\n\t * @param {String} type - The requested type.\n\t * @return {Uniform} The uniform.\n\t */\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat2' ) return new Matrix2NodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\t/**\n\t * Formats the given shader snippet from a given type into another one. E.g.\n\t * this method might be used to convert a simple float string `\"1.0\"` into a\n\t * `vec3` representation: `\"vec3<f32>( 1.0 )\"`.\n\t *\n\t * @param {String} snippet - The shader snippet.\n\t * @param {String} fromType - The source type.\n\t * @param {String} toType - The target type.\n\t * @return {String} The updated shader string.\n\t */\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength === 16 && toTypeLength === 9 ) {\n\n\t\t\treturn `${ this.getType( toType ) }(${ snippet }[0].xyz, ${ snippet }[1].xyz, ${ snippet }[2].xyz)`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 9 && toTypeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( toType ) }(${ snippet }[0].xy, ${ snippet }[1].xy)`;\n\n\t\t}\n\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\t/**\n\t * Returns a signature with the engine's current revision.\n\t *\n\t * @return {String} The signature.\n\t */\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - Node System\\n`;\n\n\t}\n\n\t// Deprecated\n\n\t/**\n\t * @function\n\t * @deprecated since r168. Use `new NodeMaterial()` instead, with targeted node material name.\n\t *\n\t * @param {String} [type='NodeMaterial'] - The node material type.\n\t * @throws {Error}\n\t */\n\tcreateNodeMaterial( type = 'NodeMaterial' ) { // @deprecated, r168\n\n\t\tthrow new Error( `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${ type }() instead.` );\n\n\t}\n\n}\n\n/**\n * Management class for updating nodes. The module tracks metrics like\n * the elapsed time, delta time, the render and frame ID to correctly\n * call the node update methods {@link Node#updateBefore}, {@link Node#update}\n * and {@link Node#updateAfter} depending on the node's configuration.\n */\nclass NodeFrame {\n\n\t/**\n\t * Constructs a new node fame.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The elapsed time in seconds.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.time = 0;\n\n\t\t/**\n\t\t * The delta time in seconds.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.deltaTime = 0;\n\n\t\t/**\n\t\t * The frame ID.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.frameId = 0;\n\n\t\t/**\n\t\t * The render ID.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderId = 0;\n\n\t\t/**\n\t\t * Used to control the {@link Node#update} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateMap = new WeakMap();\n\n\t\t/**\n\t\t * Used to control the {@link Node#updateBefore} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateBeforeMap = new WeakMap();\n\n\t\t/**\n\t\t * Used to control the {@link Node#updateAfter} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateAfterMap = new WeakMap();\n\n\t\t/**\n\t\t * A reference to the current renderer.\n\t\t *\n\t\t * @type {Renderer?}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = null;\n\n\t\t/**\n\t\t * A reference to the current material.\n\t\t *\n\t\t * @type {Material?}\n\t\t * @default null\n\t\t */\n\t\tthis.material = null;\n\n\t\t/**\n\t\t * A reference to the current camera.\n\t\t *\n\t\t * @type {Camera?}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * A reference to the current 3D object.\n\t\t *\n\t\t * @type {Object3D?}\n\t\t * @default null\n\t\t */\n\t\tthis.object = null;\n\n\t\t/**\n\t\t * A reference to the current scene.\n\t\t *\n\t\t * @type {Scene?}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = null;\n\n\t}\n\n\t/**\n\t * Returns a dictionary for a given node and update map which\n\t * is used to correctly call node update methods per frame or render.\n\t *\n\t * @private\n\t * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.\n\t * @param {Node} nodeRef - The reference to the current node.\n\t * @return {Object<String,WeakMap>} The dictionary.\n\t */\n\t_getMaps( referenceMap, nodeRef ) {\n\n\t\tlet maps = referenceMap.get( nodeRef );\n\n\t\tif ( maps === undefined ) {\n\n\t\t\tmaps = {\n\t\t\t\trenderMap: new WeakMap(),\n\t\t\t\tframeMap: new WeakMap()\n\t\t\t};\n\n\t\t\treferenceMap.set( nodeRef, maps );\n\n\t\t}\n\n\t\treturn maps;\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#updateBefore} for the given node.\n\t * It makes sure {@link Node#updateBeforeType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateBeforeNode( node ) {\n\n\t\tconst updateType = node.getUpdateBeforeType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateBefore( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#updateAfter} for the given node.\n\t * It makes sure {@link Node#updateAfterType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateAfterNode( node ) {\n\n\t\tconst updateType = node.getUpdateAfterType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateAfter( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#update} for the given node.\n\t * It makes sure {@link Node#updateType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateNode( node ) {\n\n\t\tconst updateType = node.getUpdateType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.update( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the internal state of the node frame. This method is\n\t * called by the renderer in its internal animation loop.\n\t */\n\tupdate() {\n\n\t\tthis.frameId ++;\n\n\t\tif ( this.lastTime === undefined ) this.lastTime = performance.now();\n\n\t\tthis.deltaTime = ( performance.now() - this.lastTime ) / 1000;\n\n\t\tthis.lastTime = performance.now();\n\n\t\tthis.time += this.deltaTime;\n\n\t}\n\n}\n\n/**\n * Describes the input of a {@link NodeFunction}.\n */\nclass NodeFunctionInput {\n\n\t/**\n\t * Constructs a new node function input.\n\t *\n\t * @param {String} type - The input type.\n\t * @param {String} name - The input name.\n\t * @param {Number?} [count=null] - If the input is an Array, count will be the length.\n\t * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).\n\t * @param {Boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).\n\t */\n\tconstructor( type, name, count = null, qualifier = '', isConst = false ) {\n\n\t\t/**\n\t\t *  The input type.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The input name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * If the input is an Array, count will be the length.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t *The parameter qualifier (only relevant for GLSL).\n\t\t *\n\t\t * @type {('in'|'out'|'inout')}\n\t\t * @default ''\n\t\t */\n\t\tthis.qualifier = qualifier;\n\n\t\t/**\n\t\t * Whether the input uses a const qualifier or not (only relevant for GLSL).\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isConst = isConst;\n\n\t}\n\n}\n\nNodeFunctionInput.isNodeFunctionInput = true;\n\n/**\n * Module for representing directional lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass DirectionalLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'DirectionalLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new directional light node.\n\t *\n\t * @param {DirectionalLight?} [light=null] - The directional light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst lightColor = this.colorNode;\n\t\tconst lightDirection = lightTargetDirection( this.light );\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.direct( {\n\t\t\tlightDirection,\n\t\t\tlightColor,\n\t\t\treflectedLight\n\t\t}, builder.stack, builder );\n\n\t}\n\n}\n\nconst _matrix41 = /*@__PURE__*/ new Matrix4();\nconst _matrix42 = /*@__PURE__*/ new Matrix4();\n\nlet _ltcLib = null;\n\n/**\n * Module for representing rect area lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass RectAreaLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'RectAreaLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new rect area light node.\n\t *\n\t * @param {RectAreaLight?} [light=null] - The rect area light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the half height of the are light.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the half width of the are light.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * The `updateType` is set to `NodeUpdateType.RENDER` since the light\n\t\t * relies on `viewMatrix` which might vary per render call.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t}\n\n\t/**\n\t * Overwritten to updated rect area light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tconst viewMatrix = frame.camera.matrixWorldInverse;\n\n\t\t_matrix42.identity();\n\t\t_matrix41.copy( light.matrixWorld );\n\t\t_matrix41.premultiply( viewMatrix );\n\t\t_matrix42.extractRotation( _matrix41 );\n\n\t\tthis.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );\n\t\tthis.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\tthis.halfWidth.value.applyMatrix4( _matrix42 );\n\t\tthis.halfHeight.value.applyMatrix4( _matrix42 );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tlet ltc_1, ltc_2;\n\n\t\tif ( builder.isAvailable( 'float32Filterable' ) ) {\n\n\t\t\tltc_1 = texture( _ltcLib.LTC_FLOAT_1 );\n\t\t\tltc_2 = texture( _ltcLib.LTC_FLOAT_2 );\n\n\t\t} else {\n\n\t\t\tltc_1 = texture( _ltcLib.LTC_HALF_1 );\n\t\t\tltc_2 = texture( _ltcLib.LTC_HALF_2 );\n\n\t\t}\n\n\t\tconst { colorNode, light } = this;\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst lightPosition = lightViewPosition( light );\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.directRectArea( {\n\t\t\tlightColor: colorNode,\n\t\t\tlightPosition,\n\t\t\thalfWidth: this.halfWidth,\n\t\t\thalfHeight: this.halfHeight,\n\t\t\treflectedLight,\n\t\t\tltc_1,\n\t\t\tltc_2\n\t\t}, builder.stack, builder );\n\n\t}\n\n\t/**\n\t * Used to configure the internal BRDF approximation texture data.\n\t *\n\t * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.\n\t */\n\tstatic setLTC( ltc ) {\n\n\t\t_ltcLib = ltc;\n\n\t}\n\n}\n\n/**\n * Module for representing spot lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass SpotLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'SpotLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new spot light node.\n\t *\n\t * @param {SpotLight?} [light=null] - The spot light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the cone cosine.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.coneCosNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the penumbra cosine.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the cutoff distance.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the decay exponent.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.decayExponentNode = uniform( 0 ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated spot light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tthis.coneCosNode.value = Math.cos( light.angle );\n\t\tthis.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\t/**\n\t * Computes the spot attenuation for the given angle.\n\t *\n\t * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.\n\t * @return {Node<float>} The spot attenuation.\n\t */\n\tgetSpotAttenuation( angleCosine ) {\n\n\t\tconst { coneCosNode, penumbraCosNode } = this;\n\n\t\treturn smoothstep( coneCosNode, penumbraCosNode, angleCosine );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;\n\n\t\tconst lVector = lightViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode\n\n\t\tconst lightDirection = lVector.normalize();\n\t\tconst angleCos = lightDirection.dot( lightTargetDirection( light ) );\n\t\tconst spotAttenuation = this.getSpotAttenuation( angleCos );\n\n\t\tconst lightDistance = lVector.length();\n\n\t\tconst lightAttenuation = getDistanceAttenuation( {\n\t\t\tlightDistance,\n\t\t\tcutoffDistance: cutoffDistanceNode,\n\t\t\tdecayExponent: decayExponentNode\n\t\t} );\n\n\t\tlet lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );\n\n\t\tif ( light.map ) {\n\n\t\t\tconst spotLightCoord = lightProjectionUV( light );\n\t\t\tconst projectedTexture = texture( light.map, spotLightCoord.xy ).onRenderUpdate( () => light.map );\n\n\t\t\tconst inSpotLightMap = spotLightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();\n\n\t\t\tlightColor = inSpotLightMap.select( lightColor.mul( projectedTexture ), lightColor );\n\n\t\t}\n\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.direct( {\n\t\t\tlightDirection,\n\t\t\tlightColor,\n\t\t\treflectedLight\n\t\t}, builder.stack, builder );\n\n\t}\n\n}\n\n/**\n * An IES version of the default spot light node.\n *\n * @augments SpotLightNode\n */\nclass IESSpotLightNode extends SpotLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'IESSpotLightNode';\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to compute an IES conform spot attenuation.\n\t *\n\t * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.\n\t * @return {Node<float>} The spot attenuation.\n\t */\n\tgetSpotAttenuation( angleCosine ) {\n\n\t\tconst iesMap = this.light.iesMap;\n\n\t\tlet spotAttenuation = null;\n\n\t\tif ( iesMap && iesMap.isTexture === true ) {\n\n\t\t\tconst angle = angleCosine.acos().mul( 1.0 / Math.PI );\n\n\t\t\tspotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;\n\n\t\t} else {\n\n\t\t\tspotAttenuation = super.getSpotAttenuation( angleCosine );\n\n\t\t}\n\n\t\treturn spotAttenuation;\n\n\t}\n\n}\n\n/**\n * Module for representing ambient lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass AmbientLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'AmbientLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new ambient light node.\n\t *\n\t * @param {AmbientLight?} [light=null] - The ambient light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tcontext.irradiance.addAssign( this.colorNode );\n\n\t}\n\n}\n\n/**\n * Module for representing hemisphere lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass HemisphereLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'HemisphereLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new hemisphere light node.\n\t *\n\t * @param {HemisphereLight?} [light=null] - The hemisphere light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the light's position.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.lightPositionNode = lightPosition( light );\n\n\t\t/**\n\t\t * A node representing the light's direction.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.lightDirectionNode = this.lightPositionNode.normalize();\n\n\t\t/**\n\t\t * Uniform node representing the light's ground color.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.groundColorNode = uniform( new Color() ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated hemisphere light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.lightPositionNode.object3d = light;\n\n\t\tthis.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode, groundColorNode, lightDirectionNode } = this;\n\n\t\tconst dotNL = normalView.dot( lightDirectionNode );\n\t\tconst hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );\n\n\t\tconst irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\n/**\n * Module for representing light probes as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass LightProbeNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightProbeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new light probe node.\n\t *\n\t * @param {LightProbe?} [light=null] - The light probe.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tconst array = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );\n\n\t\t/**\n\t\t * Light probe represented as a uniform of spherical harmonics.\n\t\t *\n\t\t * @type {UniformArrayNode}\n\t\t */\n\t\tthis.lightProbe = uniformArray( array );\n\n\t}\n\n\t/**\n\t * Overwritten to updated light probe specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst irradiance = getShIrradianceAt( normalWorld, this.lightProbe );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\n/**\n * Base class for node parsers. A derived parser must be implemented\n * for each supported native shader language.\n */\nclass NodeParser {\n\n\t/**\n\t * The method parses the given native code an returns a node function.\n\t *\n\t * @abstract\n\t * @param {String} source - The native shader code.\n\t * @return {NodeFunction} A node function.\n\t */\n\tparseFunction( /*source*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\n/**\n * Base class for node functions. A derived module must be implemented\n * for each supported native shader language. Similar to other `Node*` modules,\n * this class is only relevant during the building process and not used\n * in user-level code.\n */\nclass NodeFunction {\n\n\t/**\n\t * Constructs a new node function.\n\t *\n\t * @param {String} type - The node type. This type is the return type of the node function.\n\t * @param {Array<NodeFunctionInput>} inputs - The function's inputs.\n\t * @param {String} [name=''] - The function's name.\n\t * @param {String} [precision=''] - The precision qualifier.\n\t */\n\tconstructor( type, inputs, name = '', precision = '' ) {\n\n\t\t/**\n\t\t * The node type. This type is the return type of the node function.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The function's inputs.\n\t\t *\n\t\t * @type {Array<NodeFunctionInput>}\n\t\t */\n\t\tthis.inputs = inputs;\n\n\t\t/**\n\t\t * The name of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The precision qualifier.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.precision = precision;\n\n\t}\n\n\t/**\n\t * This method returns the native code of the node function.\n\t *\n\t * @abstract\n\t * @param {String} name - The function's name.\n\t * @return {String} A shader code.\n\t */\n\tgetCode( /*name = this.name*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nNodeFunction.isNodeFunction = true;\n\nconst declarationRegexp$1 = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp$1 = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse$1 = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp$1 );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tprecision,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a GLSL node function.\n *\n * @augments NodeFunction\n */\nclass GLSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new GLSL node function.\n\t *\n\t * @param {String} source - The GLSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );\n\n\t\tsuper( type, inputs, name, precision );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\t/**\n\t * This method returns the GLSL code of the node function.\n\t *\n\t * @param {String} [name=this.name] - The function's name.\n\t * @return {String} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, precision } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( precision !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ precision } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\n/**\n * A GLSL node parser.\n *\n * @augments NodeParser\n */\nclass GLSLNodeParser extends NodeParser {\n\n\t/**\n\t * The method parses the given GLSL code an returns a node function.\n\t *\n\t * @param {String} source - The GLSL code.\n\t * @return {GLSLNodeFunction} A node function.\n\t */\n\tparseFunction( source ) {\n\n\t\treturn new GLSLNodeFunction( source );\n\n\t}\n\n}\n\nconst _outputNodeMap = new WeakMap();\nconst _chainKeys$2 = [];\nconst _cacheKeyValues = [];\n\n/**\n * This renderer module manages node-related objects and is the\n * primary interface between the renderer and the node system.\n *\n * @private\n * @augments DataMap\n */\nclass Nodes extends DataMap {\n\n\t/**\n\t * Constructs a new nodes management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Backend} backend - The renderer's backend.\n\t */\n\tconstructor( renderer, backend ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * The node frame.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.nodeFrame = new NodeFrame();\n\n\t\t/**\n\t\t * A cache for managing node builder states.\n\t\t *\n\t\t * @type {Map<Number,NodeBuilderState>}\n\t\t */\n\t\tthis.nodeBuilderCache = new Map();\n\n\t\t/**\n\t\t * A cache for managing data cache key data.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.callHashCache = new ChainMap();\n\n\t\t/**\n\t\t * A cache for managing node uniforms group data.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.groupsData = new ChainMap();\n\n\t\t/**\n\t\t * A cache for managing node objects of\n\t\t * scene properties like fog or environments.\n\t\t *\n\t\t * @type {Object<String,WeakMap>}\n\t\t */\n\t\tthis.cacheLib = {};\n\n\t}\n\n\t/**\n\t * Returns `true` if the given node uniforms group must be updated or not.\n\t *\n\t * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.\n\t * @return {Boolean} Whether the node uniforms group requires an update or not.\n\t */\n\tupdateGroup( nodeUniformsGroup ) {\n\n\t\tconst groupNode = nodeUniformsGroup.groupNode;\n\t\tconst name = groupNode.name;\n\n\t\t// objectGroup is always updated\n\n\t\tif ( name === objectGroup.name ) return true;\n\n\t\t// renderGroup is updated once per render/compute call\n\n\t\tif ( name === renderGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst renderId = this.nodeFrame.renderId;\n\n\t\t\tif ( uniformsGroupData.renderId !== renderId ) {\n\n\t\t\t\tuniformsGroupData.renderId = renderId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// frameGroup is updated once per frame\n\n\t\tif ( name === frameGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst frameId = this.nodeFrame.frameId;\n\n\t\t\tif ( uniformsGroupData.frameId !== frameId ) {\n\n\t\t\t\tuniformsGroupData.frameId = frameId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// other groups are updated just when groupNode.needsUpdate is true\n\n\t\t_chainKeys$2[ 0 ] = groupNode;\n\t\t_chainKeys$2[ 1 ] = nodeUniformsGroup;\n\n\t\tlet groupData = this.groupsData.get( _chainKeys$2 );\n\t\tif ( groupData === undefined ) this.groupsData.set( _chainKeys$2, groupData = {} );\n\n\t\t_chainKeys$2.length = 0;\n\n\t\tif ( groupData.version !== groupNode.version ) {\n\n\t\t\tgroupData.version = groupNode.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the cache key for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Number} The cache key.\n\t */\n\tgetForRenderCacheKey( renderObject ) {\n\n\t\treturn renderObject.initialCacheKey;\n\n\t}\n\n\t/**\n\t * Returns a node builder state for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetForRender( renderObject ) {\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet nodeBuilderState = renderObjectData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst { nodeBuilderCache } = this;\n\n\t\t\tconst cacheKey = this.getForRenderCacheKey( renderObject );\n\n\t\t\tnodeBuilderState = nodeBuilderCache.get( cacheKey );\n\n\t\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );\n\t\t\t\tnodeBuilder.scene = renderObject.scene;\n\t\t\t\tnodeBuilder.material = renderObject.material;\n\t\t\t\tnodeBuilder.camera = renderObject.camera;\n\t\t\t\tnodeBuilder.context.material = renderObject.material;\n\t\t\t\tnodeBuilder.lightsNode = renderObject.lightsNode;\n\t\t\t\tnodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );\n\t\t\t\tnodeBuilder.fogNode = this.getFogNode( renderObject.scene );\n\t\t\t\tnodeBuilder.clippingContext = renderObject.clippingContext;\n\t\t\t\tnodeBuilder.build();\n\n\t\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\t\tnodeBuilderCache.set( cacheKey, nodeBuilderState );\n\n\t\t\t}\n\n\t\t\tnodeBuilderState.usedTimes ++;\n\n\t\t\trenderObjectData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t/**\n\t * Deletes the given object from the internal data map\n\t *\n\t * @param {Any} object - The object to delete.\n\t * @return {Object?} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tif ( object.isRenderObject ) {\n\n\t\t\tconst nodeBuilderState = this.get( object ).nodeBuilderState;\n\t\t\tnodeBuilderState.usedTimes --;\n\n\t\t\tif ( nodeBuilderState.usedTimes === 0 ) {\n\n\t\t\t\tthis.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\t/**\n\t * Returns a node builder state for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetForCompute( computeNode ) {\n\n\t\tconst computeData = this.get( computeNode );\n\n\t\tlet nodeBuilderState = computeData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );\n\t\t\tnodeBuilder.build();\n\n\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\tcomputeData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t/**\n\t * Creates a node builder state for the given node builder.\n\t *\n\t * @private\n\t * @param {NodeBuilder} nodeBuilder - The node builder.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\t_createNodeBuilderState( nodeBuilder ) {\n\n\t\treturn new NodeBuilderState(\n\t\t\tnodeBuilder.vertexShader,\n\t\t\tnodeBuilder.fragmentShader,\n\t\t\tnodeBuilder.computeShader,\n\t\t\tnodeBuilder.getAttributesArray(),\n\t\t\tnodeBuilder.getBindings(),\n\t\t\tnodeBuilder.updateNodes,\n\t\t\tnodeBuilder.updateBeforeNodes,\n\t\t\tnodeBuilder.updateAfterNodes,\n\t\t\tnodeBuilder.observer,\n\t\t\tnodeBuilder.transforms\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns an environment node for the current configured\n\t * scene environment.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene environment.\n\t */\n\tgetEnvironmentNode( scene ) {\n\n\t\tthis.updateEnvironment( scene );\n\n\t\tlet environmentNode = null;\n\n\t\tif ( scene.environmentNode && scene.environmentNode.isNode ) {\n\n\t\t\tenvironmentNode = scene.environmentNode;\n\n\t\t} else {\n\n\t\t\tconst sceneData = this.get( scene );\n\n\t\t\tif ( sceneData.environmentNode ) {\n\n\t\t\t\tenvironmentNode = sceneData.environmentNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn environmentNode;\n\n\t}\n\n\t/**\n\t * Returns a background node for the current configured\n\t * scene background.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene background.\n\t */\n\tgetBackgroundNode( scene ) {\n\n\t\tthis.updateBackground( scene );\n\n\t\tlet backgroundNode = null;\n\n\t\tif ( scene.backgroundNode && scene.backgroundNode.isNode ) {\n\n\t\t\tbackgroundNode = scene.backgroundNode;\n\n\t\t} else {\n\n\t\t\tconst sceneData = this.get( scene );\n\n\t\t\tif ( sceneData.backgroundNode ) {\n\n\t\t\t\tbackgroundNode = sceneData.backgroundNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn backgroundNode;\n\n\t}\n\n\t/**\n\t * Returns a fog node for the current configured scene fog.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene fog.\n\t */\n\tgetFogNode( scene ) {\n\n\t\tthis.updateFog( scene );\n\n\t\treturn scene.fogNode || this.get( scene ).fogNode || null;\n\n\t}\n\n\t/**\n\t * Returns a cache key for the given scene and lights node.\n\t * This key is used by `RenderObject` as a part of the dynamic\n\t * cache key (a key that must be checked every time the render\n\t * objects is drawn).\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @return {Number} The cache key.\n\t */\n\tgetCacheKey( scene, lightsNode ) {\n\n\t\t_chainKeys$2[ 0 ] = scene;\n\t\t_chainKeys$2[ 1 ] = lightsNode;\n\n\t\tconst callId = this.renderer.info.calls;\n\n\t\tconst cacheKeyData = this.callHashCache.get( _chainKeys$2 ) || {};\n\n\t\tif ( cacheKeyData.callId !== callId ) {\n\n\t\t\tconst environmentNode = this.getEnvironmentNode( scene );\n\t\t\tconst fogNode = this.getFogNode( scene );\n\n\t\t\tif ( lightsNode ) _cacheKeyValues.push( lightsNode.getCacheKey( true ) );\n\t\t\tif ( environmentNode ) _cacheKeyValues.push( environmentNode.getCacheKey() );\n\t\t\tif ( fogNode ) _cacheKeyValues.push( fogNode.getCacheKey() );\n\n\t\t\t_cacheKeyValues.push( this.renderer.shadowMap.enabled ? 1 : 0 );\n\n\t\t\tcacheKeyData.callId = callId;\n\t\t\tcacheKeyData.cacheKey = hashArray( _cacheKeyValues );\n\n\t\t\tthis.callHashCache.set( _chainKeys$2, cacheKeyData );\n\n\t\t\t_cacheKeyValues.length = 0;\n\n\t\t}\n\n\t\t_chainKeys$2.length = 0;\n\n\t\treturn cacheKeyData.cacheKey;\n\n\t}\n\n\t/**\n\t * A boolean that indicates whether tone mapping should be enabled\n\t * or not.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isToneMappingState() {\n\n\t\treturn this.renderer.getRenderTarget() ? false : true;\n\n\t}\n\n\t/**\n\t * If a scene background is configured, this method makes sure to\n\t * represent the background with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateBackground( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tconst forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );\n\n\t\t\tif ( sceneData.background !== background || forceUpdate ) {\n\n\t\t\t\tconst backgroundNode = this.getCacheNode( 'background', background, () => {\n\n\t\t\t\t\tif ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\t\t\t\tif ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {\n\n\t\t\t\t\t\t\treturn pmremTexture( background );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet envMap;\n\n\t\t\t\t\t\t\tif ( background.isCubeTexture === true ) {\n\n\t\t\t\t\t\t\t\tenvMap = cubeTexture( background );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tenvMap = texture( background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn cubeMapNode( envMap );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( background.isTexture === true ) {\n\n\t\t\t\t\t\treturn texture( background, screenUV.flipY() ).setUpdateMatrix( true );\n\n\t\t\t\t\t} else if ( background.isColor !== true ) {\n\n\t\t\t\t\t\tconsole.error( 'WebGPUNodes: Unsupported background configuration.', background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, forceUpdate );\n\n\t\t\t\tsceneData.backgroundNode = backgroundNode;\n\t\t\t\tsceneData.background = background;\n\t\t\t\tsceneData.backgroundBlurriness = scene.backgroundBlurriness;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.backgroundNode ) {\n\n\t\t\tdelete sceneData.backgroundNode;\n\t\t\tdelete sceneData.background;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is part of the caching of nodes which are used to represents the\n\t * scene's background, fog or environment.\n\t *\n\t * @param {String} type - The type of object to cache.\n\t * @param {Object} object - The object.\n\t * @param {Function} callback - A callback that produces a node representation for the given object.\n\t * @param {Boolean} [forceUpdate=false] - Whether an update should be enforced or not.\n\t * @return {Node} The node representation.\n\t */\n\tgetCacheNode( type, object, callback, forceUpdate = false ) {\n\n\t\tconst nodeCache = this.cacheLib[ type ] || ( this.cacheLib[ type ] = new WeakMap() );\n\n\t\tlet node = nodeCache.get( object );\n\n\t\tif ( node === undefined || forceUpdate ) {\n\n\t\t\tnode = callback();\n\t\t\tnodeCache.set( object, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * If a scene fog is configured, this method makes sure to\n\t * represent the fog with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateFog( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst sceneFog = scene.fog;\n\n\t\tif ( sceneFog ) {\n\n\t\t\tif ( sceneData.fog !== sceneFog ) {\n\n\t\t\t\tconst fogNode = this.getCacheNode( 'fog', sceneFog, () => {\n\n\t\t\t\t\tif ( sceneFog.isFogExp2 ) {\n\n\t\t\t\t\t\tconst color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst density = reference( 'density', 'float', sceneFog ).setGroup( renderGroup );\n\n\t\t\t\t\t\treturn fog( color, densityFogFactor( density ) );\n\n\t\t\t\t\t} else if ( sceneFog.isFog ) {\n\n\t\t\t\t\t\tconst color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst near = reference( 'near', 'float', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst far = reference( 'far', 'float', sceneFog ).setGroup( renderGroup );\n\n\t\t\t\t\t\treturn fog( color, rangeFogFactor( near, far ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.Renderer: Unsupported fog configuration.', sceneFog );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tsceneData.fogNode = fogNode;\n\t\t\t\tsceneData.fog = sceneFog;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdelete sceneData.fogNode;\n\t\t\tdelete sceneData.fog;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * If a scene environment is configured, this method makes sure to\n\t * represent the environment with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateEnvironment( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst environment = scene.environment;\n\n\t\tif ( environment ) {\n\n\t\t\tif ( sceneData.environment !== environment ) {\n\n\t\t\t\tconst environmentNode = this.getCacheNode( 'environment', environment, () => {\n\n\t\t\t\t\tif ( environment.isCubeTexture === true ) {\n\n\t\t\t\t\t\treturn cubeTexture( environment );\n\n\t\t\t\t\t} else if ( environment.isTexture === true ) {\n\n\t\t\t\t\t\treturn texture( environment );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'Nodes: Unsupported environment configuration.', environment );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tsceneData.environmentNode = environmentNode;\n\t\t\t\tsceneData.environment = environment;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.environmentNode ) {\n\n\t\t\tdelete sceneData.environmentNode;\n\t\t\tdelete sceneData.environment;\n\n\t\t}\n\n\t}\n\n\tgetNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {\n\n\t\tconst nodeFrame = this.nodeFrame;\n\t\tnodeFrame.renderer = renderer;\n\t\tnodeFrame.scene = scene;\n\t\tnodeFrame.object = object;\n\t\tnodeFrame.camera = camera;\n\t\tnodeFrame.material = material;\n\n\t\treturn nodeFrame;\n\n\t}\n\n\tgetNodeFrameForRender( renderObject ) {\n\n\t\treturn this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );\n\n\t}\n\n\t/**\n\t * Returns the current output cache key.\n\t *\n\t * @return {String} The output cache key.\n\t */\n\tgetOutputCacheKey() {\n\n\t\tconst renderer = this.renderer;\n\n\t\treturn renderer.toneMapping + ',' + renderer.currentColorSpace;\n\n\t}\n\n\t/**\n\t * Checks if the output configuration (tone mapping and color space) for\n\t * the given target has changed.\n\t *\n\t * @param {Texture} outputTarget - The output target.\n\t * @return {Boolean} Whether the output configuration has changed or not.\n\t */\n\thasOutputChange( outputTarget ) {\n\n\t\tconst cacheKey = _outputNodeMap.get( outputTarget );\n\n\t\treturn cacheKey !== this.getOutputCacheKey();\n\n\t}\n\n\t/**\n\t * Returns a node that represents the output configuration (tone mapping and\n\t * color space) for the current target.\n\t *\n\t * @param {Texture} outputTarget - The output target.\n\t * @return {Node} The output node.\n\t */\n\tgetOutputNode( outputTarget ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst cacheKey = this.getOutputCacheKey();\n\n\t\tconst output = texture( outputTarget, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );\n\n\t\t_outputNodeMap.set( outputTarget, cacheKey );\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Triggers the call of `updateBefore()` methods\n\t * for all nodes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateBefore( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateBeforeNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateBeforeNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `updateAfter()` methods\n\t * for all nodes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateAfter( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateAfterNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateAfterNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `update()` methods\n\t * for all nodes of the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tupdateForCompute( computeNode ) {\n\n\t\tconst nodeFrame = this.getNodeFrame();\n\t\tconst nodeBuilder = this.getForCompute( computeNode );\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `update()` methods\n\t * for all nodes of the given compute node.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object requires a refresh.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the given render object requires a refresh or not.\n\t */\n\tneedsRefresh( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst monitor = renderObject.getMonitor();\n\n\t\treturn monitor.needsRefresh( renderObject, nodeFrame );\n\n\t}\n\n\t/**\n\t * Frees the internal resources.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.nodeFrame = new NodeFrame();\n\t\tthis.nodeBuilderCache = new Map();\n\t\tthis.cacheLib = {};\n\n\t}\n\n}\n\nconst _plane = /*@__PURE__*/ new Plane();\n\n/**\n * Represents the state that is used to perform clipping via clipping planes.\n * There is a default clipping context for each render context. When the\n * scene holds instances of `ClippingGroup`, there will be a context for each\n * group.\n *\n * @private\n */\nclass ClippingContext {\n\n\t/**\n\t * Constructs a new clipping context.\n\t *\n\t * @param {ClippingContext?} [parentContext=null] - A reference to the parent clipping context.\n\t */\n\tconstructor( parentContext = null ) {\n\n\t\t/**\n\t\t * The clipping context's version.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * Whether the intersection of the clipping planes is used to clip objects, rather than their union.\n\t\t *\n\t\t * @type {Boolean?}\n\t\t * @default null\n\t\t */\n\t\tthis.clipIntersection = null;\n\n\t\t/**\n\t\t * The clipping context's cache key.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.cacheKey = '';\n\n\t\t/**\n\t\t * Whether the shadow pass is active or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.shadowPass = false;\n\n\t\t/**\n\t\t * The view normal matrix.\n\t\t *\n\t\t * @type {Matrix3}\n\t\t */\n\t\tthis.viewNormalMatrix = new Matrix3();\n\n\t\t/**\n\t\t * Internal cache for maintaining clipping contexts.\n\t\t *\n\t\t * @type {WeakMap<ClippingGroup,ClippingContext>}\n\t\t */\n\t\tthis.clippingGroupContexts = new WeakMap();\n\n\t\t/**\n\t\t * The intersection planes.\n\t\t *\n\t\t * @type {Array<Vector4>}\n\t\t */\n\t\tthis.intersectionPlanes = [];\n\n\t\t/**\n\t\t * The intersection planes.\n\t\t *\n\t\t * @type {Array<Vector4>}\n\t\t */\n\t\tthis.unionPlanes = [];\n\n\t\t/**\n\t\t * The version of the clipping context's parent context.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @readonly\n\t\t */\n\t\tthis.parentVersion = null;\n\n\t\tif ( parentContext !== null ) {\n\n\t\t\tthis.viewNormalMatrix = parentContext.viewNormalMatrix;\n\t\t\tthis.clippingGroupContexts = parentContext.clippingGroupContexts;\n\n\t\t\tthis.shadowPass = parentContext.shadowPass;\n\t\t\tthis.viewMatrix = parentContext.viewMatrix;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Projects the given source clipping planes and writes the result into the\n\t * destination array.\n\t *\n\t * @param {Array<Plane>} source - The source clipping planes.\n\t * @param {Array<Vector4>} destination - The destination.\n\t * @param {Number} offset - The offset.\n\t */\n\tprojectPlanes( source, destination, offset ) {\n\n\t\tconst l = source.length;\n\n\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t_plane.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );\n\n\t\t\tconst v = destination[ offset + i ];\n\t\t\tconst normal = _plane.normal;\n\n\t\t\tv.x = - normal.x;\n\t\t\tv.y = - normal.y;\n\t\t\tv.z = - normal.z;\n\t\t\tv.w = _plane.constant;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the root clipping context of a scene.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t */\n\tupdateGlobal( scene, camera ) {\n\n\t\tthis.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial );\n\t\tthis.viewMatrix = camera.matrixWorldInverse;\n\n\t\tthis.viewNormalMatrix.getNormalMatrix( this.viewMatrix );\n\n\t}\n\n\t/**\n\t * Updates the clipping context.\n\t *\n\t * @param {ClippingContext} parentContext - The parent context.\n\t * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.\n\t */\n\tupdate( parentContext, clippingGroup ) {\n\n\t\tlet update = false;\n\n\t\tif ( parentContext.version !== this.parentVersion ) {\n\n\t\t\tthis.intersectionPlanes = Array.from( parentContext.intersectionPlanes );\n\t\t\tthis.unionPlanes = Array.from( parentContext.unionPlanes );\n\t\t\tthis.parentVersion = parentContext.version;\n\n\t\t}\n\n\t\tif ( this.clipIntersection !== clippingGroup.clipIntersection ) {\n\n\t\t\tthis.clipIntersection = clippingGroup.clipIntersection;\n\n\t\t\tif ( this.clipIntersection ) {\n\n\t\t\t\tthis.unionPlanes.length = parentContext.unionPlanes.length;\n\n\t\t\t} else {\n\n\t\t\t\tthis.intersectionPlanes.length = parentContext.intersectionPlanes.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst srcClippingPlanes = clippingGroup.clippingPlanes;\n\t\tconst l = srcClippingPlanes.length;\n\n\t\tlet dstClippingPlanes;\n\t\tlet offset;\n\n\t\tif ( this.clipIntersection ) {\n\n\t\t\tdstClippingPlanes = this.intersectionPlanes;\n\t\t\toffset = parentContext.intersectionPlanes.length;\n\n\t\t} else {\n\n\t\t\tdstClippingPlanes = this.unionPlanes;\n\t\t\toffset = parentContext.unionPlanes.length;\n\n\t\t}\n\n\t\tif ( dstClippingPlanes.length !== offset + l ) {\n\n\t\t\tdstClippingPlanes.length = offset + l;\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tdstClippingPlanes[ offset + i ] = new Vector4();\n\n\t\t\t}\n\n\t\t\tupdate = true;\n\n\t\t}\n\n\t\tthis.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );\n\n\t\tif ( update ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a clipping context for the given clipping group.\n\t *\n\t * @param {ClippingGroup} clippingGroup - The clipping group.\n\t * @return {ClippingContext} The clipping context.\n\t */\n\tgetGroupContext( clippingGroup ) {\n\n\t\tif ( this.shadowPass && ! clippingGroup.clipShadows ) return this;\n\n\t\tlet context = this.clippingGroupContexts.get( clippingGroup );\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ClippingContext( this );\n\t\t\tthis.clippingGroupContexts.set( clippingGroup, context );\n\n\t\t}\n\n\t\tcontext.update( this, clippingGroup );\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * The count of union clipping planes.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget unionClippingCount() {\n\n\t\treturn this.unionPlanes.length;\n\n\t}\n\n}\n\n/**\n * This module is used to represent render bundles inside the renderer\n * for further processing.\n *\n * @private\n */\nclass RenderBundle {\n\n\t/**\n\t * Constructs a new bundle group.\n\t *\n\t * @param {BundleGroup} bundleGroup - The bundle group.\n\t * @param {Camera} camera - The camera the bundle group is rendered with.\n\t */\n\tconstructor( bundleGroup, camera ) {\n\n\t\tthis.bundleGroup = bundleGroup;\n\t\tthis.camera = camera;\n\n\t}\n\n}\n\nconst _chainKeys$1 = [];\n\n/**\n * This renderer module manages render bundles.\n *\n * @private\n */\nclass RenderBundles {\n\n\t/**\n\t * Constructs a new render bundle management component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A chain map for maintaining the render bundles.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.bundles = new ChainMap();\n\n\t}\n\n\t/**\n\t * Returns a render bundle for the given bundle group and camera.\n\t *\n\t * @param {BundleGroup} bundleGroup - The bundle group.\n\t * @param {Camera} camera - The camera the bundle group is rendered with.\n\t * @return {RenderBundle} The render bundle.\n\t */\n\tget( bundleGroup, camera ) {\n\n\t\tconst bundles = this.bundles;\n\n\t\t_chainKeys$1[ 0 ] = bundleGroup;\n\t\t_chainKeys$1[ 1 ] = camera;\n\n\t\tlet bundle = bundles.get( _chainKeys$1 );\n\n\t\tif ( bundle === undefined ) {\n\n\t\t\tbundle = new RenderBundle( bundleGroup, camera );\n\t\t\tbundles.set( _chainKeys$1, bundle );\n\n\t\t}\n\n\t\t_chainKeys$1.length = 0;\n\n\t\treturn bundle;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.bundles = new ChainMap();\n\n\t}\n\n}\n\n/**\n * The purpose of a node library is to assign node implementations\n * to existing library features. In `WebGPURenderer` lights, materials\n * which are not based on `NodeMaterial` as well as tone mapping techniques\n * are implemented with node-based modules.\n *\n * @private\n */\nclass NodeLibrary {\n\n\t/**\n\t * Constructs a new node library.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A weak map that maps lights to light nodes.\n\t\t *\n\t\t * @type {WeakMap<Light.constructor,AnalyticLightNode.constructor>}\n\t\t */\n\t\tthis.lightNodes = new WeakMap();\n\n\t\t/**\n\t\t * A map that maps materials to node materials.\n\t\t *\n\t\t * @type {Map<String,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.materialNodes = new Map();\n\n\t\t/**\n\t\t * A map that maps tone mapping techniques (constants)\n\t\t * to tone mapping node functions.\n\t\t *\n\t\t * @type {Map<Number,Function>}\n\t\t */\n\t\tthis.toneMappingNodes = new Map();\n\n\t}\n\n\t/**\n\t * Returns a matching node material instance for the given material object.\n\t *\n\t * This method also assigns/copies the properties of the given material object\n\t * to the node material. This is done to make sure the current material\n\t * configuration carries over to the node version.\n\t *\n\t * @param {Material} material - A material.\n\t * @return {NodeMaterial} The corresponding node material.\n\t */\n\tfromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial ) return material;\n\n\t\tlet nodeMaterial = null;\n\n\t\tconst nodeMaterialClass = this.getMaterialNodeClass( material.type );\n\n\t\tif ( nodeMaterialClass !== null ) {\n\n\t\t\tnodeMaterial = new nodeMaterialClass();\n\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n\t/**\n\t * Adds a tone mapping node function for a tone mapping technique (constant).\n\t *\n\t * @param {Function} toneMappingNode - The tone mapping node function.\n\t * @param {Number} toneMapping - The tone mapping.\n\t */\n\taddToneMapping( toneMappingNode, toneMapping ) {\n\n\t\tthis.addType( toneMappingNode, toneMapping, this.toneMappingNodes );\n\n\t}\n\n\t/**\n\t * Returns a tone mapping node function for a tone mapping technique (constant).\n\t *\n\t * @param {Number} toneMapping - The tone mapping.\n\t * @return {Function?} The tone mapping node function. Returns `null` if no node function is found.\n\t */\n\tgetToneMappingFunction( toneMapping ) {\n\n\t\treturn this.toneMappingNodes.get( toneMapping ) || null;\n\n\t}\n\n\t/**\n\t * Returns a node material class definition for a material type.\n\t *\n\t * @param {String} materialType - The material type.\n\t * @return {NodeMaterial.constructor?} The node material class definition. Returns `null` if no node material is found.\n\t */\n\tgetMaterialNodeClass( materialType ) {\n\n\t\treturn this.materialNodes.get( materialType ) || null;\n\n\t}\n\n\t/**\n\t * Adds a node material class definition for a given material type.\n\t *\n\t * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.\n\t * @param {String} materialClassType - The material type.\n\t */\n\taddMaterial( materialNodeClass, materialClassType ) {\n\n\t\tthis.addType( materialNodeClass, materialClassType, this.materialNodes );\n\n\t}\n\n\t/**\n\t * Returns a light node class definition for a light class definition.\n\t *\n\t * @param {Light.constructor} light - The light class definition.\n\t * @return {AnalyticLightNode.constructor?} The light node class definition. Returns `null` if no light node is found.\n\t */\n\tgetLightNodeClass( light ) {\n\n\t\treturn this.lightNodes.get( light ) || null;\n\n\t}\n\n\t/**\n\t * Adds a light node class definition for a given light class definition.\n\t *\n\t * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.\n\t * @param {Light.constructor} lightClass - The light class definition.\n\t */\n\taddLight( lightNodeClass, lightClass ) {\n\n\t\tthis.addClass( lightNodeClass, lightClass, this.lightNodes );\n\n\t}\n\n\t/**\n\t * Adds a node class definition for the given type to the provided type library.\n\t *\n\t * @param {Any} nodeClass - The node class definition.\n\t * @param {Number|String} type - The object type.\n\t * @param {Map} library - The type library.\n\t */\n\taddType( nodeClass, type, library ) {\n\n\t\tif ( library.has( type ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ type }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );\n\n\t\tlibrary.set( type, nodeClass );\n\n\t}\n\n\t/**\n\t * Adds a node class definition for the given class definition to the provided type library.\n\t *\n\t * @param {Any} nodeClass - The node class definition.\n\t * @param {Any} baseClass - The class definition.\n\t * @param {WeakMap} library - The type library.\n\t */\n\taddClass( nodeClass, baseClass, library ) {\n\n\t\tif ( library.has( baseClass ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ baseClass.name }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );\n\n\t\tlibrary.set( baseClass, nodeClass );\n\n\t}\n\n}\n\nconst _defaultLights = /*@__PURE__*/ new LightsNode();\nconst _chainKeys = [];\n\n/**\n * This renderer module manages the lights nodes which are unique\n * per scene and camera combination.\n *\n * The lights node itself is later configured in the render list\n * with the actual lights from the scene.\n *\n * @private\n * @augments ChainMap\n */\nclass Lighting extends ChainMap {\n\n\t/**\n\t * Constructs a lighting management component.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\t/**\n\t * Creates a new lights node for the given array of lights.\n\t *\n\t * @param {Array<Light>} lights - The render object.\n\t * @return {LightsNode} The lights node.\n\t */\n\tcreateNode( lights = [] ) {\n\n\t\treturn new LightsNode().setLights( lights );\n\n\t}\n\n\t/**\n\t * Returns a lights node for the given scene and camera.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera.\n\t * @return {LightsNode} The lights node.\n\t */\n\tgetNode( scene, camera ) {\n\n\t\t// ignore post-processing\n\n\t\tif ( scene.isQuadMesh ) return _defaultLights;\n\n\t\t_chainKeys[ 0 ] = scene;\n\t\t_chainKeys[ 1 ] = camera;\n\n\t\tlet node = this.get( _chainKeys );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = this.createNode();\n\t\t\tthis.set( _chainKeys, node );\n\n\t\t}\n\n\t\t_chainKeys.length = 0;\n\n\t\treturn node;\n\n\t}\n\n}\n\n/**\n * A special type of render target that is used when rendering\n * with the WebXR Device API.\n *\n * @private\n * @augments RenderTarget\n */\nclass XRRenderTarget extends RenderTarget {\n\n\t/**\n\t * Constructs a new XR render target.\n\t *\n\t * @param {Number} [width=1] - The width of the render target.\n\t * @param {Number} [height=1] - The height of the render target.\n\t * @param {Object} [options={}] - The configuration options.\n\t */\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isXRRenderTarget = true;\n\n\t\t/**\n\t\t * Whether the attachments of the render target\n\t\t * are defined by external textures. This flag is\n\t\t * set to `true` when using the WebXR Layers API.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.hasExternalTextures = false;\n\n\t\t/**\n\t\t * Whether a depth buffer should automatically be allocated\n\t\t * for this XR render target or not.\n\t\t *\n\t\t * Allocating a depth buffer is the default behavior of XR render\n\t\t * targets. However, when using the WebXR Layers API, this flag\n\t\t * must be set to `false` when the `ignoreDepthValues` property of\n\t\t * the projection layers evaluates to `false`.\n\t\t *\n\t\t * Reference: {@link https://www.w3.org/TR/webxrlayers-1/#dom-xrprojectionlayer-ignoredepthvalues}.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoAllocateDepthBuffer = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.hasExternalTextures = source.hasExternalTextures;\n\t\tthis.autoAllocateDepthBuffer = source.autoAllocateDepthBuffer;\n\n\t\treturn this;\n\n\t}\n\n\n}\n\nconst _cameraLPos = /*@__PURE__*/ new Vector3();\nconst _cameraRPos = /*@__PURE__*/ new Vector3();\n\n/**\n * The XR manager is built on top of the WebXR Device API to\n * manage XR sessions with `WebGPURenderer`.\n *\n * XR is currently only supported with a WebGL 2 backend.\n *\n * @augments EventDispatcher\n */\nclass XRManager extends EventDispatcher {\n\n\t/**\n\t * Constructs a new XR manager.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( renderer ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag globally enables XR rendering.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.enabled = false;\n\n\t\t/**\n\t\t * Whether the XR device is currently presenting or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.isPresenting = false;\n\n\t\t/**\n\t\t * Whether the XR camera should automatically be updated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.cameraAutoUpdate = true;\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @private\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis._renderer = renderer;\n\n\t\t// camera\n\n\t\t/**\n\t\t * Represents the camera for the left eye.\n\t\t *\n\t\t * @private\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis._cameraL = new PerspectiveCamera();\n\t\tthis._cameraL.viewport = new Vector4();\n\n\t\t/**\n\t\t * Represents the camera for the right eye.\n\t\t *\n\t\t * @private\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis._cameraR = new PerspectiveCamera();\n\t\tthis._cameraR.viewport = new Vector4();\n\n\t\t/**\n\t\t * A list of cameras used for rendering the XR views.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Camera>}\n\t\t */\n\t\tthis._cameras = [ this._cameraL, this._cameraR ];\n\n\t\t/**\n\t\t * The main XR camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ArrayCamera}\n\t\t */\n\t\tthis._cameraXR = new ArrayCamera();\n\n\t\t/**\n\t\t * The current near value of the XR camera.\n\t\t *\n\t\t * @private\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentDepthNear = null;\n\n\t\t/**\n\t\t * The current far value of the XR camera.\n\t\t *\n\t\t * @private\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentDepthFar = null;\n\n\t\t/**\n\t\t * A list of WebXR controllers requested by the application.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<WebXRController>}\n\t\t */\n\t\tthis._controllers = [];\n\n\t\t/**\n\t\t * A list of XR input source. Each input source belongs to\n\t\t * an instance of WebXRController.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<XRInputSource?>}\n\t\t */\n\t\tthis._controllerInputSources = [];\n\n\t\t/**\n\t\t * The current render target of the renderer.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderTarget = null;\n\n\t\t/**\n\t\t * The XR render target that represents the rendering destination\n\t\t * during an active XR session.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis._xrRenderTarget = null;\n\n\t\t/**\n\t\t * The current animation context.\n\t\t *\n\t\t * @private\n\t\t * @type {Window?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentAnimationContext = null;\n\n\t\t/**\n\t\t * The current animation loop.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentAnimationLoop = null;\n\n\t\t/**\n\t\t * The current pixel ratio.\n\t\t *\n\t\t * @private\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentPixelRatio = null;\n\n\t\t/**\n\t\t * The current size of the renderer's canvas\n\t\t * in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector2}\n\t\t */\n\t\tthis._currentSize = new Vector2();\n\n\t\t/**\n\t\t * The default event listener for handling events inside a XR session.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onSessionEvent = onSessionEvent.bind( this );\n\n\t\t/**\n\t\t * The event listener for handling the end of a XR session.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onSessionEnd = onSessionEnd.bind( this );\n\n\t\t/**\n\t\t * The event listener for handling the `inputsourceschange` event.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onInputSourcesChange = onInputSourcesChange.bind( this );\n\n\t\t/**\n\t\t * The animation loop which is used as a replacement for the default\n\t\t * animation loop of the applicatio. It is only used when a XR session\n\t\t * is active.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onAnimationFrame = onAnimationFrame.bind( this );\n\n\t\t/**\n\t\t * The current XR reference space.\n\t\t *\n\t\t * @private\n\t\t * @type {XRReferenceSpace?}\n\t\t * @default null\n\t\t */\n\t\tthis._referenceSpace = null;\n\n\t\t/**\n\t\t * The current XR reference space type.\n\t\t *\n\t\t * @private\n\t\t * @type {String}\n\t\t * @default 'local-floor'\n\t\t */\n\t\tthis._referenceSpaceType = 'local-floor';\n\n\t\t/**\n\t\t * A custom reference space defined by the application.\n\t\t *\n\t\t * @private\n\t\t * @type {XRReferenceSpace?}\n\t\t * @default null\n\t\t */\n\t\tthis._customReferenceSpace = null;\n\n\t\t/**\n\t\t * The framebuffer scale factor.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._framebufferScaleFactor = 1;\n\n\t\t/**\n\t\t * The foveation factor.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._foveation = 1.0;\n\n\t\t/**\n\t\t * A reference to the current XR session.\n\t\t *\n\t\t * @private\n\t\t * @type {XRSession?}\n\t\t * @default null\n\t\t */\n\t\tthis._session = null;\n\n\t\t/**\n\t\t * A reference to the current XR base layer.\n\t\t *\n\t\t * @private\n\t\t * @type {XRWebGLLayer?}\n\t\t * @default null\n\t\t */\n\t\tthis._glBaseLayer = null;\n\n\t\t/**\n\t\t * A reference to the current XR binding.\n\t\t *\n\t\t * @private\n\t\t * @type {XRWebGLBinding?}\n\t\t * @default null\n\t\t */\n\t\tthis._glBinding = null;\n\n\t\t/**\n\t\t * A reference to the current XR projection layer.\n\t\t *\n\t\t * @private\n\t\t * @type {XRProjectionLayer?}\n\t\t * @default null\n\t\t */\n\t\tthis._glProjLayer = null;\n\n\t\t/**\n\t\t * A reference to the current XR frame.\n\t\t *\n\t\t * @private\n\t\t * @type {XRFrame?}\n\t\t * @default null\n\t\t */\n\t\tthis._xrFrame = null;\n\n\t\t/**\n\t\t * Whether to use the WebXR Layers API or not.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t */\n\t\tthis._useLayers = ( typeof XRWebGLBinding !== 'undefined' && 'createProjectionLayer' in XRWebGLBinding.prototype ); // eslint-disable-line compat/compat\n\n\t}\n\n\t/**\n\t * Returns an instance of `THREE.Group` that represents the transformation\n\t * of a XR controller in target ray space. The requested controller is defined\n\t * by the given index.\n\t *\n\t * @param {Number} index - The index of the XR controller.\n\t * @return {Group} A group that represents the controller's transformation.\n\t */\n\tgetController( index ) {\n\n\t\tconst controller = this._getController( index );\n\n\t\treturn controller.getTargetRaySpace();\n\n\t}\n\n\t/**\n\t * Returns an instance of `THREE.Group` that represents the transformation\n\t * of a XR controller in grip space. The requested controller is defined\n\t * by the given index.\n\t *\n\t * @param {Number} index - The index of the XR controller.\n\t * @return {Group} A group that represents the controller's transformation.\n\t */\n\tgetControllerGrip( index ) {\n\n\t\tconst controller = this._getController( index );\n\n\t\treturn controller.getGripSpace();\n\n\t}\n\n\t/**\n\t * Returns an instance of `THREE.Group` that represents the transformation\n\t * of a XR controller in hand space. The requested controller is defined\n\t * by the given index.\n\t *\n\t * @param {Number} index - The index of the XR controller.\n\t * @return {Group} A group that represents the controller's transformation.\n\t */\n\tgetHand( index ) {\n\n\t\tconst controller = this._getController( index );\n\n\t\treturn controller.getHandSpace();\n\n\t}\n\n\t/**\n\t * Returns the foveation value.\n\t *\n\t * @return {Number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.\n\t */\n\tgetFoveation() {\n\n\t\tif ( this._glProjLayer === null && this._glBaseLayer === null ) {\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\treturn this._foveation;\n\n\t}\n\n\t/**\n\t * Sets the foveation value.\n\t *\n\t * @param {Number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)\n\t * and `1` means maximum foveation (the edges render at lower resolution).\n\t */\n\tsetFoveation( foveation ) {\n\n\t\tthis._foveation = foveation;\n\n\t\tif ( this._glProjLayer !== null ) {\n\n\t\t\tthis._glProjLayer.fixedFoveation = foveation;\n\n\t\t}\n\n\t\tif ( this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== undefined ) {\n\n\t\t\tthis._glBaseLayer.fixedFoveation = foveation;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the framebuffer scale factor.\n\t *\n\t * @return {Number} The framebuffer scale factor.\n\t */\n\tgetFramebufferScaleFactor() {\n\n\t\treturn this._framebufferScaleFactor;\n\n\t}\n\n\t/**\n\t * Sets the framebuffer scale factor.\n\t *\n\t * This method can not be used during a XR session.\n\t *\n\t * @param {Number} factor - The framebuffer scale factor.\n\t */\n\tsetFramebufferScaleFactor( factor ) {\n\n\t\tthis._framebufferScaleFactor = factor;\n\n\t\tif ( this.isPresenting === true ) {\n\n\t\t\tconsole.warn( 'THREE.XRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the reference space type.\n\t *\n\t * @return {String} The reference space type.\n\t */\n\tgetReferenceSpaceType() {\n\n\t\treturn this._referenceSpaceType;\n\n\t}\n\n\t/**\n\t * Sets the reference space type.\n\t *\n\t * This method can not be used during a XR session.\n\t *\n\t * @param {String} type - The reference space type.\n\t */\n\tsetReferenceSpaceType( type ) {\n\n\t\tthis._referenceSpaceType = type;\n\n\t\tif ( this.isPresenting === true ) {\n\n\t\t\tconsole.warn( 'THREE.XRManager: Cannot change reference space type while presenting.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the XR reference space.\n\t *\n\t * @return {XRReferenceSpace} The XR reference space.\n\t */\n\tgetReferenceSpace() {\n\n\t\treturn this._customReferenceSpace || this._referenceSpace;\n\n\t}\n\n\t/**\n\t * Sets a custom XR reference space.\n\t *\n\t * @param {XRReferenceSpace} space - The XR reference space.\n\t */\n\tsetReferenceSpace( space ) {\n\n\t\tthis._customReferenceSpace = space;\n\n\t}\n\n\t/**\n\t * Returns the XR camera.\n\t *\n\t * @return {ArrayCamera} The XR camera.\n\t */\n\tgetCamera() {\n\n\t\treturn this._cameraXR;\n\n\t}\n\n\t/**\n\t * Returns the environment blend mode from the current XR session.\n\t *\n\t * @return {('opaque'|'additive'|'alpha-blend')?} The environment blend mode. Returns `null` when used outside of a XR session.\n\t */\n\tgetEnvironmentBlendMode() {\n\n\t\tif ( this._session !== null ) {\n\n\t\t\treturn this._session.environmentBlendMode;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the current XR frame.\n\t *\n\t * @return {XRFrame?} The XR frame. Returns `null` when used outside a XR session.\n\t */\n\tgetFrame() {\n\n\t\treturn this._xrFrame;\n\n\t}\n\n\t/**\n\t * Returns the current XR session.\n\t *\n\t * @return {XRSession?} The XR session. Returns `null` when used outside a XR session.\n\t */\n\tgetSession() {\n\n\t\treturn this._session;\n\n\t}\n\n\t/**\n\t * After a XR session has been requested usually with one of the `*Button` modules, it\n\t * is injected into the renderer with this method. This method triggers the start of\n\t * the actual XR rendering.\n\t *\n\t * @async\n\t * @param {XRSession} session - The XR session to set.\n\t * @return {Promise} A Promise that resolves when the session has been set.\n\t */\n\tasync setSession( session ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst backend = renderer.backend;\n\n\t\tconst gl = renderer.getContext();\n\n\t\tthis._session = session;\n\n\t\tif ( session !== null ) {\n\n\t\t\tif ( backend.isWebGPUBackend === true ) throw new Error( 'THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing \"{ forceWebGL: true }\" to the constructor of the renderer.' );\n\n\t\t\tthis._currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tsession.addEventListener( 'select', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'selectstart', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'selectend', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'squeeze', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'squeezestart', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'squeezeend', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'end', this._onSessionEnd );\n\t\t\tsession.addEventListener( 'inputsourceschange', this._onInputSourcesChange );\n\n\t\t\tawait backend.makeXRCompatible();\n\n\t\t\tthis._currentPixelRatio = renderer.getPixelRatio();\n\t\t\trenderer.getSize( this._currentSize );\n\n\t\t\tthis._currentAnimationContext = renderer._animation.getContext();\n\t\t\tthis._currentAnimationLoop = renderer._animation.getAnimationLoop();\n\t\t\trenderer._animation.stop();\n\n\t\t\t//\n\n\t\t\tif ( this._useLayers === true ) {\n\n\t\t\t\t// default path using XRWebGLBinding/XRProjectionLayer\n\n\t\t\t\tlet depthFormat = null;\n\t\t\t\tlet depthType = null;\n\t\t\t\tlet glDepthFormat = null;\n\n\t\t\t\tif ( renderer.depth ) {\n\n\t\t\t\t\tglDepthFormat = renderer.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\t\t\t\t\tdepthFormat = renderer.stencil ? DepthStencilFormat : DepthFormat;\n\t\t\t\t\tdepthType = renderer.stencil ? UnsignedInt248Type : UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tconst projectionlayerInit = {\n\t\t\t\t\tcolorFormat: gl.RGBA8,\n\t\t\t\t\tdepthFormat: glDepthFormat,\n\t\t\t\t\tscaleFactor: this._framebufferScaleFactor\n\t\t\t\t};\n\n\t\t\t\tconst glBinding = new XRWebGLBinding( session, gl );\n\t\t\t\tconst glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );\n\n\t\t\t\tthis._glBinding = glBinding;\n\t\t\t\tthis._glProjLayer = glProjLayer;\n\n\t\t\t\tsession.updateRenderState( { layers: [ glProjLayer ] } );\n\n\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\trenderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );\n\n\t\t\t\tthis._xrRenderTarget = new XRRenderTarget(\n\t\t\t\t\tglProjLayer.textureWidth,\n\t\t\t\t\tglProjLayer.textureHeight,\n\t\t\t\t\t{\n\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\tdepthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),\n\t\t\t\t\t\tstencilBuffer: renderer.stencil,\n\t\t\t\t\t\tsamples: renderer.samples\n\t\t\t\t\t} );\n\n\t\t\t\tthis._xrRenderTarget.hasExternalTextures = true;\n\n\t\t\t} else {\n\n\t\t\t\t// fallback to XRWebGLLayer\n\n\t\t\t\tconst layerInit = {\n\t\t\t\t\tantialias: renderer.samples > 0,\n\t\t\t\t\talpha: true,\n\t\t\t\t\tdepth: renderer.depth,\n\t\t\t\t\tstencil: renderer.stencil,\n\t\t\t\t\tframebufferScaleFactor: this.getFramebufferScaleFactor()\n\t\t\t\t};\n\n\t\t\t\tconst glBaseLayer = new XRWebGLLayer( session, gl, layerInit );\n\t\t\t\tthis._glBaseLayer = glBaseLayer;\n\n\t\t\t\tsession.updateRenderState( { baseLayer: glBaseLayer } );\n\n\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\trenderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );\n\n\t\t\t\tthis._xrRenderTarget = new XRRenderTarget(\n\t\t\t\t\tglBaseLayer.framebufferWidth,\n\t\t\t\t\tglBaseLayer.framebufferHeight,\n\t\t\t\t\t{\n\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\tstencilBuffer: renderer.stencil\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tthis.setFoveation( this.getFoveation() );\n\n\t\t\tthis._referenceSpace = await session.requestReferenceSpace( this.getReferenceSpaceType() );\n\n\t\t\trenderer._animation.setAnimationLoop( this._onAnimationFrame );\n\t\t\trenderer._animation.setContext( session );\n\t\t\trenderer._animation.start();\n\n\t\t\tthis.isPresenting = true;\n\n\t\t\tthis.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is called by the renderer per frame and updates the XR camera\n\t * and it sub cameras based on the given camera. The given camera is the \"user\"\n\t * camera created on application level and used for non-XR rendering.\n\t *\n\t * @param {PerspectiveCamera} camera - The camera.\n\t */\n\tupdateCamera( camera ) {\n\n\t\tconst session = this._session;\n\n\t\tif ( session === null ) return;\n\n\t\tconst depthNear = camera.near;\n\t\tconst depthFar = camera.far;\n\n\t\tconst cameraXR = this._cameraXR;\n\t\tconst cameraL = this._cameraL;\n\t\tconst cameraR = this._cameraR;\n\n\t\tcameraXR.near = cameraR.near = cameraL.near = depthNear;\n\t\tcameraXR.far = cameraR.far = cameraL.far = depthFar;\n\n\t\tif ( this._currentDepthNear !== cameraXR.near || this._currentDepthFar !== cameraXR.far ) {\n\n\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\tsession.updateRenderState( {\n\t\t\t\tdepthNear: cameraXR.near,\n\t\t\t\tdepthFar: cameraXR.far\n\t\t\t} );\n\n\t\t\tthis._currentDepthNear = cameraXR.near;\n\t\t\tthis._currentDepthFar = cameraXR.far;\n\n\t\t}\n\n\t\tcameraL.layers.mask = camera.layers.mask | 0b010;\n\t\tcameraR.layers.mask = camera.layers.mask | 0b100;\n\t\tcameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;\n\n\t\tconst parent = camera.parent;\n\t\tconst cameras = cameraXR.cameras;\n\n\t\tupdateCamera( cameraXR, parent );\n\n\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t}\n\n\t\t// update projection matrix for proper view frustum culling\n\n\t\tif ( cameras.length === 2 ) {\n\n\t\t\tsetProjectionFromUnion( cameraXR, cameraL, cameraR );\n\n\t\t} else {\n\n\t\t\t// assume single camera setup (AR)\n\n\t\t\tcameraXR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t}\n\n\t\t// update user camera and its children\n\n\t\tupdateUserCamera( camera, cameraXR, parent );\n\n\n\t}\n\n\t/**\n\t * Returns a WebXR controller for the given controller index.\n\t *\n\t * @private\n\t * @param {Number} index - The controller index.\n\t * @return {WebXRController} The XR controller.\n\t */\n\t_getController( index ) {\n\n\t\tlet controller = this._controllers[ index ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new WebXRController();\n\t\t\tthis._controllers[ index ] = controller;\n\n\t\t}\n\n\t\treturn controller;\n\n\t}\n\n}\n\n/**\n * Assumes 2 cameras that are parallel and share an X-axis, and that\n * the cameras' projection and world matrices have already been set.\n * And that near and far planes are identical for both cameras.\n * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n *\n * @param {ArrayCamera} camera - The camera to update.\n * @param {PerspectiveCamera} cameraL - The left camera.\n * @param {PerspectiveCamera} cameraR - The right camera.\n */\nfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t_cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t_cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\tconst ipd = _cameraLPos.distanceTo( _cameraRPos );\n\n\tconst projL = cameraL.projectionMatrix.elements;\n\tconst projR = cameraR.projectionMatrix.elements;\n\n\t// VR systems will have identical far and near planes, and\n\t// most likely identical top and bottom frustum extents.\n\t// Use the left camera for these values.\n\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\tconst left = near * leftFov;\n\tconst right = near * rightFov;\n\n\t// Calculate the new camera's position offset from the\n\t// left camera. xOffset should be roughly half `ipd`.\n\tconst zOffset = ipd / ( - leftFov + rightFov );\n\tconst xOffset = zOffset * - leftFov;\n\n\t// TODO: Better way to apply this offset?\n\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\tcamera.translateX( xOffset );\n\tcamera.translateZ( zOffset );\n\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t// Check if the projection uses an infinite far plane.\n\tif ( projL[ 10 ] === - 1.0 ) {\n\n\t\t// Use the projection matrix from the left eye.\n\t\t// The camera offset is sufficient to include the view volumes\n\t\t// of both eyes (assuming symmetric projections).\n\t\tcamera.projectionMatrix.copy( cameraL.projectionMatrix );\n\t\tcamera.projectionMatrixInverse.copy( cameraL.projectionMatrixInverse );\n\n\t} else {\n\n\t\t// Find the union of the frustum values of the cameras and scale\n\t\t// the values so that the near plane's position does not change in world space,\n\t\t// although must now be relative to the new union camera.\n\t\tconst near2 = near + zOffset;\n\t\tconst far2 = far + zOffset;\n\t\tconst left2 = left - xOffset;\n\t\tconst right2 = right + ( ipd - xOffset );\n\t\tconst top2 = topFov * far / far2 * near2;\n\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\n\t}\n\n}\n\n/**\n * Updates the world matrices for the given camera based on the parent 3D object.\n *\n * @inner\n * @param {Camera} camera - The camera to update.\n * @param {Object3D} parent - The parent 3D object.\n */\nfunction updateCamera( camera, parent ) {\n\n\tif ( parent === null ) {\n\n\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t} else {\n\n\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t}\n\n\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n}\n\n/**\n * Updates the given camera with the transfomration of the XR camera and parent object.\n *\n * @inner\n * @param {Camera} camera - The camera to update.\n * @param {ArrayCamera} cameraXR - The XR camera.\n * @param {Object3D} parent - The parent 3D object.\n */\nfunction updateUserCamera( camera, cameraXR, parent ) {\n\n\tif ( parent === null ) {\n\n\t\tcamera.matrix.copy( cameraXR.matrixWorld );\n\n\t} else {\n\n\t\tcamera.matrix.copy( parent.matrixWorld );\n\t\tcamera.matrix.invert();\n\t\tcamera.matrix.multiply( cameraXR.matrixWorld );\n\n\t}\n\n\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\tcamera.updateMatrixWorld( true );\n\n\tcamera.projectionMatrix.copy( cameraXR.projectionMatrix );\n\tcamera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );\n\n\tif ( camera.isPerspectiveCamera ) {\n\n\t\tcamera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );\n\t\tcamera.zoom = 1;\n\n\t}\n\n}\n\nfunction onSessionEvent( event ) {\n\n\tconst controllerIndex = this._controllerInputSources.indexOf( event.inputSource );\n\n\tif ( controllerIndex === - 1 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst controller = this._controllers[ controllerIndex ];\n\n\tif ( controller !== undefined ) {\n\n\t\tconst referenceSpace = this.getReferenceSpace();\n\n\t\tcontroller.update( event.inputSource, event.frame, referenceSpace );\n\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t}\n\n}\n\nfunction onSessionEnd() {\n\n\tconst session = this._session;\n\tconst renderer = this._renderer;\n\n\tsession.removeEventListener( 'select', this._onSessionEvent );\n\tsession.removeEventListener( 'selectstart', this._onSessionEvent );\n\tsession.removeEventListener( 'selectend', this._onSessionEvent );\n\tsession.removeEventListener( 'squeeze', this._onSessionEvent );\n\tsession.removeEventListener( 'squeezestart', this._onSessionEvent );\n\tsession.removeEventListener( 'squeezeend', this._onSessionEvent );\n\tsession.removeEventListener( 'end', this._onSessionEnd );\n\tsession.removeEventListener( 'inputsourceschange', this._onInputSourcesChange );\n\n\tfor ( let i = 0; i < this._controllers.length; i ++ ) {\n\n\t\tconst inputSource = this._controllerInputSources[ i ];\n\n\t\tif ( inputSource === null ) continue;\n\n\t\tthis._controllerInputSources[ i ] = null;\n\n\t\tthis._controllers[ i ].disconnect( inputSource );\n\n\t}\n\n\tthis._currentDepthNear = null;\n\tthis._currentDepthFar = null;\n\n\t// restore framebuffer/rendering state\n\n\trenderer.backend.setXRTarget( null );\n\trenderer.setRenderTarget( this._currentRenderTarget );\n\n\tthis._session = null;\n\tthis._xrRenderTarget = null;\n\n\t//\n\n\tthis.isPresenting = false;\n\n\trenderer._animation.stop();\n\n\trenderer._animation.setAnimationLoop( this._currentAnimationLoop );\n\trenderer._animation.setContext( this._currentAnimationContext );\n\trenderer._animation.start();\n\n\trenderer.setPixelRatio( this._currentPixelRatio );\n\trenderer.setSize( this._currentSize.width, this._currentSize.height, false );\n\n\tthis.dispatchEvent( { type: 'sessionend' } );\n\n}\n\nfunction onInputSourcesChange( event ) {\n\n\tconst controllers = this._controllers;\n\tconst controllerInputSources = this._controllerInputSources;\n\n\t// Notify disconnected\n\n\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\tconst inputSource = event.removed[ i ];\n\t\tconst index = controllerInputSources.indexOf( inputSource );\n\n\t\tif ( index >= 0 ) {\n\n\t\t\tcontrollerInputSources[ index ] = null;\n\t\t\tcontrollers[ index ].disconnect( inputSource );\n\n\t\t}\n\n\t}\n\n\t// Notify connected\n\n\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\tconst inputSource = event.added[ i ];\n\n\t\tlet controllerIndex = controllerInputSources.indexOf( inputSource );\n\n\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t// Assign input source a controller that currently has no input source\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tif ( i >= controllerInputSources.length ) {\n\n\t\t\t\t\tcontrollerInputSources.push( inputSource );\n\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if ( controllerInputSources[ i ] === null ) {\n\n\t\t\t\t\tcontrollerInputSources[ i ] = inputSource;\n\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If all controllers do currently receive input we ignore new ones\n\n\t\t\tif ( controllerIndex === - 1 ) break;\n\n\t\t}\n\n\t\tconst controller = controllers[ controllerIndex ];\n\n\t\tif ( controller ) {\n\n\t\t\tcontroller.connect( inputSource );\n\n\t\t}\n\n\t}\n\n}\n\nfunction onAnimationFrame( time, frame ) {\n\n\tif ( frame === undefined ) return;\n\n\tconst cameraXR = this._cameraXR;\n\tconst renderer = this._renderer;\n\tconst backend = renderer.backend;\n\n\tconst glBaseLayer = this._glBaseLayer;\n\n\tconst referenceSpace = this.getReferenceSpace();\n\tconst pose = frame.getViewerPose( referenceSpace );\n\n\tthis._xrFrame = frame;\n\n\tif ( pose !== null ) {\n\n\t\tconst views = pose.views;\n\n\t\tif ( this._glBaseLayer !== null ) {\n\n\t\t\tbackend.setXRTarget( glBaseLayer.framebuffer );\n\n\t\t}\n\n\t\tlet cameraXRNeedsUpdate = false;\n\n\t\t// check if it's necessary to rebuild cameraXR's camera list\n\n\t\tif ( views.length !== cameraXR.cameras.length ) {\n\n\t\t\tcameraXR.cameras.length = 0;\n\t\t\tcameraXRNeedsUpdate = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\tconst view = views[ i ];\n\n\t\t\tlet viewport;\n\n\t\t\tif ( this._useLayers === true ) {\n\n\t\t\t\tconst glSubImage = this._glBinding.getViewSubImage( this._glProjLayer, view );\n\t\t\t\tviewport = glSubImage.viewport;\n\n\t\t\t\t// For side-by-side projection, we only produce a single texture for both eyes.\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tbackend.setXRRenderTargetTextures(\n\t\t\t\t\t\tthis._xrRenderTarget,\n\t\t\t\t\t\tglSubImage.colorTexture,\n\t\t\t\t\t\tthis._glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tviewport = glBaseLayer.getViewport( view );\n\n\t\t\t}\n\n\t\t\tlet camera = this._cameras[ i ];\n\n\t\t\tif ( camera === undefined ) {\n\n\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\tcamera.layers.enable( i );\n\t\t\t\tcamera.viewport = new Vector4();\n\t\t\t\tthis._cameras[ i ] = camera;\n\n\t\t\t}\n\n\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tcameraXR.matrix.copy( camera.matrix );\n\t\t\t\tcameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );\n\n\t\t\t}\n\n\t\t\tif ( cameraXRNeedsUpdate === true ) {\n\n\t\t\t\tcameraXR.cameras.push( camera );\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this._xrRenderTarget );\n\n\t}\n\n\t//\n\n\tfor ( let i = 0; i < this._controllers.length; i ++ ) {\n\n\t\tconst inputSource = this._controllerInputSources[ i ];\n\t\tconst controller = this._controllers[ i ];\n\n\t\tif ( inputSource !== null && controller !== undefined ) {\n\n\t\t\tcontroller.update( inputSource, frame, referenceSpace );\n\n\t\t}\n\n\t}\n\n\tif ( this._currentAnimationLoop ) this._currentAnimationLoop( time, frame );\n\n\tif ( frame.detectedPlanes ) {\n\n\t\tthis.dispatchEvent( { type: 'planesdetected', data: frame } );\n\n\t}\n\n\tthis._xrFrame = null;\n\n}\n\n/** @module Renderer **/\n\nconst _scene = /*@__PURE__*/ new Scene();\nconst _drawingBufferSize = /*@__PURE__*/ new Vector2();\nconst _screen = /*@__PURE__*/ new Vector4();\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _vector4 = /*@__PURE__*/ new Vector4();\n\n/**\n * Base class for renderers.\n */\nclass Renderer {\n\n\t/**\n\t * Constructs a new renderer.\n\t *\n\t * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).\n\t * @param {Object} parameters - The configuration parameter.\n\t * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0\n\t * to overwrite the default.\n\t * @param {Function?} [parameters.getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n\t * @param {Number} [parameters.colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best\n\t * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.\n\t */\n\tconstructor( backend, parameters = {} ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderer = true;\n\n\t\t//\n\n\t\tconst {\n\t\t\tlogarithmicDepthBuffer = false,\n\t\t\talpha = true,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\tantialias = false,\n\t\t\tsamples = 0,\n\t\t\tgetFallback = null,\n\t\t\tcolorBufferType = HalfFloatType\n\t\t} = parameters;\n\n\t\t/**\n\t\t * A reference to the canvas element the renderer is drawing to.\n\t\t * This value of this property will automatically be created by\n\t\t * the renderer.\n\t\t *\n\t\t * @type {HTMLCanvasElement|OffscreenCanvas}\n\t\t */\n\t\tthis.domElement = backend.getDomElement();\n\n\t\t/**\n\t\t * A reference to the current backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * The number of MSAA samples.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.samples = samples || ( antialias === true ) ? 4 : 0;\n\n\t\t/**\n\t\t * Whether the renderer should automatically clear the current rendering target\n\t\t * before execute a `render()` call. The target can be the canvas (default framebuffer)\n\t\t * or the current bound render target (custom framebuffer).\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClear = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the color buffer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearColor = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the depth buffer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearDepth = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the stencil buffer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearStencil = true;\n\n\t\t/**\n\t\t * Whether the default framebuffer should be transparent or opaque.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.alpha = alpha;\n\n\t\t/**\n\t\t * Whether logarithmic depth buffer is enabled or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.logarithmicDepthBuffer = logarithmicDepthBuffer;\n\n\t\t/**\n\t\t * Defines the output color space of the renderer.\n\t\t *\n\t\t * @type {String}\n\t\t * @default SRGBColorSpace\n\t\t */\n\t\tthis.outputColorSpace = SRGBColorSpace;\n\n\t\t/**\n\t\t * Defines the tone mapping of the renderer.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default NoToneMapping\n\t\t */\n\t\tthis.toneMapping = NoToneMapping;\n\n\t\t/**\n\t\t * Defines the tone mapping exposure.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t/**\n\t\t * Whether the renderer should sort its render lists or not.\n\t\t *\n\t\t * Note: Sorting is used to attempt to properly render objects that have some degree of transparency.\n\t\t * By definition, sorting objects may not work in all cases. Depending on the needs of application,\n\t\t * it may be necessary to turn off sorting and use other methods to deal with transparency rendering\n\t\t * e.g. manually determining each object's rendering order.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sortObjects = true;\n\n\t\t/**\n\t\t * Whether the default framebuffer should have a depth buffer or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.depth = depth;\n\n\t\t/**\n\t\t * Whether the default framebuffer should have a stencil buffer or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencil = stencil;\n\n\t\t/**\n\t\t * Holds a series of statistical information about the GPU memory\n\t\t * and the rendering process. Useful for debugging and monitoring.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = new Info();\n\n\t\tthis.nodes = {\n\t\t\tmodelViewMatrix: null,\n\t\t\tmodelNormalViewMatrix: null\n\t\t};\n\n\t\t/**\n\t\t * The node library defines how certain library objects like materials, lights\n\t\t * or tone mapping functions are mapped to node types. This is required since\n\t\t * although instances of classes like `MeshBasicMaterial` or `PointLight` can\n\t\t * be part of the scene graph, they are internally represented as nodes for\n\t\t * further processing.\n\t\t *\n\t\t * @type {NodeLibrary}\n\t\t */\n\t\tthis.library = new NodeLibrary();\n\n\t\t/**\n\t\t * A map-like data structure for managing lights.\n\t\t *\n\t\t * @type {Lighting}\n\t\t */\n\t\tthis.lighting = new Lighting();\n\n\t\t// internals\n\n\t\t/**\n\t\t * This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._getFallback = getFallback;\n\n\t\t/**\n\t\t * The renderer's pixel ration.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._pixelRatio = 1;\n\n\t\t/**\n\t\t * The width of the renderer's default framebuffer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._width = this.domElement.width;\n\n\t\t/**\n\t\t * The height of the renderer's default framebuffer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._height = this.domElement.height;\n\n\t\t/**\n\t\t * The viewport of the renderer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._viewport = new Vector4( 0, 0, this._width, this._height );\n\n\t\t/**\n\t\t * The scissor rectangle of the renderer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._scissor = new Vector4( 0, 0, this._width, this._height );\n\n\t\t/**\n\t\t * Whether the scissor test should be enabled or not.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._scissorTest = false;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing shader attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Attributes?}\n\t\t * @default null\n\t\t */\n\t\tthis._attributes = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing geometries.\n\t\t *\n\t\t * @private\n\t\t * @type {Geometries?}\n\t\t * @default null\n\t\t */\n\t\tthis._geometries = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing node related logic.\n\t\t *\n\t\t * @private\n\t\t * @type {Nodes?}\n\t\t * @default null\n\t\t */\n\t\tthis._nodes = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing the internal animation loop.\n\t\t *\n\t\t * @private\n\t\t * @type {Animation?}\n\t\t * @default null\n\t\t */\n\t\tthis._animation = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing shader program bindings.\n\t\t *\n\t\t * @private\n\t\t * @type {Bindings?}\n\t\t * @default null\n\t\t */\n\t\tthis._bindings = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render objects.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderObjects?}\n\t\t * @default null\n\t\t */\n\t\tthis._objects = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render and compute pipelines.\n\t\t *\n\t\t * @private\n\t\t * @type {Pipelines?}\n\t\t * @default null\n\t\t */\n\t\tthis._pipelines = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render bundles.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderBundles?}\n\t\t * @default null\n\t\t */\n\t\tthis._bundles = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render lists.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderLists?}\n\t\t * @default null\n\t\t */\n\t\tthis._renderLists = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render contexts.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderContexts?}\n\t\t * @default null\n\t\t */\n\t\tthis._renderContexts = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing textures.\n\t\t *\n\t\t * @private\n\t\t * @type {Textures?}\n\t\t * @default null\n\t\t */\n\t\tthis._textures = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for backgrounds.\n\t\t *\n\t\t * @private\n\t\t * @type {Background?}\n\t\t * @default null\n\t\t */\n\t\tthis._background = null;\n\n\t\t/**\n\t\t * This fullscreen quad is used for internal render passes\n\t\t * like the tone mapping and color space output pass.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quad = new QuadMesh( new NodeMaterial() );\n\t\tthis._quad.material.name = 'Renderer_output';\n\n\t\t/**\n\t\t * A reference to the current render context.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderContext?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderContext = null;\n\n\t\t/**\n\t\t * A custom sort function for the opaque render list.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._opaqueSort = null;\n\n\t\t/**\n\t\t * A custom sort function for the transparent render list.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._transparentSort = null;\n\n\t\t/**\n\t\t * The framebuffer target.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis._frameBufferTarget = null;\n\n\t\tconst alphaClear = this.alpha === true ? 0 : 1;\n\n\t\t/**\n\t\t * The clear color value.\n\t\t *\n\t\t * @private\n\t\t * @type {Color4}\n\t\t */\n\t\tthis._clearColor = new Color4( 0, 0, 0, alphaClear );\n\n\t\t/**\n\t\t * The clear depth value.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._clearDepth = 1;\n\n\t\t/**\n\t\t * The clear stencil value.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._clearStencil = 0;\n\n\t\t/**\n\t\t * The current render target.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis._renderTarget = null;\n\n\t\t/**\n\t\t * The active cube face.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._activeCubeFace = 0;\n\n\t\t/**\n\t\t * The active mipmap level.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._activeMipmapLevel = 0;\n\n\t\t/**\n\t\t * The MRT setting.\n\t\t *\n\t\t * @private\n\t\t * @type {MRTNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._mrt = null;\n\n\t\t/**\n\t\t * This function defines how a render object is going\n\t\t * to be rendered.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._renderObjectFunction = null;\n\n\t\t/**\n\t\t * Used to keep track of the current render object function.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderObjectFunction = null;\n\n\t\t/**\n\t\t * Used to keep track of the current render bundle.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderBundle?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderBundle = null;\n\n\t\t/**\n\t\t * Next to `_renderObjectFunction()`, this function provides another hook\n\t\t * for influencing the render process of a render object. It is meant for internal\n\t\t * use and only relevant for `compileAsync()` right now. Instead of using\n\t\t * the default logic of `_renderObjectDirect()` which actually draws the render object,\n\t\t * a different function might be used which performs no draw but just the node\n\t\t * and pipeline updates.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t/**\n\t\t * Indicates whether the device has been lost or not. In WebGL terms, the device\n\t\t * lost is considered as a context lost. When this is set to `true`, rendering\n\t\t * isn't possible anymore.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._isDeviceLost = false;\n\n\t\t/**\n\t\t * A callback function that defines what should happen when a device/context lost occurs.\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.onDeviceLost = this._onDeviceLost;\n\n\t\t/**\n\t\t * Defines the type of color buffers. The default `HalfFloatType` is recommend for\n\t\t * best quality. To save memory and bandwidth, `UnsignedByteType` might be used.\n\t\t * This will reduce rendering quality though.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis._colorBufferType = colorBufferType;\n\n\t\t/**\n\t\t * Whether the renderer has been initialized or not.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._initialized = false;\n\n\t\t/**\n\t\t * A reference to the promise which initializes the renderer.\n\t\t *\n\t\t * @private\n\t\t * @type {Promise?}\n\t\t * @default null\n\t\t */\n\t\tthis._initPromise = null;\n\n\t\t/**\n\t\t * An array of compilation promises which are used in `compileAsync()`.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Promise>?}\n\t\t * @default null\n\t\t */\n\t\tthis._compilationPromises = null;\n\n\t\t/**\n\t\t * Whether the renderer should render transparent render objects or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.transparent = true;\n\n\t\t/**\n\t\t * Whether the renderer should render opaque render objects or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.opaque = true;\n\n\t\t/**\n\t\t * Shadow map configuration\n\t\t * @typedef {Object} ShadowMapConfig\n\t\t * @property {Boolean} enabled - Whether to globally enable shadows or not.\n\t\t * @property {Number} type - The shadow map type.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's shadow configuration.\n\t\t *\n\t\t * @type {module:Renderer~ShadowMapConfig}\n\t\t */\n\t\tthis.shadowMap = {\n\t\t\tenabled: false,\n\t\t\ttype: PCFShadowMap\n\t\t};\n\n\t\t/**\n\t\t * XR configuration.\n\t\t * @typedef {Object} XRConfig\n\t\t * @property {Boolean} enabled - Whether to globally enable XR or not.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's XR manager.\n\t\t *\n\t\t * @type {XRManager}\n\t\t */\n\t\tthis.xr = new XRManager( this );\n\n\t\t/**\n\t\t * Debug configuration.\n\t\t * @typedef {Object} DebugConfig\n\t\t * @property {Boolean} checkShaderErrors - Whether shader errors should be checked or not.\n\t\t * @property {Function} onShaderError - A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now.\n\t\t * @property {Function} getShaderAsync - Allows the get the raw shader code for the given scene, camera and 3D object.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's debug configuration.\n\t\t *\n\t\t * @type {module:Renderer~DebugConfig}\n\t\t */\n\t\tthis.debug = {\n\t\t\tcheckShaderErrors: true,\n\t\t\tonShaderError: null,\n\t\t\tgetShaderAsync: async ( scene, camera, object ) => {\n\n\t\t\t\tawait this.compileAsync( scene, camera );\n\n\t\t\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\t\t\tconst renderContext = this._renderContexts.get( scene, camera, this._renderTarget );\n\n\t\t\t\tconst material = scene.overrideMaterial || object.material;\n\n\t\t\t\tconst renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );\n\n\t\t\t\tconst { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();\n\n\t\t\t\treturn { fragmentShader, vertexShader };\n\n\t\t\t}\n\t\t};\n\n\t}\n\n\t/**\n\t * Initializes the renderer so it is ready for usage.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the renderer has been initialized.\n\t */\n\tasync init() {\n\n\t\tif ( this._initialized ) {\n\n\t\t\tthrow new Error( 'Renderer: Backend has already been initialized.' );\n\n\t\t}\n\n\t\tif ( this._initPromise !== null ) {\n\n\t\t\treturn this._initPromise;\n\n\t\t}\n\n\t\tthis._initPromise = new Promise( async ( resolve, reject ) => {\n\n\t\t\tlet backend = this.backend;\n\n\t\t\ttry {\n\n\t\t\t\tawait backend.init( this );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( this._getFallback !== null ) {\n\n\t\t\t\t\t// try the fallback\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tthis.backend = backend = this._getFallback( error );\n\t\t\t\t\t\tawait backend.init( this );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\treject( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\treject( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._nodes = new Nodes( this, backend );\n\t\t\tthis._animation = new Animation( this._nodes, this.info );\n\t\t\tthis._attributes = new Attributes( backend );\n\t\t\tthis._background = new Background( this, this._nodes );\n\t\t\tthis._geometries = new Geometries( this._attributes, this.info );\n\t\t\tthis._textures = new Textures( this, backend, this.info );\n\t\t\tthis._pipelines = new Pipelines( backend, this._nodes );\n\t\t\tthis._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );\n\t\t\tthis._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );\n\t\t\tthis._renderLists = new RenderLists( this.lighting );\n\t\t\tthis._bundles = new RenderBundles();\n\t\t\tthis._renderContexts = new RenderContexts();\n\n\t\t\t//\n\n\t\t\tthis._animation.start();\n\t\t\tthis._initialized = true;\n\n\t\t\tresolve();\n\n\t\t} );\n\n\t\treturn this._initPromise;\n\n\t}\n\n\t/**\n\t * The coordinate system of the renderer. The value of this property\n\t * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or\n\t * `THREE.WebGPUCoordinateSystem`.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget coordinateSystem() {\n\n\t\treturn this.backend.coordinateSystem;\n\n\t}\n\n\t/**\n\t * Compiles all materials in the given scene. This can be useful to avoid a\n\t * phenomenon which is called \"shader compilation stutter\", which occurs when\n\t * rendering an object with a new shader for the first time.\n\t *\n\t * If you want to add a 3D object to an existing scene, use the third optional\n\t * parameter for applying the target scene. Note that the (target) scene's lighting\n\t * and environment must be configured before calling this method.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The scene or 3D object to precompile.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n\t * @return {Promise<Array>} A Promise that resolves when the compile has been finished.\n\t */\n\tasync compileAsync( scene, camera, targetScene = null ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\t\tconst previousCompilationPromises = this._compilationPromises;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\tconst renderTarget = this._renderTarget;\n\t\tconst renderContext = this._renderContexts.get( targetScene, camera, renderTarget );\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\tconst compilationPromises = [];\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this.renderObject;\n\n\t\tthis._handleObjectFunction = this._createObjectPipeline;\n\n\t\tthis._compilationPromises = compilationPromises;\n\n\t\tnodeFrame.renderId ++;\n\n\t\t//\n\n\t\tnodeFrame.update();\n\n\t\t//\n\n\t\trenderContext.depth = this.depth;\n\t\trenderContext.stencil = this.stencil;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\t// include lights from target scene\n\t\tif ( targetScene !== scene ) {\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderList.pushLight( object );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\trenderList.finish();\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\n\t\t}\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t// process render lists\n\n\t\tconst opaqueObjects = renderList.opaque;\n\t\tconst transparentObjects = renderList.transparent;\n\t\tconst transparentDoublePassObjects = renderList.transparentDoublePass;\n\t\tconst lightsNode = renderList.lightsNode;\n\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\t\tthis._compilationPromises = previousCompilationPromises;\n\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n\t\tawait Promise.all( compilationPromises );\n\n\t}\n\n\t/**\n\t * Renders the scene in an async fashion.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera.\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync( scene, camera ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._renderScene( scene, camera );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.backend.waitForGPU();\n\n\t}\n\n\t/**\n\t * Sets the given MRT configuration.\n\t *\n\t * @param {MRTNode} mrt - The MRT node to set.\n\t * @return {Renderer} A reference to this renderer.\n\t */\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the MRT configuration.\n\t *\n\t * @return {MRTNode} The MRT configuration.\n\t */\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t/**\n\t * Returns the color buffer type.\n\t *\n\t * @return {Number} The color buffer type.\n\t */\n\tgetColorBufferType() {\n\n\t\treturn this._colorBufferType;\n\n\t}\n\n\t/**\n\t * Default implementation of the device lost callback.\n\t *\n\t * @private\n\t * @param {Object} info - Information about the context lost.\n\t */\n\t_onDeviceLost( info ) {\n\n\t\tlet errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n\n\t\tif ( info.reason ) {\n\n\t\t\terrorMessage += `\\nReason: ${info.reason}`;\n\n\t\t}\n\n\t\tconsole.error( errorMessage );\n\n\t\tthis._isDeviceLost = true;\n\n\t}\n\n\t/**\n\t * Renders the given render bundle.\n\t *\n\t * @private\n\t * @param {Object} bundle - Render bundle data.\n\t * @param {Scene} sceneRef - The scene the render bundle belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderBundle( bundle, sceneRef, lightsNode ) {\n\n\t\tconst { bundleGroup, camera, renderList } = bundle;\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\t//\n\n\t\tconst renderBundle = this._bundles.get( bundleGroup, camera );\n\t\tconst renderBundleData = this.backend.get( renderBundle );\n\n\t\tif ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();\n\n\t\t//\n\n\t\tconst needsUpdate = bundleGroup.version !== renderBundleData.version;\n\t\tconst renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;\n\n\t\trenderBundleData.renderContexts.add( renderContext );\n\n\t\tif ( renderBundleNeedsUpdate ) {\n\n\t\t\tthis.backend.beginBundle( renderContext );\n\n\t\t\tif ( renderBundleData.renderObjects === undefined || needsUpdate ) {\n\n\t\t\t\trenderBundleData.renderObjects = [];\n\n\t\t\t}\n\n\t\t\tthis._currentRenderBundle = renderBundle;\n\n\t\t\tconst opaqueObjects = renderList.opaque;\n\n\t\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\n\t\t\tthis._currentRenderBundle = null;\n\n\t\t\t//\n\n\t\t\tthis.backend.finishBundle( renderContext, renderBundle );\n\n\t\t\trenderBundleData.version = bundleGroup.version;\n\n\t\t} else {\n\n\t\t\tconst { renderObjects } = renderBundleData;\n\n\t\t\tfor ( let i = 0, l = renderObjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderObject = renderObjects[ i ];\n\n\t\t\t\tif ( this._nodes.needsRefresh( renderObject ) ) {\n\n\t\t\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t\t\t\tthis._nodes.updateAfter( renderObject );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.backend.addBundle( renderContext, renderBundle );\n\n\t}\n\n\t/**\n\t * Renders the scene or 3D object with the given camera. This method can only be called\n\t * if the renderer has been initialized.\n\t *\n\t * The target of the method is the default framebuffer (meaning the canvas)\n\t * or alternatively a render target when specified via `setRenderTarget()`.\n\t *\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t * @return {Promise?} A Promise that resolve when the scene has been rendered.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\trender( scene, camera ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );\n\n\t\t\treturn this.renderAsync( scene, camera );\n\n\t\t}\n\n\t\tthis._renderScene( scene, camera );\n\n\t}\n\n\t/**\n\t * Returns an internal render target which is used when computing the output tone mapping\n\t * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render\n\t * pass and not inline to achieve more correct results.\n\t *\n\t * @private\n\t * @return {RenderTarget?} The render target. The method returns `null` if no output conversion should be applied.\n\t */\n\t_getFrameBufferTarget() {\n\n\t\tconst { currentToneMapping, currentColorSpace } = this;\n\n\t\tconst useToneMapping = currentToneMapping !== NoToneMapping;\n\t\tconst useColorSpace = currentColorSpace !== LinearSRGBColorSpace;\n\n\t\tif ( useToneMapping === false && useColorSpace === false ) return null;\n\n\t\tconst { width, height } = this.getDrawingBufferSize( _drawingBufferSize );\n\t\tconst { depth, stencil } = this;\n\n\t\tlet frameBufferTarget = this._frameBufferTarget;\n\n\t\tif ( frameBufferTarget === null ) {\n\n\t\t\tframeBufferTarget = new RenderTarget( width, height, {\n\t\t\t\tdepthBuffer: depth,\n\t\t\t\tstencilBuffer: stencil,\n\t\t\t\ttype: this._colorBufferType,\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tminFilter: LinearFilter,\n\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\tsamples: this.samples\n\t\t\t} );\n\n\t\t\tframeBufferTarget.isPostProcessingRenderTarget = true;\n\n\t\t\tthis._frameBufferTarget = frameBufferTarget;\n\n\t\t}\n\n\t\tframeBufferTarget.depthBuffer = depth;\n\t\tframeBufferTarget.stencilBuffer = stencil;\n\t\tframeBufferTarget.setSize( width, height );\n\t\tframeBufferTarget.viewport.copy( this._viewport );\n\t\tframeBufferTarget.scissor.copy( this._scissor );\n\t\tframeBufferTarget.viewport.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissor.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissorTest = this._scissorTest;\n\n\t\treturn frameBufferTarget;\n\n\t}\n\n\t/**\n\t * Renders the scene or 3D object with the given camera.\n\t *\n\t * @private\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t * @param {Boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.\n\t * @return {RenderContext} The current render context.\n\t */\n\t_renderScene( scene, camera, useFrameBufferTarget = true ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tconst frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tconst outputRenderTarget = this._renderTarget;\n\n\t\tconst activeCubeFace = this._activeCubeFace;\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\t//\n\n\t\tlet renderTarget;\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\trenderTarget = frameBufferTarget;\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t} else {\n\n\t\t\trenderTarget = outputRenderTarget;\n\n\t\t}\n\n\t\t//\n\n\t\tconst renderContext = this._renderContexts.get( scene, camera, renderTarget );\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.render.calls ++;\n\t\tthis.info.render.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\t\tconst xr = this.xr;\n\n\t\tif ( camera.coordinateSystem !== coordinateSystem && xr.isPresenting === false ) {\n\n\t\t\tcamera.coordinateSystem = coordinateSystem;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\t\t\tsubCamera.coordinateSystem = coordinateSystem;\n\t\t\t\t\tsubCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t}\n\n\t\t//\n\n\t\tlet viewport = this._viewport;\n\t\tlet scissor = this._scissor;\n\t\tlet pixelRatio = this._pixelRatio;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tviewport = renderTarget.viewport;\n\t\t\tscissor = renderTarget.scissor;\n\t\t\tpixelRatio = 1;\n\n\t\t}\n\n\t\tthis.getDrawingBufferSize( _drawingBufferSize );\n\n\t\t_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );\n\n\t\tconst minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;\n\t\tconst maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;\n\n\t\trenderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.viewportValue.width >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.height >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.minDepth = minDepth;\n\t\trenderContext.viewportValue.maxDepth = maxDepth;\n\t\trenderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;\n\n\t\trenderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;\n\t\trenderContext.scissorValue.width >>= activeMipmapLevel;\n\t\trenderContext.scissorValue.height >>= activeMipmapLevel;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\trenderList.finish();\n\n\t\tif ( this.sortObjects === true ) {\n\n\t\t\trenderList.sort( this._opaqueSort, this._transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\t\t\trenderContext.width = this.domElement.width;\n\t\t\trenderContext.height = this.domElement.height;\n\t\t\trenderContext.depth = this.depth;\n\t\t\trenderContext.stencil = this.stencil;\n\n\t\t}\n\n\t\trenderContext.width >>= activeMipmapLevel;\n\t\trenderContext.height >>= activeMipmapLevel;\n\t\trenderContext.activeCubeFace = activeCubeFace;\n\t\trenderContext.activeMipmapLevel = activeMipmapLevel;\n\t\trenderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t//\n\n\t\tthis.backend.beginRender( renderContext );\n\n\t\t// process render lists\n\n\t\tconst {\n\t\t\tbundles,\n\t\t\tlightsNode,\n\t\t\ttransparentDoublePass: transparentDoublePassObjects,\n\t\t\ttransparent: transparentObjects,\n\t\t\topaque: opaqueObjects\n\t\t} = renderList;\n\n\t\tif ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// finish render pass\n\n\t\tthis.backend.finishRender( renderContext );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\n\t\t//\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\tthis.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t\t\tconst quad = this._quad;\n\n\t\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\t\tquad.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\t}\n\n\t\t//\n\n\t\tsceneRef.onAfterRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\treturn renderContext;\n\n\t}\n\n\t/**\n\t * Returns the maximum available anisotropy for texture filtering.\n\t *\n\t * @return {Number} The maximum available anisotropy.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn this.backend.getMaxAnisotropy();\n\n\t}\n\n\t/**\n\t * Returns the active cube face.\n\t *\n\t * @return {Number} The active cube face.\n\t */\n\tgetActiveCubeFace() {\n\n\t\treturn this._activeCubeFace;\n\n\t}\n\n\t/**\n\t * Returns the active mipmap level.\n\t *\n\t * @return {Number} The active mipmap level.\n\t */\n\tgetActiveMipmapLevel() {\n\n\t\treturn this._activeMipmapLevel;\n\n\t}\n\n\t/**\n\t * Applications are advised to always define the animation loop\n\t * with this method and not manually with `requestAnimationFrame()`\n\t * for best compatibility.\n\t *\n\t * @async\n\t * @param {Function} callback - The application's animation loop.\n\t * @return {Promise} A Promise that resolves when the set has been executed.\n\t */\n\tasync setAnimationLoop( callback ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._animation.setAnimationLoop( callback );\n\n\t}\n\n\t/**\n\t * Can be used to transfer buffer data from a storage buffer attribute\n\t * from the GPU to the CPU in context of compute shaders.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.backend.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Returns the rendering context.\n\t *\n\t * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.backend.getContext();\n\n\t}\n\n\t/**\n\t * Returns the pixel ratio.\n\t *\n\t * @return {Number} The pixel ratio.\n\t */\n\tgetPixelRatio() {\n\n\t\treturn this._pixelRatio;\n\n\t}\n\n\t/**\n\t * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize( target ) {\n\n\t\treturn target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();\n\n\t}\n\n\t/**\n\t * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetSize( target ) {\n\n\t\treturn target.set( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Sets the given pixel ration and resizes the canvas if necessary.\n\t *\n\t * @param {Number} [value=1] - The pixel ratio.\n\t */\n\tsetPixelRatio( value = 1 ) {\n\n\t\tif ( this._pixelRatio === value ) return;\n\n\t\tthis._pixelRatio = value;\n\n\t\tthis.setSize( this._width, this._height, false );\n\n\t}\n\n\t/**\n\t * This method allows to define the drawing buffer size by specifying\n\t * width, height and pixel ratio all at once. The size of the drawing\n\t * buffer is computed with this formula:\n\t * ````\n\t * size.x = width * pixelRatio;\n\t * size.y = height * pixelRatio;\n\t *```\n\t *\n\t * @param {Number} width - The width in logical pixels.\n\t * @param {Number} height - The height in logical pixels.\n\t * @param {Number} pixelRatio - The pixel ratio.\n\t */\n\tsetDrawingBufferSize( width, height, pixelRatio ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.domElement.width = Math.floor( width * pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\t/**\n\t * Sets the size of the renderer.\n\t *\n\t * @param {Number} width - The width in logical pixels.\n\t * @param {Number} height - The height in logical pixels.\n\t * @param {Boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.\n\t */\n\tsetSize( width, height, updateStyle = true ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis.domElement.width = Math.floor( width * this._pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * this._pixelRatio );\n\n\t\tif ( updateStyle === true ) {\n\n\t\t\tthis.domElement.style.width = width + 'px';\n\t\t\tthis.domElement.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\t/**\n\t * Defines a manual sort function for the opaque render list.\n\t * Pass `null` to use the default sort.\n\t *\n\t * @param {Function} method - The sort function.\n\t */\n\tsetOpaqueSort( method ) {\n\n\t\tthis._opaqueSort = method;\n\n\t}\n\n\t/**\n\t * Defines a manual sort function for the transparent render list.\n\t * Pass `null` to use the default sort.\n\t *\n\t * @param {Function} method - The sort function.\n\t */\n\tsetTransparentSort( method ) {\n\n\t\tthis._transparentSort = method;\n\n\t}\n\n\t/**\n\t * Returns the scissor rectangle.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The scissor rectangle.\n\t */\n\tgetScissor( target ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\ttarget.x = scissor.x;\n\t\ttarget.y = scissor.y;\n\t\ttarget.width = scissor.width;\n\t\ttarget.height = scissor.height;\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Defines the scissor rectangle.\n\t *\n\t * @param {Number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.\n\t * Instead of passing four arguments, the method also works with a single four-dimensional vector.\n\t * @param {Number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.\n\t * @param {Number} width - The width of the scissor box in logical pixel unit.\n\t * @param {Number} height - The height of the scissor box in logical pixel unit.\n\t */\n\tsetScissor( x, y, width, height ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tscissor.copy( x );\n\n\t\t} else {\n\n\t\t\tscissor.set( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the scissor test value.\n\t *\n\t * @return {Boolean} Whether the scissor test should be enabled or not.\n\t */\n\tgetScissorTest() {\n\n\t\treturn this._scissorTest;\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tthis._scissorTest = boolean;\n\n\t\tthis.backend.setScissorTest( boolean );\n\n\t}\n\n\t/**\n\t * Returns the viewport definition.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The viewport definition.\n\t */\n\tgetViewport( target ) {\n\n\t\treturn target.copy( this._viewport );\n\n\t}\n\n\t/**\n\t * Defines the viewport.\n\t *\n\t * @param {Number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n\t * @param {Number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n\t * @param {Number} width - The width of the viewport in logical pixel unit.\n\t * @param {Number} height - The height of the viewport in logical pixel unit.\n\t * @param {Number} minDepth - The minimum depth value of the viewport. WebGPU only.\n\t * @param {Number} maxDepth - The maximum depth value of the viewport. WebGPU only.\n\t */\n\tsetViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {\n\n\t\tconst viewport = this._viewport;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tviewport.copy( x );\n\n\t\t} else {\n\n\t\t\tviewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tviewport.minDepth = minDepth;\n\t\tviewport.maxDepth = maxDepth;\n\n\t}\n\n\t/**\n\t * Returns the clear color.\n\t *\n\t * @param {Color} target - The method writes the result in this target object.\n\t * @return {Color} The clear color.\n\t */\n\tgetClearColor( target ) {\n\n\t\treturn target.copy( this._clearColor );\n\n\t}\n\n\t/**\n\t * Defines the clear color and optionally the clear alpha.\n\t *\n\t * @param {Color} color - The clear color.\n\t * @param {Number} [alpha=1] - The clear alpha.\n\t */\n\tsetClearColor( color, alpha = 1 ) {\n\n\t\tthis._clearColor.set( color );\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\t/**\n\t * Returns the clear alpha.\n\t *\n\t * @return {Number} The clear alpha.\n\t */\n\tgetClearAlpha() {\n\n\t\treturn this._clearColor.a;\n\n\t}\n\n\t/**\n\t * Defines the clear alpha.\n\t *\n\t * @param {Number} alpha - The clear alpha.\n\t */\n\tsetClearAlpha( alpha ) {\n\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\t/**\n\t * Returns the clear depth.\n\t *\n\t * @return {Number} The clear depth.\n\t */\n\tgetClearDepth() {\n\n\t\treturn this._clearDepth;\n\n\t}\n\n\t/**\n\t * Defines the clear depth.\n\t *\n\t * @param {Number} depth - The clear depth.\n\t */\n\tsetClearDepth( depth ) {\n\n\t\tthis._clearDepth = depth;\n\n\t}\n\n\t/**\n\t * Returns the clear stencil.\n\t *\n\t * @return {Number} The clear stencil.\n\t */\n\tgetClearStencil() {\n\n\t\treturn this._clearStencil;\n\n\t}\n\n\t/**\n\t * Defines the clear stencil.\n\t *\n\t * @param {Number} stencil - The clear stencil.\n\t */\n\tsetClearStencil( stencil ) {\n\n\t\tthis._clearStencil = stencil;\n\n\t}\n\n\t/**\n\t * This method performs an occlusion query for the given 3D object.\n\t * It returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {Boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( object ) {\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\treturn renderContext && this.backend.isOccluded( renderContext, object );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation. This method ignores `autoClear` properties.\n\t *\n\t * @param {Boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {Boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {Boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclear( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );\n\n\t\t\treturn this.clearAsync( color, depth, stencil );\n\n\t\t}\n\n\t\tconst renderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\tlet renderContext = null;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext = this._renderContexts.getForClear( renderTarget );\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\n\t\t}\n\n\t\t// #30329\n\t\trenderContext.clearColorValue = this._clearColor;\n\n\t\tthis.backend.clear( color, depth, stencil, renderContext );\n\n\t\tif ( renderTarget !== null && this._renderTarget === null ) {\n\n\t\t\t// If a color space transform or tone mapping is required,\n\t\t\t// the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.\n\n\t\t\tconst quad = this._quad;\n\n\t\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\t\tquad.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearColor() {\n\n\t\treturn this.clear( true, false, false );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearDepth() {\n\n\t\treturn this.clear( false, true, false );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearStencil() {\n\n\t\treturn this.clear( false, false, true );\n\n\t}\n\n\t/**\n\t * Async version of {@link module:Renderer~Renderer#clear}.\n\t *\n\t * @async\n\t * @param {Boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {Boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {Boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearAsync( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.clear( color, depth, stencil );\n\n\t}\n\n\t/**\n\t * Async version of {@link module:Renderer~Renderer#clearColor}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearColorAsync() {\n\n\t\tthis.clearAsync( true, false, false );\n\n\t}\n\n\t/**\n\t * Async version of {@link module:Renderer~Renderer#clearDepth}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearDepthAsync() {\n\n\t\tthis.clearAsync( false, true, false );\n\n\t}\n\n\t/**\n\t * Async version of {@link module:Renderer~Renderer#clearStencil}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearStencilAsync() {\n\n\t\tthis.clearAsync( false, false, true );\n\n\t}\n\n\t/**\n\t * The current output tone mapping of the renderer. When a render target is set,\n\t * the output tone mapping is always `NoToneMapping`.\n\t *\n\t * @type {Number}\n\t */\n\tget currentToneMapping() {\n\n\t\treturn this._renderTarget !== null ? NoToneMapping : this.toneMapping;\n\n\t}\n\n\t/**\n\t * The current output color space of the renderer. When a render target is set,\n\t * the output color space is always `LinearSRGBColorSpace`.\n\t *\n\t * @type {String}\n\t */\n\tget currentColorSpace() {\n\n\t\treturn this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;\n\n\t}\n\n\t/**\n\t * Frees all internal resources of the renderer. Call this method if the renderer\n\t * is no longer in use by your app.\n\t */\n\tdispose() {\n\n\t\tthis.info.dispose();\n\t\tthis.backend.dispose();\n\n\t\tthis._animation.dispose();\n\t\tthis._objects.dispose();\n\t\tthis._pipelines.dispose();\n\t\tthis._nodes.dispose();\n\t\tthis._bindings.dispose();\n\t\tthis._renderLists.dispose();\n\t\tthis._renderContexts.dispose();\n\t\tthis._textures.dispose();\n\n\t\tif ( this._frameBufferTarget !== null ) this._frameBufferTarget.dispose();\n\n\t\tObject.values( this.backend.timestampQueryPool ).forEach( queryPool => {\n\n\t\t\tif ( queryPool !== null ) queryPool.dispose();\n\n\t\t} );\n\n\t\tthis.setRenderTarget( null );\n\t\tthis.setAnimationLoop( null );\n\n\t}\n\n\t/**\n\t * Sets the given render target. Calling this method means the renderer does not\n\t * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.\n\t * Use `null` as the first argument to reset the state.\n\t *\n\t * @param {RenderTarget?} renderTarget - The render target to set.\n\t * @param {Number} [activeCubeFace=0] - The active cube face.\n\t * @param {Number} [activeMipmapLevel=0] - The active mipmap level.\n\t */\n\tsetRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\tthis._renderTarget = renderTarget;\n\t\tthis._activeCubeFace = activeCubeFace;\n\t\tthis._activeMipmapLevel = activeMipmapLevel;\n\n\t}\n\n\t/**\n\t * Returns the current render target.\n\t *\n\t * @return {RenderTarget?} The render target. Returns `null` if no render target is set.\n\t */\n\tgetRenderTarget() {\n\n\t\treturn this._renderTarget;\n\n\t}\n\n\t/**\n\t * Callback for {@link module:Renderer~Renderer#setRenderObjectFunction}.\n\t *\n\t * @callback renderObjectFunction\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {BufferGeometry} geometry - The object's geometry.\n\t * @param {Material} material - The object's material.\n\t * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\n\t/**\n\t * Sets the given render object function. Calling this method overwrites the default implementation\n\t * which is {@link module:Renderer~Renderer#renderObject}. Defining a custom function can be useful\n\t * if you want to modify the way objects are rendered. For example you can define things like \"every\n\t * object that has material of a certain type should perform a pre-pass with a special overwrite material\".\n\t * The custom function must always call `renderObject()` in its implementation.\n\t *\n\t * Use `null` as the first argument to reset the state.\n\t *\n\t * @param {module:Renderer~renderObjectFunction?} renderObjectFunction - The render object function.\n\t */\n\tsetRenderObjectFunction( renderObjectFunction ) {\n\n\t\tthis._renderObjectFunction = renderObjectFunction;\n\n\t}\n\n\t/**\n\t * Returns the current render object function.\n\t *\n\t * @return {Function?} The current render object function. Returns `null` if no function is set.\n\t */\n\tgetRenderObjectFunction() {\n\n\t\treturn this._renderObjectFunction;\n\n\t}\n\n\t/**\n\t * Execute a single or an array of compute nodes. This method can only be called\n\t * if the renderer has been initialized.\n\t *\n\t * @param {Node|Array<Node>} computeNodes - The compute node(s).\n\t * @return {Promise?} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.\n\t */\n\tcompute( computeNodes ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );\n\n\t\t\treturn this.computeAsync( computeNodes );\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.compute.calls ++;\n\t\tthis.info.compute.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst backend = this.backend;\n\t\tconst pipelines = this._pipelines;\n\t\tconst bindings = this._bindings;\n\t\tconst nodes = this._nodes;\n\n\t\tconst computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];\n\n\t\tif ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {\n\n\t\t\tthrow new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );\n\n\t\t}\n\n\t\tbackend.beginCompute( computeNodes );\n\n\t\tfor ( const computeNode of computeList ) {\n\n\t\t\t// onInit\n\n\t\t\tif ( pipelines.has( computeNode ) === false ) {\n\n\t\t\t\tconst dispose = () => {\n\n\t\t\t\t\tcomputeNode.removeEventListener( 'dispose', dispose );\n\n\t\t\t\t\tpipelines.delete( computeNode );\n\t\t\t\t\tbindings.delete( computeNode );\n\t\t\t\t\tnodes.delete( computeNode );\n\n\t\t\t\t};\n\n\t\t\t\tcomputeNode.addEventListener( 'dispose', dispose );\n\n\t\t\t\t//\n\n\t\t\t\tconst onInitFn = computeNode.onInitFunction;\n\n\t\t\t\tif ( onInitFn !== null ) {\n\n\t\t\t\t\tonInitFn.call( computeNode, { renderer: this } );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodes.updateForCompute( computeNode );\n\t\t\tbindings.updateForCompute( computeNode );\n\n\t\t\tconst computeBindings = bindings.getForCompute( computeNode );\n\t\t\tconst computePipeline = pipelines.getForCompute( computeNode, computeBindings );\n\n\t\t\tbackend.compute( computeNodes, computeNode, computeBindings, computePipeline );\n\n\t\t}\n\n\t\tbackend.finishCompute( computeNodes );\n\n\t\t//\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t}\n\n\t/**\n\t * Execute a single or an array of compute nodes.\n\t *\n\t * @async\n\t * @param {Node|Array<Node>} computeNodes - The compute node(s).\n\t * @return {Promise} A Promise that resolve when the compute has finished.\n\t */\n\tasync computeAsync( computeNodes ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.compute( computeNodes );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the selected backend.\n\t *\n\t * @async\n\t * @param {String} name - The feature's name.\n\t * @return {Promise<Boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n\t */\n\tasync hasFeatureAsync( name ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\tasync resolveTimestampsAsync( type = 'render' ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\treturn this.backend.resolveTimestampsAsync( type );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the selected backend. If the\n\t * renderer has not been initialized, this method always returns `false`.\n\t *\n\t * @param {String} name - The feature's name.\n\t * @return {Boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\t/**\n\t * Returns `true` when the renderer has been initialized.\n\t *\n\t * @return {Boolean} Whether the renderer has been initialized or not.\n\t */\n\thasInitialized() {\n\n\t\treturn this._initialized;\n\n\t}\n\n\t/**\n\t * Initializes the given textures. Useful for preloading a texture rather than waiting until first render\n\t * (which can cause noticeable lags due to decode and GPU upload overhead).\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture.\n\t * @return {Promise} A Promise that resolves when the texture has been initialized.\n\t */\n\tasync initTextureAsync( texture ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\t/**\n\t * Initializes the given textures. Useful for preloading a texture rather than waiting until first render\n\t * (which can cause noticeable lags due to decode and GPU upload overhead).\n\t *\n\t * This method can only be used if the renderer has been initialized.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tinitTexture( texture ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );\n\n\t\t}\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer into the given texture.\n\t *\n\t * @param {FramebufferTexture} framebufferTexture - The texture.\n\t * @param {Vector2|Vector4} rectangle - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.\n\t */\n\tcopyFramebufferToTexture( framebufferTexture, rectangle = null ) {\n\n\t\tif ( rectangle !== null ) {\n\n\t\t\tif ( rectangle.isVector2 ) {\n\n\t\t\t\trectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();\n\n\t\t\t} else if ( rectangle.isVector4 ) {\n\n\t\t\t\trectangle = _vector4.copy( rectangle ).floor();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );\n\n\t\t}\n\n\t\t//\n\n\t\tlet renderContext = this._currentRenderContext;\n\t\tlet renderTarget;\n\n\t\tif ( renderContext !== null ) {\n\n\t\t\trenderTarget = renderContext.renderTarget;\n\n\t\t} else {\n\n\t\t\trenderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\t\trenderContext = this._textures.get( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis._textures.updateTexture( framebufferTexture, { renderTarget } );\n\n\t\tthis.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );\n\n\t}\n\n\t/**\n\t * Copies data of source texture into a destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.\n\t * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.\n\t * @param {Number} level - The mipmap level to copy.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tthis._textures.updateTexture( srcTexture );\n\t\tthis._textures.updateTexture( dstTexture );\n\n\t\tthis.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t}\n\n\t/**\n\t * Reads pixel data from the given render target.\n\t *\n\t * @async\n\t * @param {RenderTarget} renderTarget - The render target to read from.\n\t * @param {Number} x - The `x` coordinate of the copy region's origin.\n\t * @param {Number} y - The `y` coordinate of the copy region's origin.\n\t * @param {Number} width - The width of the copy region.\n\t * @param {Number} height - The height of the copy region.\n\t * @param {Number} [textureIndex=0] - The texture index of a MRT render target.\n\t * @param {Number} [faceIndex=0] - The active cube face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.\n\t */\n\tasync readRenderTargetPixelsAsync( renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0 ) {\n\n\t\treturn this.backend.copyTextureToBuffer( renderTarget.textures[ textureIndex ], x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * Analyzes the given 3D object's hierarchy and builds render lists from the\n\t * processed hierarchy.\n\t *\n\t * @param {Object3D} object - The 3D object to process (usually a scene).\n\t * @param {Camera} camera - The camera the object is rendered with.\n\t * @param {Number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.\n\t * @param {RenderList} renderList - The current render list.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\t_projectObject( object, camera, groupOrder, renderList, clippingContext ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\tif ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\trenderList.pushLight( object );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\tconsole.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\t\t\t_vector4\n\t\t\t\t\t\t\t.copy( geometry.boundingSphere.center )\n\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\trenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {\n\n\t\t\tconst baseRenderList = renderList;\n\n\t\t\t// replace render list\n\t\t\trenderList = this._renderLists.get( object, camera );\n\n\t\t\trenderList.begin();\n\n\t\t\tbaseRenderList.pushBundle( {\n\t\t\t\tbundleGroup: object,\n\t\t\t\tcamera,\n\t\t\t\trenderList,\n\t\t\t} );\n\n\t\t\trenderList.finish();\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the given render bundles.\n\t *\n\t * @private\n\t * @param {Array<Object>} bundles - Array with render bundle data.\n\t * @param {Scene} sceneRef - The scene the render bundles belong to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderBundles( bundles, sceneRef, lightsNode ) {\n\n\t\tfor ( const bundle of bundles ) {\n\n\t\t\tthis._renderBundle( bundle, sceneRef, lightsNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the transparent objects from the given render lists.\n\t *\n\t * @private\n\t * @param {Array<Object>} renderList - The transparent render list.\n\t * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).\n\t * @param {Camera} camera - The camera the render list should be rendered with.\n\t * @param {Scene} scene - The scene the render list belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {\n\n\t\tif ( doublePassList.length > 0 ) {\n\n\t\t\t// render back side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );\n\n\t\t\t// render front side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = FrontSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t\t// restore\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the objects from the given render list.\n\t *\n\t * @private\n\t * @param {Array<Object>} renderList - The render list.\n\t * @param {Camera} camera - The camera the render list should be rendered with.\n\t * @param {Scene} scene - The scene the render list belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\t_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {\n\n\t\tfor ( let i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\tconst { object, geometry, material, group, clippingContext } = renderList[ i ];\n\n\t\t\tthis._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method represents the default render object function that manages the render lifecycle\n\t * of the object.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {BufferGeometry} geometry - The object's geometry.\n\t * @param {Material} material - The object's material.\n\t * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\trenderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {\n\n\t\tlet overridePositionNode;\n\t\tlet overrideColorNode;\n\t\tlet overrideDepthNode;\n\n\t\t//\n\n\t\tobject.onBeforeRender( this, scene, camera, geometry, material, group );\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial !== null ) {\n\n\t\t\tconst overrideMaterial = scene.overrideMaterial;\n\n\t\t\tif ( material.positionNode && material.positionNode.isNode ) {\n\n\t\t\t\toverridePositionNode = overrideMaterial.positionNode;\n\t\t\t\toverrideMaterial.positionNode = material.positionNode;\n\n\t\t\t}\n\n\t\t\toverrideMaterial.alphaTest = material.alphaTest;\n\t\t\toverrideMaterial.alphaMap = material.alphaMap;\n\t\t\toverrideMaterial.transparent = material.transparent || material.transmission > 0;\n\n\t\t\tif ( overrideMaterial.isShadowPassMaterial ) {\n\n\t\t\t\toverrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n\n\t\t\t\tif ( material.depthNode && material.depthNode.isNode ) {\n\n\t\t\t\t\toverrideDepthNode = overrideMaterial.depthNode;\n\t\t\t\t\toverrideMaterial.depthNode = material.depthNode;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.castShadowNode && material.castShadowNode.isNode ) {\n\n\t\t\t\t\toverrideColorNode = overrideMaterial.colorNode;\n\t\t\t\t\toverrideMaterial.colorNode = material.castShadowNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterial = overrideMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\tmaterial.side = BackSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id\n\n\t\t\tmaterial.side = FrontSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id\n\n\t\t\tmaterial.side = DoubleSide;\n\n\t\t} else {\n\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( overridePositionNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.positionNode = overridePositionNode;\n\n\t\t}\n\n\t\tif ( overrideDepthNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.depthNode = overrideDepthNode;\n\n\t\t}\n\n\t\tif ( overrideColorNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.colorNode = overrideColorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tobject.onAfterRender( this, scene, camera, geometry, material, group );\n\n\t}\n\n\t/**\n\t * This method represents the default `_handleObjectFunction` implementation which creates\n\t * a render object from the given data and performs the draw command with the selected backend.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {{start: Number, count: Number}?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\t_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tconst needsRefresh = this._nodes.needsRefresh( renderObject );\n\n\t\tif ( needsRefresh ) {\n\n\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\tthis._geometries.updateForRender( renderObject );\n\n\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t}\n\n\t\tthis._pipelines.updateForRender( renderObject );\n\n\t\t//\n\n\t\tif ( this._currentRenderBundle !== null ) {\n\n\t\t\tconst renderBundleData = this.backend.get( this._currentRenderBundle );\n\n\t\t\trenderBundleData.renderObjects.push( renderObject );\n\n\t\t\trenderObject.bundle = this._currentRenderBundle.bundleGroup;\n\n\t\t}\n\n\t\tthis.backend.draw( renderObject, this.info );\n\n\t\tif ( needsRefresh ) this._nodes.updateAfter( renderObject );\n\n\t}\n\n\t/**\n\t * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.\n\t * Used in `compileAsync()`.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {{start: Number, count: Number}?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\t_createObjectPipeline( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tthis._nodes.updateBefore( renderObject );\n\n\t\tthis._geometries.updateForRender( renderObject );\n\n\t\tthis._nodes.updateForRender( renderObject );\n\t\tthis._bindings.updateForRender( renderObject );\n\n\t\tthis._pipelines.getForRender( renderObject, this._compilationPromises );\n\n\t\tthis._nodes.updateAfter( renderObject );\n\n\t}\n\n\t/**\n\t * Alias for `compileAsync()`.\n\t *\n\t * @method\n\t * @param {Object3D} scene - The scene or 3D object to precompile.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n\t * @return {Promise} A Promise that resolves when the compile has been finished.\n\t */\n\tget compile() {\n\n\t\treturn this.compileAsync;\n\n\t}\n\n}\n\n/**\n * A binding represents the connection between a resource (like a texture, sampler\n * or uniform buffer) and the resource definition in a shader stage.\n *\n * This module is an abstract base class for all concrete bindings types.\n *\n * @abstract\n * @private\n */\nclass Binding {\n\n\t/**\n\t * Constructs a new binding.\n\t *\n\t * @param {String} [name=''] - The binding's name.\n\t */\n\tconstructor( name = '' ) {\n\n\t\t/**\n\t\t * The binding's name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * A bitmask that defines in what shader stages the\n\t\t * binding's resource is accessible.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.visibility = 0;\n\n\t}\n\n\t/**\n\t * Makes sure binding's resource is visible for the given shader stage.\n\t *\n\t * @param {Number} visibility - The shader stage.\n\t */\n\tsetVisibility( visibility ) {\n\n\t\tthis.visibility |= visibility;\n\n\t}\n\n\t/**\n\t * Clones the binding.\n\t *\n\t * @return {Binding} The cloned binding.\n\t */\n\tclone() {\n\n\t\treturn Object.assign( new this.constructor(), this );\n\n\t}\n\n}\n\n/** @module BufferUtils **/\n\n/**\n * This function is usually called with the length in bytes of an array buffer.\n * It returns an padded value which ensure chunk size alignment according to STD140 layout.\n *\n * @function\n * @param {Number} floatLength - The buffer length.\n * @return {Number} The padded length.\n */\nfunction getFloatLength( floatLength ) {\n\n\t// ensure chunk size alignment (STD140 layout)\n\n\treturn floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );\n\n}\n\n/**\n * Represents a buffer binding type.\n *\n * @private\n * @abstract\n * @augments Binding\n */\nclass Buffer extends Binding {\n\n\t/**\n\t * Constructs a new buffer.\n\t *\n\t * @param {String} name - The buffer's name.\n\t * @param {TypedArray} [buffer=null] - The buffer.\n\t */\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBuffer = true;\n\n\t\t/**\n\t\t * The bytes per element.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;\n\n\t\t/**\n\t\t * A reference to the internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis._buffer = buffer;\n\n\t}\n\n\t/**\n\t * The buffer's byte length.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget byteLength() {\n\n\t\treturn getFloatLength( this._buffer.byteLength );\n\n\t}\n\n\t/**\n\t * A reference to the internal buffer.\n\t *\n\t * @type {Float32Array}\n\t * @readonly\n\t */\n\tget buffer() {\n\n\t\treturn this._buffer;\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @return {Boolean} Whether the buffer has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\treturn true;\n\n\t}\n\n}\n\n/**\n * Represents a uniform buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass UniformBuffer extends Buffer {\n\n\t/**\n\t * Constructs a new uniform buffer.\n\t *\n\t * @param {String} name - The buffer's name.\n\t * @param {TypedArray} [buffer=null] - The buffer.\n\t */\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name, buffer );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformBuffer = true;\n\n\t}\n\n}\n\nlet _id$4 = 0;\n\n/**\n * A special form of uniform buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments UniformBuffer\n */\nclass NodeUniformBuffer extends UniformBuffer {\n\n\t/**\n\t * Constructs a new node-based uniform buffer.\n\t *\n\t * @param {BufferNode} nodeUniform - The uniform buffer node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );\n\n\t\t/**\n\t\t * The uniform buffer node.\n\t\t *\n\t\t * @type {BufferNode}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * The uniform buffer.\n\t *\n\t * @type {Float32Array}\n\t */\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\n/**\n * This class represents a uniform buffer binding but with\n * an API that allows to maintain individual uniform objects.\n *\n * @private\n * @augments UniformBuffer\n */\nclass UniformsGroup extends UniformBuffer {\n\n\t/**\n\t * Constructs a new uniforms group.\n\t *\n\t * @param {String} name - The group's name.\n\t */\n\tconstructor( name ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformsGroup = true;\n\n\t\t/**\n\t\t * An array with the raw uniform values.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Number>?}\n\t\t * @default null\n\t\t */\n\t\tthis._values = null;\n\n\t\t/**\n\t\t * An array of uniform objects.\n\t\t *\n\t\t * The order of uniforms in this array must match the order of uniforms in the shader.\n\t\t *\n\t\t * @type {Array<Uniform>}\n\t\t */\n\t\tthis.uniforms = [];\n\n\t}\n\n\t/**\n\t * Adds a uniform to this group.\n\t *\n\t * @param {Uniform} uniform - The uniform to add.\n\t * @return {UniformsGroup} A reference to this group.\n\t */\n\taddUniform( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a uniform from this group.\n\t *\n\t * @param {Uniform} uniform - The uniform to remove.\n\t * @return {UniformsGroup} A reference to this group.\n\t */\n\tremoveUniform( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.uniforms.splice( index, 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * An array with the raw uniform values.\n\t *\n\t * @type {Array<Number>}\n\t */\n\tget values() {\n\n\t\tif ( this._values === null ) {\n\n\t\t\tthis._values = Array.from( this.buffer );\n\n\t\t}\n\n\t\treturn this._values;\n\n\t}\n\n\t/**\n\t * A Float32 array buffer with the uniform values.\n\t *\n\t * @type {Float32Array}\n\t */\n\tget buffer() {\n\n\t\tlet buffer = this._buffer;\n\n\t\tif ( buffer === null ) {\n\n\t\t\tconst byteLength = this.byteLength;\n\n\t\t\tbuffer = new Float32Array( new ArrayBuffer( byteLength ) );\n\n\t\t\tthis._buffer = buffer;\n\n\t\t}\n\n\t\treturn buffer;\n\n\t}\n\n\t/**\n\t * The byte length of the buffer with correct buffer alignment.\n\t *\n\t * @type {Number}\n\t */\n\tget byteLength() {\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = this.uniforms[ i ];\n\n\t\t\tconst { boundary, itemSize } = uniform;\n\n\t\t\t// offset within a single chunk in bytes\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES;\n\t\t\tconst remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n\t\t\t// conformance tests\n\n\t\t\tif ( chunkOffset !== 0 && ( remainingSizeInChunk - boundary ) < 0 ) {\n\n\t\t\t\t// check for chunk overflow\n\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkOffset );\n\n\t\t\t} else if ( chunkOffset % boundary !== 0 ) {\n\n\t\t\t\t// check for correct alignment\n\n\t\t\t\toffset += ( chunkOffset % boundary );\n\n\t\t\t}\n\n\t\t\tuniform.offset = ( offset / this.bytesPerElement );\n\n\t\t\toffset += ( itemSize * this.bytesPerElement );\n\n\t\t}\n\n\t\treturn Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;\n\n\t}\n\n\t/**\n\t * Updates this group by updating each uniform object of\n\t * the internal uniform list. The uniform objects check if their\n\t * values has actually changed so this method only returns\n\t * `true` if there is a real value change.\n\t *\n\t * @return {Boolean} Whether the uniforms have been updated and\n\t * must be uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tlet updated = false;\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tif ( this.updateByType( uniform ) === true ) {\n\n\t\t\t\tupdated = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given uniform by calling an update method matching\n\t * the uniforms type.\n\t *\n\t * @param {Uniform} uniform - The uniform to update.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateByType( uniform ) {\n\n\t\tif ( uniform.isNumberUniform ) return this.updateNumber( uniform );\n\t\tif ( uniform.isVector2Uniform ) return this.updateVector2( uniform );\n\t\tif ( uniform.isVector3Uniform ) return this.updateVector3( uniform );\n\t\tif ( uniform.isVector4Uniform ) return this.updateVector4( uniform );\n\t\tif ( uniform.isColorUniform ) return this.updateColor( uniform );\n\t\tif ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );\n\t\tif ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );\n\n\t\tconsole.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );\n\n\t}\n\n\t/**\n\t * Updates a given Number uniform.\n\t *\n\t * @param {NumberUniform} uniform - The Number uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateNumber( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset ] !== v ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset ] = a[ offset ] = v;\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector2 uniform.\n\t *\n\t * @param {Vector2Uniform} uniform - The Vector2 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector2( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector3 uniform.\n\t *\n\t * @param {Vector3Uniform} uniform - The Vector3 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector4 uniform.\n\t *\n\t * @param {Vector4Uniform} uniform - The Vector4 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\t\t\tb[ offset + 3 ] = a[ offset + 3 ] = v.w;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Color uniform.\n\t *\n\t * @param {ColorUniform} uniform - The Color uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateColor( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst c = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = c.r;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = c.g;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = c.b;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Matrix3 uniform.\n\t *\n\t * @param {Matrix3Uniform} uniform - The Matrix3 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateMatrix3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||\n\t\t\ta[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||\n\t\t\ta[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];\n\t\t\tb[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];\n\t\t\tb[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];\n\t\t\tb[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];\n\t\t\tb[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];\n\t\t\tb[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];\n\t\t\tb[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Matrix4 uniform.\n\t *\n\t * @param {Matrix4Uniform} uniform - The Matrix4 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateMatrix4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( arraysEqual( a, e, offset ) === false ) {\n\n\t\t\tconst b = this.buffer;\n\t\t\tb.set( e, offset );\n\t\t\tsetArray( a, e, offset );\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Returns a typed array that matches the given data type.\n\t *\n\t * @param {String} type - The data type.\n\t * @return {TypedArray} The typed array.\n\t */\n\t_getBufferForType( type ) {\n\n\t\tif ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );\n\t\tif ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );\n\t\treturn this.buffer;\n\n\t}\n\n}\n\n/**\n * Sets the values of the second array to the first array.\n *\n * @private\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {Number} offset - An index offset for the first array.\n */\nfunction setArray( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ offset + i ] = b[ i ];\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given arrays are equal.\n *\n * @private\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {Number} offset - An index offset for the first array.\n * @return {Boolean} Whether the given arrays are equal or not.\n */\nfunction arraysEqual( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\tif ( a[ offset + i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nlet _id$3 = 0;\n\n/**\n * A special form of uniforms group that represents\n * the individual uniforms as node-based uniforms.\n *\n * @private\n * @augments UniformsGroup\n */\nclass NodeUniformsGroup extends UniformsGroup {\n\n\t/**\n\t * Constructs a new node-based uniforms group.\n\t *\n\t * @param {String} name - The group's name.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( name, groupNode ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * The group's ID.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$3 ++;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeUniformsGroup = true;\n\n\t}\n\n}\n\nlet _id$2 = 0;\n\n/**\n * Represents a sampled texture binding type.\n *\n * @private\n * @augments Binding\n */\nclass SampledTexture extends Binding {\n\n\t/**\n\t * Constructs a new sampled texture.\n\t *\n\t * @param {String} name - The sampled texture's name.\n\t * @param {Texture?} texture - The texture this binding is referring to.\n\t */\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This identifier.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$2 ++;\n\n\t\t/**\n\t\t * The texture this binding is referring to.\n\t\t *\n\t\t * @type {Texture?}\n\t\t */\n\t\tthis.texture = texture;\n\n\t\t/**\n\t\t * The binding's version.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = texture ? texture.version : 0;\n\n\t\t/**\n\t\t * Whether the texture is a storage texture or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.store = false;\n\n\t\t/**\n\t\t * The binding's generation which is an additional version\n\t\t * qualifier.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.generation = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledTexture = true;\n\n\t}\n\n\t/**\n\t * Returns `true` whether this binding requires an update for the\n\t * given generation.\n\t *\n\t * @param {Number} generation - The generation.\n\t * @return {Boolean} Whether an update is required or not.\n\t */\n\tneedsBindingsUpdate( generation ) {\n\n\t\tconst { texture } = this;\n\n\t\tif ( generation !== this.generation ) {\n\n\t\t\tthis.generation = generation;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn texture.isVideoTexture;\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @return {Boolean} Whether the texture has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tconst { texture, version } = this;\n\n\t\tif ( version !== texture.version ) {\n\n\t\t\tthis.version = texture.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n\n/**\n * A special form of sampled texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments SampledTexture\n */\nclass NodeSampledTexture extends SampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled texture.\n\t *\n\t * @param {String} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {String?} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\t/**\n\t\t * The texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t\t/**\n\t\t * The access type.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.access = access;\n\n\t}\n\n\t/**\n\t * Overwrites the default to additionally check if the node value has changed.\n\t *\n\t * @param {Number} generation - The generation.\n\t * @return {Boolean} Whether an update is required or not.\n\t */\n\tneedsBindingsUpdate( generation ) {\n\n\t\treturn this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @return {Boolean} Whether the texture has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tconst { textureNode } = this;\n\n\t\tif ( this.texture !== textureNode.value ) {\n\n\t\t\tthis.texture = textureNode.value;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn super.update();\n\n\t}\n\n}\n\n/**\n * A special form of sampled cube texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments NodeSampledTexture\n */\nclass NodeSampledCubeTexture extends NodeSampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled cube texture.\n\t *\n\t * @param {String} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {String?} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledCubeTexture = true;\n\n\t}\n\n}\n\n/**\n * A special form of sampled 3D texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments NodeSampledTexture\n */\nclass NodeSampledTexture3D extends NodeSampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled 3D texture.\n\t *\n\t * @param {String} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {String?} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledTexture3D = true;\n\n\t}\n\n}\n\nconst glslMethods = {\n\ttextureDimensions: 'textureSize',\n\tequals: 'equal'\n};\n\nconst precisionLib = {\n\tlow: 'lowp',\n\tmedium: 'mediump',\n\thigh: 'highp'\n};\n\nconst supports$1 = {\n\tswizzleAssign: true,\n\tstorageBuffer: false\n};\n\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\n\n/**\n * A node builder targeting GLSL.\n *\n * This module generates GLSL shader code from node materials and also\n * generates the respective bindings and vertex buffer definitions. These\n * data are later used by the renderer to create render and compute pipelines\n * for render objects.\n *\n * @augments NodeBuilder\n */\nclass GLSLNodeBuilder extends NodeBuilder {\n\n\t/**\n\t * Constructs a new GLSL node builder renderer.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new GLSLNodeParser() );\n\n\t\t/**\n\t\t * A dictionary holds for each shader stage ('vertex', 'fragment', 'compute')\n\t\t * another dictionary which manages UBOs per group ('render','frame','object').\n\t\t *\n\t\t * @type {Object<String,Object<String,NodeUniformsGroup>>}\n\t\t */\n\t\tthis.uniformGroups = {};\n\n\t\t/**\n\t\t * An array that holds objects defining the varying and attribute data in\n\t\t * context of Transform Feedback.\n\t\t *\n\t\t * @type {Object<String,Map<String,Object>>}\n\t\t */\n\t\tthis.transforms = [];\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Map of used extensions.\n\t\t *\n\t\t * @type {Object<String,Map<String,Object>>}\n\t\t */\n\t\tthis.extensions = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage an Array of used builtins.\n\t\t *\n\t\t * @type {Object<String,Array<String>>}\n\t\t */\n\t\tthis.builtins = { vertex: [], fragment: [], compute: [] };\n\n\t\t/**\n\t\t * Whether comparison in shader code are generated with methods or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.useComparisonMethod = true;\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {Boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @param {String} method - The method name to resolve.\n\t * @return {String} The resolved GLSL method name.\n\t */\n\tgetMethod( method ) {\n\n\t\treturn glslMethods[ method ] || method;\n\n\t}\n\n\t/**\n\t * Returns the output struct name. Not relevant for GLSL.\n\t *\n\t * @return {String}\n\t */\n\tgetOutputStructName() {\n\n\t\treturn '';\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {String} The GLSL function code.\n\t */\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( this.getType( input.type ) + ' ' + input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tconst code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {\n\n\t${ flowData.vars }\n\n${ flowData.code }\n\treturn ${ flowData.result };\n\n}`;\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Setups the Pixel Buffer Object (PBO) for the given storage\n\t * buffer node.\n\t *\n\t * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n\t */\n\tsetupPBO( storageBufferNode ) {\n\n\t\tconst attribute = storageBufferNode.value;\n\n\t\tif ( attribute.pbo === undefined ) {\n\n\t\t\tconst originalArray = attribute.array;\n\t\t\tconst numElements = attribute.count * attribute.itemSize;\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );\n\n\t\t\tlet format = isInteger ? RedIntegerFormat : RedFormat;\n\n\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\tformat = isInteger ? RGIntegerFormat : RGFormat;\n\n\t\t\t} else if ( itemSize === 3 ) {\n\n\t\t\t\tformat = isInteger ? RGBIntegerFormat : RGBFormat;\n\n\t\t\t} else if ( itemSize === 4 ) {\n\n\t\t\t\tformat = isInteger ? RGBAIntegerFormat : RGBAFormat;\n\n\t\t\t}\n\n\t\t\tconst typeMap = {\n\t\t\t\tFloat32Array: FloatType,\n\t\t\t\tUint8Array: UnsignedByteType,\n\t\t\t\tUint16Array: UnsignedShortType,\n\t\t\t\tUint32Array: UnsignedIntType,\n\t\t\t\tInt8Array: ByteType,\n\t\t\t\tInt16Array: ShortType,\n\t\t\t\tInt32Array: IntType,\n\t\t\t\tUint8ClampedArray: UnsignedByteType,\n\t\t\t};\n\n\t\t\tconst width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );\n\t\t\tlet height = Math.ceil( ( numElements / itemSize ) / width );\n\t\t\tif ( width * height * itemSize < numElements ) height ++; // Ensure enough space\n\n\t\t\tconst newSize = width * height * itemSize;\n\n\t\t\tconst newArray = new originalArray.constructor( newSize );\n\n\t\t\tnewArray.set( originalArray, 0 );\n\n\t\t\tattribute.array = newArray;\n\n\t\t\tconst pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );\n\t\t\tpboTexture.needsUpdate = true;\n\t\t\tpboTexture.isPBOTexture = true;\n\n\t\t\tconst pbo = new TextureNode( pboTexture, null, null );\n\t\t\tpbo.setPrecision( 'high' );\n\n\t\t\tattribute.pboNode = pbo;\n\t\t\tattribute.pbo = pbo.value;\n\n\t\t\tthis.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a GLSL snippet that represents the property name of the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The property name.\n\t */\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {\n\n\t\t\treturn shaderStage.charAt( 0 ) + '_' + node.name;\n\n\t\t}\n\n\t\treturn super.getPropertyName( node, shaderStage );\n\n\t}\n\n\t/**\n\t * Setups the Pixel Buffer Object (PBO) for the given storage\n\t * buffer node.\n\t *\n\t * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.\n\t * @return {String} The property name.\n\t */\n\tgeneratePBO( storageArrayElementNode ) {\n\n\t\tconst { node, indexNode } = storageArrayElementNode;\n\t\tconst attribute = node.value;\n\n\t\tif ( this.renderer.backend.has( attribute ) ) {\n\n\t\t\tconst attributeData = this.renderer.backend.get( attribute );\n\t\t\tattributeData.pbo = attribute.pbo;\n\n\t\t}\n\n\t\tconst nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\t\tconst textureName = this.getPropertyName( nodeUniform );\n\n\t\tthis.increaseUsage( indexNode ); // force cache generate to be used as index in x,y\n\t\tconst indexSnippet = indexNode.build( this, 'uint' );\n\n\t\tconst elementNodeData = this.getDataFromNode( storageArrayElementNode );\n\n\t\tlet propertyName = elementNodeData.propertyName;\n\n\t\tif ( propertyName === undefined ) {\n\n\t\t\t// property element\n\n\t\t\tconst nodeVar = this.getVarFromNode( storageArrayElementNode );\n\n\t\t\tpropertyName = this.getPropertyName( nodeVar );\n\n\t\t\t// property size\n\n\t\t\tconst bufferNodeData = this.getDataFromNode( node );\n\n\t\t\tlet propertySizeName = bufferNodeData.propertySizeName;\n\n\t\t\tif ( propertySizeName === undefined ) {\n\n\t\t\t\tpropertySizeName = propertyName + 'Size';\n\n\t\t\t\tthis.getVarFromNode( node, propertySizeName, 'uint' );\n\n\t\t\t\tthis.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );\n\n\t\t\t\tbufferNodeData.propertySizeName = propertySizeName;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );\n\t\t\tconst uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;\n\n\t\t\tconst snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );\n\n\t\t\t//\n\n\n\t\t\tlet prefix = 'vec4';\n\n\t\t\tif ( attribute.pbo.type === UnsignedIntType ) {\n\n\t\t\t\tprefix = 'uvec4';\n\n\t\t\t} else if ( attribute.pbo.type === IntType ) {\n\n\t\t\t\tprefix = 'ivec4';\n\n\t\t\t}\n\n\t\t\tthis.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );\n\n\t\t\telementNodeData.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {String?} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.\n\t * @param {String} [levelSnippet='0u'] - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {String} The GLSL snippet.\n\t */\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {\n\n\t\tif ( depthSnippet ) {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;\n\n\t\t} else {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling/loading the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {String?} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.\n\t * @return {String} The GLSL snippet.\n\t */\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } ).x`;\n\n\t\t} else {\n\n\t\t\tif ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } )`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {String} The GLSL snippet.\n\t */\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {\n\n\t\treturn `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet when sampling textures with a bias to the mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.\n\t * @return {String} The GLSL snippet.\n\t */\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {\n\n\t\treturn `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {Array<String>} gradSnippet - An array holding both gradient GLSL snippets.\n\t * @return {String} The GLSL snippet.\n\t */\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {\n\n\t\treturn `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values\n\t * against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} compareSnippet -  A GLSL snippet that represents the reference value.\n\t * @param {String?} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The GLSL snippet.\n\t */\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the variables of the given shader stage as a GLSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The GLSL snippet that defines the variables.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `${ this.getVar( variable.type, variable.name, variable.count ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\t' );\n\n\t}\n\n\t/**\n\t * Returns the uniforms of the given shader stage as a GLSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The GLSL snippet that defines the uniforms.\n\t */\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tlet snippet = null;\n\t\t\tlet group = false;\n\n\t\t\tif ( uniform.type === 'texture' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tlet typePrefix = '';\n\n\t\t\t\tif ( texture.isDataTexture === true ) {\n\n\n\t\t\t\t\tif ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'u';\n\n\t\t\t\t\t} else if ( texture.type === IntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'i';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.compareFunction ) {\n\n\t\t\t\t\tsnippet = `sampler2DShadow ${ uniform.name };`;\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2DArray ${ uniform.name };`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2D ${ uniform.name };`;\n\n\t\t\t\t}\n\n\t\t\t} else if ( uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tsnippet = `samplerCube ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'texture3D' ) {\n\n\t\t\t\tsnippet = `sampler3D ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'buffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n\t\t\t\tsnippet = `${bufferNode.name} {\\n\\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\\n};\\n`;\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getVectorType( uniform.type );\n\n\t\t\t\tsnippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;\n\n\t\t\t\tgroup = true;\n\n\t\t\t}\n\n\t\t\tconst precision = uniform.node.precision;\n\n\t\t\tif ( precision !== null ) {\n\n\t\t\t\tsnippet = precisionLib[ precision ] + ' ' + snippet;\n\n\t\t\t}\n\n\t\t\tif ( group ) {\n\n\t\t\t\tsnippet = '\\t' + snippet;\n\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\t\tconst groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );\n\n\t\t\t\tgroupSnippets.push( snippet );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = 'uniform ' + snippet;\n\n\t\t\t\tbindingSnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet output = '';\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst groupSnippets = uniformGroups[ name ];\n\n\t\t\toutput += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\\n' ) ) + '\\n';\n\n\t\t}\n\n\t\toutput += bindingSnippets.join( '\\n' );\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Returns the type for a given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @return {String} The type.\n\t */\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet nodeType = super.getTypeFromAttribute( attribute );\n\n\t\tif ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {\n\n\t\t\tlet dataAttribute = attribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\t\tconst array = dataAttribute.array;\n\n\t\t\tif ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {\n\n\t\t\t\tnodeType = nodeType.slice( 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Returns the shader attributes of the given shader stage as a GLSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The GLSL snippet that defines the shader attributes.\n\t */\n\tgetAttributes( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tlet location = 0;\n\n\t\t\tfor ( const attribute of attributes ) {\n\n\t\t\t\tsnippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the members of the given struct type node as a GLSL string.\n\t *\n\t * @param {StructTypeNode} struct - The struct type node.\n\t * @return {String} The GLSL snippet that defines the struct members.\n\t */\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of struct.members ) {\n\n\t\t\tsnippets.push( `\\t${ member.type } ${ member.name };` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the structs of the given shader stage as a GLSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The GLSL snippet that defines the structs.\n\t */\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tconst outputSnippet = [];\n\n\t\tfor ( const struct of structs ) {\n\n\t\t\tif ( struct.output ) {\n\n\t\t\t\tfor ( const member of struct.members ) {\n\n\t\t\t\t\toutputSnippet.push( `layout( location = ${ member.index } ) out ${ member.type } ${ member.name };` );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlet snippet = 'struct ' + struct.name + ' {\\n';\n\t\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\t\tsnippet += '\\n};\\n';\n\n\t\t\t\tsnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( outputSnippet.length === 0 ) {\n\n\t\t\toutputSnippet.push( 'layout( location = 0 ) out vec4 fragColor;' );\n\n\t\t}\n\n\t\treturn '\\n' + outputSnippet.join( '\\n' ) + '\\n\\n' + snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the varyings of the given shader stage as a GLSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The GLSL snippet that defines the varyings.\n\t */\n\tgetVaryings( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst varyings = this.varyings;\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( shaderStage === 'compute' ) varying.needsInterpolation = true;\n\n\t\t\t\tconst type = this.getType( varying.type );\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\tsnippet += `${flat} out ${type} ${varying.name};\\n`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet += `${type} ${varying.name};\\n`; // generate variable (no varying required)\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst type = this.getType( varying.type );\n\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\tsnippet += `${flat}in ${type} ${varying.name};\\n`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const builtin of this.builtins[ shaderStage ] ) {\n\n\t\t\tsnippet += `${builtin};\\n`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the vertex index builtin.\n\t *\n\t * @return {String} The vertex index.\n\t */\n\tgetVertexIndex() {\n\n\t\treturn 'uint( gl_VertexID )';\n\n\t}\n\n\t/**\n\t * Returns the instance index builtin.\n\t *\n\t * @return {String} The instance index.\n\t */\n\tgetInstanceIndex() {\n\n\t\treturn 'uint( gl_InstanceID )';\n\n\t}\n\n\t/**\n\t * Returns the invocation local index builtin.\n\t *\n\t * @return {String} The invocation local index.\n\t */\n\tgetInvocationLocalIndex() {\n\n\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\tconst size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );\n\n\t\treturn `uint( gl_InstanceID ) % ${size}u`;\n\n\t}\n\n\t/**\n\t * Returns the draw index builtin.\n\t *\n\t * @return {String?} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.\n\t */\n\tgetDrawIndex() {\n\n\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\tif ( extensions.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\treturn 'uint( gl_DrawID )';\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the front facing builtin.\n\t *\n\t * @return {String} The front facing builtin.\n\t */\n\tgetFrontFacing() {\n\n\t\treturn 'gl_FrontFacing';\n\n\t}\n\n\t/**\n\t * Returns the frag coord builtin.\n\t *\n\t * @return {String} The frag coord builtin.\n\t */\n\tgetFragCoord() {\n\n\t\treturn 'gl_FragCoord.xy';\n\n\t}\n\n\t/**\n\t * Returns the frag depth builtin.\n\t *\n\t * @return {String} The frag depth builtin.\n\t */\n\tgetFragDepth() {\n\n\t\treturn 'gl_FragDepth';\n\n\t}\n\n\t/**\n\t * Enables the given extension.\n\t *\n\t * @param {String} name - The extension name.\n\t * @param {String} behavior - The extension behavior.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage.\n\t */\n\tenableExtension( name, behavior, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tbehavior\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the enabled extensions of the given shader stage as a GLSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The GLSL snippet that defines the enabled extensions.\n\t */\n\tgetExtensions( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tconst ext = this.renderer.backend.extensions;\n\t\t\tconst isBatchedMesh = this.object.isBatchedMesh;\n\n\t\t\tif ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\tthis.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensions = this.extensions[ shaderStage ];\n\n\t\tif ( extensions !== undefined ) {\n\n\t\t\tfor ( const { name, behavior } of extensions.values() ) {\n\n\t\t\t\tsnippets.push( `#extension ${name} : ${behavior}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the clip distances builtin.\n\t *\n\t * @return {String} The clip distances builtin.\n\t */\n\tgetClipDistance() {\n\n\t\treturn 'gl_ClipDistance';\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @param {String} name - The requested feature.\n\t * @return {Boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( name ) {\n\n\t\tlet result = supports$1[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tlet extensionName;\n\n\t\t\tresult = false;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'float32Filterable':\n\t\t\t\t\textensionName = 'OES_texture_float_linear';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'clipDistance':\n\t\t\t\t\textensionName = 'WEBGL_clip_cull_distance';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( extensionName !== undefined ) {\n\n\t\t\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\t\t\tif ( extensions.has( extensionName ) ) {\n\n\t\t\t\t\textensions.get( extensionName );\n\t\t\t\t\tresult = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsupports$1[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not.\n\t *\n\t * @return {Boolean} Returns always `true` in context of GLSL.\n\t */\n\tisFlipY() {\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Enables hardware clipping.\n\t *\n\t * @param {String} planeCount - The clipping plane count.\n\t */\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );\n\n\t\tthis.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );\n\n\t}\n\n\t/**\n\t * Registers a transform in context of Transform Feedback.\n\t *\n\t * @param {String} varyingName - The varying name.\n\t * @param {AttributeNode} attributeNode - The attribute node.\n\t */\n\tregisterTransform( varyingName, attributeNode ) {\n\n\t\tthis.transforms.push( { varyingName, attributeNode } );\n\n\t}\n\n\t/**\n\t * Returns the transforms of the given shader stage as a GLSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The GLSL snippet that defines the transforms.\n\t */\n\tgetTransforms( /* shaderStage  */ ) {\n\n\t\tconst transforms = this.transforms;\n\n\t\tlet snippet = '';\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\tconst attributeName = this.getPropertyName( transform.attributeNode );\n\n\t\t\tsnippet += `${ transform.varyingName } = ${ attributeName };\\n\\t`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns a GLSL struct based on the given name and variables.\n\t *\n\t * @private\n\t * @param {String} name - The struct name.\n\t * @param {String} vars - The struct variables.\n\t * @return {String} The GLSL snippet representing a struct.\n\t */\n\t_getGLSLUniformStruct( name, vars ) {\n\n\t\treturn `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n\n\t}\n\n\t/**\n\t * Returns a GLSL vertex shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {String} The vertex shader.\n\t */\n\t_getGLSLVertexCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions \n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a GLSL fragment shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {String} The vertex shader.\n\t */\n\t_getGLSLFragmentCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n// structs\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t */\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'gl_Position = ';\n\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( ! node.outputNode.isOutputStructNode ) {\n\n\t\t\t\t\t\t\tflow += 'fragColor = ';\n\t\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.extensions = this.getExtensions( shaderStage );\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.transforms = this.getTransforms( shaderStage );\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getGLSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getGLSLVertexCode( shadersData.compute );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is one of the more important ones since it's responsible\n\t * for generating a matching binding instance for the given uniform node.\n\t *\n\t * These bindings are later used in the renderer to create bind groups\n\t * and layouts.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {String} type - The node data type.\n\t * @param {String} shaderStage - The shader stage.\n\t * @param {String?} [name=null] - An optional uniform name.\n\t * @return {NodeUniform} The node uniform object.\n\t */\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet uniformGPU = nodeData.uniformGPU;\n\n\t\tif ( uniformGPU === undefined ) {\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'buffer' ) {\n\n\t\t\t\tnode.name = `NodeBuffer_${ node.id }`;\n\t\t\t\tuniformNode.name = `buffer${ node.id }`;\n\n\t\t\t\tconst buffer = new NodeUniformBuffer( node, group );\n\t\t\t\tbuffer.name = node.name;\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n}\n\nlet _vector2 = null;\nlet _color4 = null;\n\n/**\n * Most of the rendering related logic is implemented in the\n * {@link module:Renderer} module and related management components.\n * Sometimes it is required though to execute commands which are\n * specific to the current 3D backend (which is WebGPU or WebGL 2).\n * This abstract base class defines an interface that encapsulates\n * all backend-related logic. Derived classes for each backend must\n * implement the interface.\n *\n * @abstract\n * @private\n */\nclass Backend {\n\n\t/**\n\t * Constructs a new backend.\n\t *\n\t * @param {Object} parameters - An object holding parameters for the backend.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\t/**\n\t\t * The parameters of the backend.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = Object.assign( {}, parameters );\n\n\t\t/**\n\t\t * This weak map holds backend-specific data of objects\n\t\t * like textures, attributes or render targets.\n\t\t *\n\t\t * @type {WeakMap}\n\t\t */\n\t\tthis.data = new WeakMap();\n\n\t\t/**\n\t\t * A reference to the renderer.\n\t\t *\n\t\t * @type {Renderer?}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = null;\n\n\t\t/**\n\t\t * A reference to the canvas element the renderer is drawing to.\n\t\t *\n\t\t * @type {(HTMLCanvasElement|OffscreenCanvas)?}\n\t\t * @default null\n\t\t */\n\t\tthis.domElement = null;\n\n\t\t/**\n\t\t * A reference to the timestamp query pool.\n   \t\t *\n   \t\t * @type {{render: TimestampQueryPool?, compute: TimestampQueryPool?}}\n\t\t */\n\t\tthis.timestampQueryPool = {\n\t\t\t'render': null,\n\t\t\t'compute': null\n\t\t};\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage. Concrete backends\n\t * are supposed to implement their rendering context creation and related\n\t * operations in this method.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the backend has been initialized.\n\t */\n\tasync init( renderer ) {\n\n\t\tthis.renderer = renderer;\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @abstract\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {}\n\n\t// render context\n\n\t/**\n\t * This method is executed at the beginning of a render call and\n\t * can be used by the backend to prepare the state for upcoming\n\t * draw calls.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( /*renderContext*/ ) {}\n\n\t/**\n\t * This method is executed at the end of a render call and\n\t * can be used by the backend to finalize work after draw\n\t * calls.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( /*renderContext*/ ) {}\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * can be used by the backend to prepare the state for upcoming\n\t * compute tasks.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( /*computeGroup*/ ) {}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * can be used by the backend to finalize work after compute\n\t * tasks.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( /*computeGroup*/ ) {}\n\n\t// render object\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( /*renderObject, info*/ ) { }\n\n\t// compute node\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t */\n\tcompute( /*computeGroup, computeNode, computeBindings, computePipeline*/ ) { }\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @abstract\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( /*program*/ ) { }\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @abstract\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( /*program*/ ) { }\n\n\t// bindings\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @abstract\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tcreateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @abstract\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tupdateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t * @abstract\n\t * @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( /*binding*/ ) { }\n\n\t// pipeline\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( /*renderObject, promises*/ ) { }\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @abstract\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( /*computePipeline, bindings*/ ) { }\n\n\t// cache key\n\n\t/**\n\t * Returns `true` if the render pipeline requires an update.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( /*renderObject*/ ) { }\n\n\t/**\n\t * Returns a cache key that is used to identify render pipelines.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {String} The cache key.\n\t */\n\tgetRenderCacheKey( /*renderObject*/ ) { }\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {NodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( /*renderObject, renderer*/ ) { }\n\n\t// textures\n\n\t/**\n\t * Creates a GPU sampler for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( /*texture*/ ) { }\n\n\t/**\n\t * Destroys the GPU sampler for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( /*texture*/ ) {}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( /*texture*/ ) { }\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( /*texture, options={}*/ ) { }\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( /*texture, options = {}*/ ) { }\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( /*texture*/ ) { }\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( /*texture*/ ) { }\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @abstract\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {Number} x - The x coordinate of the copy origin.\n\t * @param {Number} y - The y coordinate of the copy origin.\n\t * @param {Number} width - The width of the copy.\n\t * @param {Number} height - The height of the copy.\n\t * @param {Number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( /*texture, x, y, width, height, faceIndex*/ ) {}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @abstract\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n\t * @param {Number} [level=0] - The mip level to copy.\n\t */\n\tcopyTextureToTexture( /*srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0*/ ) {}\n\n\t/**\n\t* Copies the current bound framebuffer to the given texture.\n\t*\n\t* @abstract\n\t* @param {Texture} texture - The destination texture.\n\t* @param {RenderContext} renderContext - The render context.\n\t* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t*/\n\tcopyFramebufferToTexture( /*texture, renderContext, rectangle*/ ) {}\n\n\t// attributes\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Creates the GPU buffer of an indexed shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( /*attribute*/ ) { }\n\n\t// canvas\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @abstract\n\t * @return {Object} The rendering context.\n\t */\n\tgetContext() { }\n\n\t/**\n\t * Backends can use this method if they have to run\n\t * logic when the renderer gets resized.\n\t *\n\t * @abstract\n\t */\n\tupdateSize() { }\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( /*renderContext*/ ) {}\n\n\t// utils\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene. Backends must implement this method by using\n\t * a Occlusion Query API.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {Boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( /*renderContext, object*/ ) {}\n\n\t/**\n\t * Resolves the time stamp for the given render context and type.\n\t *\n\t * @async\n\t * @abstract\n\t * @param {String} [type='render'] - The type of the time stamp.\n\t * @return {Promise<Number>} A Promise that resolves with the time stamp.\n\t */\n\tasync resolveTimestampsAsync( type = 'render' ) {\n\n\t\tif ( ! this.trackTimestamp ) {\n\n\t\t\twarnOnce( 'WebGPURenderer: Timestamp tracking is disabled.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst queryPool = this.timestampQueryPool[ type ];\n\t\tif ( ! queryPool ) {\n\n\t\t\twarnOnce( `WebGPURenderer: No timestamp query pool for type '${type}' found.` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst duration = await queryPool.resolveQueriesAsync();\n\n\t\tthis.renderer.info[ type ].timestamp = duration;\n\n\t\treturn duration;\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @abstract\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( /* attribute */ ) {}\n\n\t/**\n\t * Checks if the given feature is supported by the backend.\n\t *\n\t * @async\n\t * @abstract\n\t * @param {String} name - The feature's name.\n\t * @return {Promise<Boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n\t */\n\tasync hasFeatureAsync( /*name*/ ) { }\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @abstract\n\t * @param {String} name - The feature's name.\n\t * @return {Boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( /*name*/ ) {}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @abstract\n\t * @return {Number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {}\n\n\t/**\n\t * Returns the drawing buffer size.\n\t *\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize() {\n\n\t\t_vector2 = _vector2 || new Vector2();\n\n\t\treturn this.renderer.getDrawingBufferSize( _vector2 );\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @abstract\n\t * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( /*boolean*/ ) { }\n\n\t/**\n\t * Returns the clear color and alpha into a single\n\t * color object.\n\t *\n\t * @return {Color4} The clear color.\n\t */\n\tgetClearColor() {\n\n\t\tconst renderer = this.renderer;\n\n\t\t_color4 = _color4 || new Color4();\n\n\t\trenderer.getClearColor( _color4 );\n\n\t\t_color4.getRGB( _color4, this.renderer.currentColorSpace );\n\n\t\treturn _color4;\n\n\t}\n\n\t/**\n\t * Returns the DOM element. If no DOM element exists, the backend\n\t * creates a new one.\n\t *\n\t * @return {HTMLCanvasElement} The DOM element.\n\t */\n\tgetDomElement() {\n\n\t\tlet domElement = this.domElement;\n\n\t\tif ( domElement === null ) {\n\n\t\t\tdomElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );\n\n\t\t\tthis.domElement = domElement;\n\n\t\t}\n\n\t\treturn domElement;\n\n\t}\n\n\t/**\n\t * Sets a dictionary for the given object into the\n\t * internal data structure.\n\t *\n\t * @param {Object} object - The object.\n\t * @param {Object} value - The dictionary to set.\n\t */\n\tset( object, value ) {\n\n\t\tthis.data.set( object, value );\n\n\t}\n\n\t/**\n\t * Returns the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object} The object's dictionary.\n\t */\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Checks if the given object has a dictionary\n\t * with data defined.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Boolean} Whether a dictionary for the given object as been defined or not.\n\t */\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\t/**\n\t * Deletes an object from the internal data structure.\n\t *\n\t * @param {Object} object - The object to delete.\n\t */\n\tdelete( object ) {\n\n\t\tthis.data.delete( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t *\n\t * @abstract\n\t */\n\tdispose() { }\n\n}\n\nlet _id$1 = 0;\n\n/**\n * This module is internally used in context of compute shaders.\n * This type of shader is not natively supported in WebGL 2 and\n * thus implemented via Transform Feedback. `DualAttributeData`\n * manages the related data.\n *\n * @private\n */\nclass DualAttributeData {\n\n\tconstructor( attributeData, dualBuffer ) {\n\n\t\tthis.buffers = [ attributeData.bufferGPU, dualBuffer ];\n\t\tthis.type = attributeData.type;\n\t\tthis.bufferType = attributeData.bufferType;\n\t\tthis.pbo = attributeData.pbo;\n\t\tthis.byteLength = attributeData.byteLength;\n\t\tthis.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n\t\tthis.version = attributeData.version;\n\t\tthis.isInteger = attributeData.isInteger;\n\t\tthis.activeBufferIndex = 0;\n\t\tthis.baseId = attributeData.id;\n\n\t}\n\n\n\tget id() {\n\n\t\treturn `${ this.baseId }|${ this.activeBufferIndex }`;\n\n\t}\n\n\tget bufferGPU() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ];\n\n\t}\n\n\tget transformBuffer() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ^ 1 ];\n\n\t}\n\n\tswitchBuffers() {\n\n\t\tthis.activeBufferIndex ^= 1;\n\n\t}\n\n}\n\n/**\n * A WebGL 2 backend utility module for managing shader attributes.\n *\n * @private\n */\nclass WebGLAttributeUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer for the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.\n\t */\n\tcreateAttribute( attribute, bufferType ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage || gl.STATIC_DRAW;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet bufferGPU = bufferData.bufferGPU;\n\n\t\tif ( bufferGPU === undefined ) {\n\n\t\t\tbufferGPU = this._createBuffer( gl, bufferType, array, usage );\n\n\t\t\tbufferData.bufferGPU = bufferGPU;\n\t\t\tbufferData.bufferType = bufferType;\n\t\t\tbufferData.version = bufferAttribute.version;\n\n\t\t}\n\n\t\t//attribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\tlet attributeData = {\n\t\t\tbufferGPU,\n\t\t\tbufferType,\n\t\t\ttype,\n\t\t\tbyteLength: array.byteLength,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tpbo: attribute.pbo,\n\t\t\tisInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n\t\t\tid: _id$1 ++\n\t\t};\n\n\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t// create buffer for transform feedback use\n\t\t\tconst bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );\n\t\t\tattributeData = new DualAttributeData( attributeData, bufferGPUDual );\n\n\t\t}\n\n\t\tbackend.set( attribute, attributeData );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\t\tconst bufferType = bufferData.bufferType;\n\t\tconst updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, bufferData.bufferGPU );\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\tbufferData.version = bufferAttribute.version;\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tbackend.delete( attribute.data );\n\n\t\t}\n\n\t\tconst attributeData = backend.get( attribute );\n\n\t\tgl.deleteBuffer( attributeData.bufferGPU );\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst { bufferGPU } = backend.get( bufferAttribute );\n\n\t\tconst array = attribute.array;\n\t\tconst byteLength = array.byteLength;\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );\n\n\t\tconst writeBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\t\tgl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );\n\n\t\tgl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new attribute.array.constructor( array.length );\n\n\t\t// Ensure the buffer is bound before reading\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\n\t\tgl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );\n\n\t\tgl.deleteBuffer( writeBuffer );\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, null );\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, null );\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t/**\n\t * Creates a WebGL buffer with the given data.\n\t *\n\t * @private\n\t * @param {WebGL2RenderingContext} gl - The rendering context.\n\t * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.\n\t * @param {TypedArray} array - The array of the buffer attribute.\n\t * @param {GLenum} usage - The usage.\n\t * @return {WebGLBuffer} The WebGL buffer.\n\t */\n\t_createBuffer( gl, bufferType, array, usage ) {\n\n\t\tconst bufferGPU = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, bufferGPU );\n\t\tgl.bufferData( bufferType, array, usage );\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\treturn bufferGPU;\n\n\t}\n\n}\n\nlet equationToGL, factorToGL;\n\n/**\n * A WebGL 2 backend utility module for managing the WebGL state.\n *\n * The major goal of this module is to reduce the number of state changes\n * by caching the WEbGL state with a series of variables. In this way, the\n * renderer only executes state change commands when necessary which\n * improves the overall performance.\n *\n * @private\n */\nclass WebGLState {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext}\n\t\t */\n\t\tthis.gl = this.backend.gl;\n\n\t\t// Below properties are intended to cache\n\t\t// the WebGL state and are not explicitly\n\t\t// documented for convenience reasons.\n\n\t\tthis.enabled = {};\n\t\tthis.currentFlipSided = null;\n\t\tthis.currentCullFace = null;\n\t\tthis.currentProgram = null;\n\t\tthis.currentBlendingEnabled = false;\n\t\tthis.currentBlending = null;\n\t\tthis.currentBlendSrc = null;\n\t\tthis.currentBlendDst = null;\n\t\tthis.currentBlendSrcAlpha = null;\n\t\tthis.currentBlendDstAlpha = null;\n\t\tthis.currentPremultipledAlpha = null;\n\t\tthis.currentPolygonOffsetFactor = null;\n\t\tthis.currentPolygonOffsetUnits = null;\n\t\tthis.currentColorMask = null;\n\t\tthis.currentDepthFunc = null;\n\t\tthis.currentDepthMask = null;\n\t\tthis.currentStencilFunc = null;\n\t\tthis.currentStencilRef = null;\n\t\tthis.currentStencilFuncMask = null;\n\t\tthis.currentStencilFail = null;\n\t\tthis.currentStencilZFail = null;\n\t\tthis.currentStencilZPass = null;\n\t\tthis.currentStencilMask = null;\n\t\tthis.currentLineWidth = null;\n\t\tthis.currentClippingPlanes = 0;\n\n\t\tthis.currentBoundFramebuffers = {};\n\t\tthis.currentDrawbuffers = new WeakMap();\n\n\t\tthis.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tthis.currentTextureSlot = null;\n\t\tthis.currentBoundTextures = {};\n\t\tthis.currentBoundBufferBases = {};\n\n\n\t\tthis._init();\n\n\t}\n\n\t/**\n\t * Inits the state of the utility.\n\t *\n\t * @private\n\t */\n\t_init() {\n\n\t\tconst gl = this.gl;\n\n\t\t// Store only WebGL constants here.\n\n\t\tequationToGL = {\n\t\t\t[ AddEquation ]: gl.FUNC_ADD,\n\t\t\t[ SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t\t[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t\t};\n\n\t\tfactorToGL = {\n\t\t\t[ ZeroFactor ]: gl.ZERO,\n\t\t\t[ OneFactor ]: gl.ONE,\n\t\t\t[ SrcColorFactor ]: gl.SRC_COLOR,\n\t\t\t[ SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t\t[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t\t[ DstColorFactor ]: gl.DST_COLOR,\n\t\t\t[ DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t\t[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t\t[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t\t[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t\t[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA\n\t\t};\n\n\t\tconst scissorParam = gl.getParameter( gl.SCISSOR_BOX );\n\t\tconst viewportParam = gl.getParameter( gl.VIEWPORT );\n\n\t\tthis.currentScissor = new Vector4().fromArray( scissorParam );\n\t\tthis.currentViewport = new Vector4().fromArray( viewportParam );\n\n\t\tthis._tempVec4 = new Vector4();\n\n\t}\n\n\t/**\n\t * Enables the given WebGL capability.\n\t *\n\t * This method caches the capability state so\n\t * `gl.enable()` is only called when necessary.\n\t *\n\t * @param {GLenum} id - The capability to enable.\n\t */\n\tenable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== true ) {\n\n\t\t\tthis.gl.enable( id );\n\t\t\tenabled[ id ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disables the given WebGL capability.\n\t *\n\t * This method caches the capability state so\n\t * `gl.disable()` is only called when necessary.\n\t *\n\t * @param {GLenum} id - The capability to enable.\n\t */\n\tdisable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== false ) {\n\n\t\t\tthis.gl.disable( id );\n\t\t\tenabled[ id ] = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether polygons are front- or back-facing\n\t * by setting the winding orientation.\n\t *\n\t * This method caches the state so `gl.frontFace()` is only\n\t * called when necessary.\n\t *\n\t * @param {Boolean} flipSided - Whether triangles flipped their sides or not.\n\t */\n\tsetFlipSided( flipSided ) {\n\n\t\tif ( this.currentFlipSided !== flipSided ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tthis.currentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether or not front- and/or back-facing\n\t * polygons can be culled.\n\t *\n\t * This method caches the state so `gl.cullFace()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} cullFace - Defines which polygons are candidates for culling.\n\t */\n\tsetCullFace( cullFace ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== this.currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tthis.currentCullFace = cullFace;\n\n\t}\n\n\t/**\n\t * Specifies the width of line primitives.\n\t *\n\t * This method caches the state so `gl.lineWidth()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} width - The line width.\n\t */\n\tsetLineWidth( width ) {\n\n\t\tconst { currentLineWidth, gl } = this;\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tthis.currentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines the blending.\n\t *\n\t * This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,\n\t * `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.\n\t *\n\t * @param {Number} blending - The blending type.\n\t * @param {Number} blendEquation - The blending equation.\n\t * @param {Number} blendSrc - Only relevant for custom blending. The RGB source blending factor.\n\t * @param {Number} blendDst - Only relevant for custom blending. The RGB destination blending factor.\n\t * @param {Number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.\n\t * @param {Number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.\n\t * @param {Number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.\n\t * @param {Boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.\n\t */\n\tsetBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( this.currentBlendingEnabled === true ) {\n\n\t\t\t\tthis.disable( gl.BLEND );\n\t\t\t\tthis.currentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.currentBlendingEnabled === false ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\t\t\tthis.currentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {\n\n\t\t\t\tif ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tthis.currentBlendEquation = AddEquation;\n\t\t\t\t\tthis.currentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.currentBlendSrc = null;\n\t\t\t\tthis.currentBlendDst = null;\n\t\t\t\tthis.currentBlendSrcAlpha = null;\n\t\t\t\tthis.currentBlendDstAlpha = null;\n\n\t\t\t\tthis.currentBlending = blending;\n\t\t\t\tthis.currentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tthis.currentBlendEquation = blendEquation;\n\t\t\tthis.currentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tthis.currentBlendSrc = blendSrc;\n\t\t\tthis.currentBlendDst = blendDst;\n\t\t\tthis.currentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tthis.currentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tthis.currentBlending = blending;\n\t\tthis.currentPremultipledAlpha = false;\n\n\t}\n\n\t/**\n\t * Specifies whether colors can be written when rendering\n\t * into a framebuffer or not.\n\t *\n\t * This method caches the state so `gl.colorMask()` is only\n\t * called when necessary.\n\t *\n\t * @param {Boolean} colorMask - The color mask.\n\t */\n\tsetColorMask( colorMask ) {\n\n\t\tif ( this.currentColorMask !== colorMask ) {\n\n\t\t\tthis.gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tthis.currentColorMask = colorMask;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether the depth test is enabled or not.\n\t *\n\t * @param {Boolean} depthTest - Whether the depth test is enabled or not.\n\t */\n\tsetDepthTest( depthTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( depthTest ) {\n\n\t\t\tthis.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether depth values can be written when rendering\n\t * into a framebuffer or not.\n\t *\n\t * This method caches the state so `gl.depthMask()` is only\n\t * called when necessary.\n\t *\n\t * @param {Boolean} depthMask - The depth mask.\n\t */\n\tsetDepthMask( depthMask ) {\n\n\t\tif ( this.currentDepthMask !== depthMask ) {\n\n\t\t\tthis.gl.depthMask( depthMask );\n\t\t\tthis.currentDepthMask = depthMask;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies the depth compare function.\n\t *\n\t * This method caches the state so `gl.depthFunc()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} depthFunc - The depth compare function.\n\t */\n\tsetDepthFunc( depthFunc ) {\n\n\t\tif ( this.currentDepthFunc !== depthFunc ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tthis.currentDepthFunc = depthFunc;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies the viewport.\n\t *\n\t * @param {Number} x - The x-coordinate of the lower left corner of the viewport.\n\t * @param {Number} y - The y-coordinate of the lower left corner of the viewport.\n\t * @param {Number} width - The width of the viewport.\n\t * @param {Number} height - The height of the viewport.\n\t *\n\t */\n\tscissor( x, y, width, height ) {\n\n\t\tconst scissor = this._tempVec4.set( x, y, width, height );\n\n\t\tif ( this.currentScissor.equals( scissor ) === false ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tthis.currentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies the viewport.\n\t *\n\t * @param {Number} x - The x-coordinate of the lower left corner of the viewport.\n\t * @param {Number} y - The y-coordinate of the lower left corner of the viewport.\n\t * @param {Number} width - The width of the viewport.\n\t * @param {Number} height - The height of the viewport.\n\t *\n\t */\n\tviewport( x, y, width, height ) {\n\n\t\tconst viewport = this._tempVec4.set( x, y, width, height );\n\n\t\tif ( this.currentViewport.equals( viewport ) === false ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tthis.currentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( boolean ) {\n\n\t\t\tgl.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tgl.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether the stencil test is enabled or not.\n\t *\n\t * @param {Boolean} stencilTest - Whether the stencil test is enabled or not.\n\t */\n\tsetStencilTest( stencilTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( stencilTest ) {\n\n\t\t\tthis.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether stencil values can be written when rendering\n\t * into a framebuffer or not.\n\t *\n\t * This method caches the state so `gl.stencilMask()` is only\n\t * called when necessary.\n\t *\n\t * @param {Boolean} stencilMask - The stencil mask.\n\t */\n\tsetStencilMask( stencilMask ) {\n\n\t\tif ( this.currentStencilMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilMask( stencilMask );\n\t\t\tthis.currentStencilMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether the stencil test functions.\n\t *\n\t * This method caches the state so `gl.stencilFunc()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} stencilFunc - The stencil compare function.\n\t * @param {Number} stencilRef - The reference value for the stencil test.\n\t * @param {Number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.\n\t */\n\tsetStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( this.currentStencilFunc !== stencilFunc ||\n\t\t\t this.currentStencilRef !== stencilRef ||\n\t\t\t this.currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\tthis.currentStencilFunc = stencilFunc;\n\t\t\tthis.currentStencilRef = stencilRef;\n\t\t\tthis.currentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether the stencil test operation.\n\t *\n\t * This method caches the state so `gl.stencilOp()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} stencilFail - The function to use when the stencil test fails.\n\t * @param {Number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.\n\t * @param {Number} stencilZPass - The function to use when both the stencil test and the depth test pass,\n\t * or when the stencil test passes and there is no depth buffer or depth testing is disabled.\n\t */\n\tsetStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( this.currentStencilFail !== stencilFail ||\n\t\t\t this.currentStencilZFail !== stencilZFail ||\n\t\t\t this.currentStencilZPass !== stencilZPass ) {\n\n\t\t\tthis.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\tthis.currentStencilFail = stencilFail;\n\t\t\tthis.currentStencilZFail = stencilZFail;\n\t\t\tthis.currentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Configures the WebGL state for the given material.\n\t *\n\t * @param {Material} material - The material to configure the state for.\n\t * @param {Number} frontFaceCW - Whether the front faces are counter-clockwise or not.\n\t * @param {Number} hardwareClippingPlanes - The number of hardware clipping planes.\n\t */\n\tsetMaterial( material, frontFaceCW, hardwareClippingPlanes ) {\n\n\t\tconst { gl } = this;\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? this.disable( gl.CULL_FACE )\n\t\t\t: this.enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tthis.setFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? this.setBlending( NoBlending )\n\t\t\t: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tthis.setDepthFunc( material.depthFunc );\n\t\tthis.setDepthTest( material.depthTest );\n\t\tthis.setDepthMask( material.depthWrite );\n\t\tthis.setColorMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tthis.setStencilTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tthis.setStencilMask( material.stencilWriteMask );\n\t\t\tthis.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tthis.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tthis.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true && this.backend.renderer.samples > 1\n\t\t\t? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tif ( hardwareClippingPlanes > 0 ) {\n\n\t\t\tif ( this.currentClippingPlanes !== hardwareClippingPlanes ) {\n\n\t\t\t\tconst CLIP_DISTANCE0_WEBGL = 0x3000;\n\n\t\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\t\tif ( i < hardwareClippingPlanes ) {\n\n\t\t\t\t\t\tthis.enable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies the polygon offset.\n\t *\n\t * This method caches the state so `gl.polygonOffset()` is only\n\t * called when necessary.\n\t *\n\t * @param {Boolean} polygonOffset - Whether polygon offset is enabled or not.\n\t * @param {Number} factor - The scale factor for the variable depth offset for each polygon.\n\t * @param {Number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.\n\t */\n\tsetPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tthis.currentPolygonOffsetFactor = factor;\n\t\t\t\tthis.currentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines the usage of the given WebGL program.\n\t *\n\t * This method caches the state so `gl.useProgram()` is only\n\t * called when necessary.\n\t *\n\t * @param {WebGLProgram} program - The WebGL program to use.\n\t * @return {Boolean} Whether a program change has been executed or not.\n\t */\n\tuseProgram( program ) {\n\n\t\tif ( this.currentProgram !== program ) {\n\n\t\t\tthis.gl.useProgram( program );\n\n\t\t\tthis.currentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// framebuffer\n\n\n\t/**\n\t * Binds the given framebuffer.\n\t *\n\t * This method caches the state so `gl.bindFramebuffer()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} target - The binding point (target).\n\t * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.\n\t * @return {Boolean} Whether a bind has been executed or not.\n\t */\n\tbindFramebuffer( target, framebuffer ) {\n\n\t\tconst { gl, currentBoundFramebuffers } = this;\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Defines draw buffers to which fragment colors are written into.\n\t * Configures the MRT setup of custom framebuffers.\n\t *\n\t * This method caches the state so `gl.drawBuffers()` is only\n\t * called when necessary.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.\n\t */\n\tdrawBuffers( renderContext, framebuffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet drawBuffers = [];\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tdrawBuffers = this.currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tthis.currentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t}\n\n\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t}\n\n\t}\n\n\n\t// texture\n\n\t/**\n\t * Makes the given texture unit active.\n\t *\n\t * This method caches the state so `gl.activeTexture()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} webglSlot - The texture unit to make active.\n\t */\n\tactiveTexture( webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Binds the given WebGL texture to a target.\n\t *\n\t * This method caches the state so `gl.bindTexture()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} webglType - The binding point (target).\n\t * @param {WebGLTexture} webglTexture - The WebGL texture to bind.\n\t * @param {Number} webglSlot - The texture.\n\t */\n\tbindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Binds a given WebGL buffer to a given binding point (target) at a given index.\n\t *\n\t * This method caches the state so `gl.bindBufferBase()` is only\n\t * called when necessary.\n\t *\n\t * @param {Number} target - The target for the bind operation.\n\t * @param {Number} index - The index of the target.\n\t * @param {WebGLBuffer} buffer - The WebGL buffer.\n\t * @return {Boolean} Whether a bind has been executed or not.\n\t */\n\tbindBufferBase( target, index, buffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst key = `${target}-${index}`;\n\n\t\tif ( this.currentBoundBufferBases[ key ] !== buffer ) {\n\n\t\t\tgl.bindBufferBase( target, index, buffer );\n\t\t\tthis.currentBoundBufferBases[ key ] = buffer;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\t/**\n\t * Unbinds the current bound texture.\n\t *\n\t * This method caches the state so `gl.bindTexture()` is only\n\t * called when necessary.\n\t */\n\tunbindTexture() {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures } = this;\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * A WebGL 2 backend utility module with common helpers.\n *\n * @private\n */\nclass WebGLUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext}\n\t\t */\n\t\tthis.gl = this.backend.gl;\n\n\t\t/**\n\t\t * A reference to a backend module holding extension-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLExtensions}\n\t\t */\n\t\tthis.extensions = backend.extensions;\n\n\t}\n\n\t/**\n\t * Converts the given three.js constant into a WebGL constant.\n\t * The method currently supports the conversion of texture formats\n\t * and types.\n\t *\n\t * @param {Number} p - The three.js constant.\n\t * @param {String} [colorSpace=NoColorSpace] - The color space.\n\t * @return {Number} The corresponding WebGL constant.\n\t */\n\tconvert( p, colorSpace = NoColorSpace ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tlet extension;\n\n\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;\n\n\t\tif ( p === ByteType ) return gl.BYTE;\n\t\tif ( p === ShortType ) return gl.SHORT;\n\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === IntType ) return gl.INT;\n\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === FloatType ) return gl.FLOAT;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\treturn gl.HALF_FLOAT;\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedFormat ) return gl.RED;\n\t\tif ( p === RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === RGFormat ) return gl.RG;\n\t\tif ( p === RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( colorSpace === SRGBColorSpace ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC\n\n\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === RGBA_BPTC_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\treturn gl.UNSIGNED_INT_24_8;\n\n\t\t}\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\t/**\n\t * This method can be used to synchronize the CPU with the GPU by waiting until\n\t * ongoing GPU commands have been completed.\n\t *\n\t * @private\n\t * @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.\n\t */\n\t_clientWaitAsync() {\n\n\t\tconst { gl } = this;\n\n\t\tconst sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );\n\n\t\tgl.flush();\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tfunction test() {\n\n\t\t\t\tconst res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );\n\n\t\t\t\tif ( res === gl.WAIT_FAILED ) {\n\n\t\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\t\treject();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( res === gl.TIMEOUT_EXPIRED ) {\n\n\t\t\t\t\trequestAnimationFrame( test );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t\ttest();\n\n\t\t} );\n\n\t}\n\n}\n\nlet initialized = false, wrappingToGL, filterToGL, compareToGL;\n\n/**\n * A WebGL 2 backend utility module for managing textures.\n *\n * @private\n */\nclass WebGLTextureUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext}\n\t\t */\n\t\tthis.gl = backend.gl;\n\n\t\t/**\n\t\t * A reference to a backend module holding extension-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLExtensions}\n\t\t */\n\t\tthis.extensions = backend.extensions;\n\n\t\t/**\n\t\t * A dictionary for managing default textures. The key\n\t\t * is the binding point (target), the value the WEbGL texture object.\n\t\t *\n\t\t * @type {Object<GLenum,WebGLTexture>}\n\t\t */\n\t\tthis.defaultTextures = {};\n\n\t\tif ( initialized === false ) {\n\n\t\t\tthis._init();\n\n\t\t\tinitialized = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inits the state of the utility.\n\t *\n\t * @private\n\t */\n\t_init() {\n\n\t\tconst gl = this.gl;\n\n\t\t// Store only WebGL constants here.\n\n\t\twrappingToGL = {\n\t\t\t[ RepeatWrapping ]: gl.REPEAT,\n\t\t\t[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,\n\t\t\t[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT\n\t\t};\n\n\t\tfilterToGL = {\n\t\t\t[ NearestFilter ]: gl.NEAREST,\n\t\t\t[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,\n\t\t\t[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t\t[ LinearFilter ]: gl.LINEAR,\n\t\t\t[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,\n\t\t\t[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR\n\t\t};\n\n\t\tcompareToGL = {\n\t\t\t[ NeverCompare ]: gl.NEVER,\n\t\t\t[ AlwaysCompare ]: gl.ALWAYS,\n\t\t\t[ LessCompare ]: gl.LESS,\n\t\t\t[ LessEqualCompare ]: gl.LEQUAL,\n\t\t\t[ EqualCompare ]: gl.EQUAL,\n\t\t\t[ GreaterEqualCompare ]: gl.GEQUAL,\n\t\t\t[ GreaterCompare ]: gl.GREATER,\n\t\t\t[ NotEqualCompare ]: gl.NOTEQUAL\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns the native texture type for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {GLenum} The native texture type.\n\t */\n\tgetGLTextureType( texture ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet glTextureType;\n\n\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_CUBE_MAP;\n\n\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_2D_ARRAY;\n\n\t\t} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642\n\n\t\t\tglTextureType = gl.TEXTURE_3D;\n\n\t\t} else {\n\n\t\t\tglTextureType = gl.TEXTURE_2D;\n\n\n\t\t}\n\n\t\treturn glTextureType;\n\n\t}\n\n\t/**\n\t * Returns the native texture type for the given texture.\n\t *\n\t * @param {String?} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.\n\t * @param {GLenum} glFormat - The WebGL format.\n\t * @param {GLenum} glType - The WebGL type.\n\t * @param {String} colorSpace - The texture's color space.\n\t * @param {Boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.\n\t * @return {GLenum} The internal format.\n\t */\n\tgetInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === gl.RED ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.R32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RED_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RG32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8 : gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;\n\t\t\tif ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_COMPONENT ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.DEPTH_COMPONENT16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH_COMPONENT24;\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_STENCIL ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;\n\n\t\t}\n\n\t\tif ( internalFormat === gl.R16F || internalFormat === gl.R32F ||\n\t\t\tinternalFormat === gl.RG16F || internalFormat === gl.RG32F ||\n\t\t\tinternalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\t/**\n\t * Sets the texture parameters for the given texture.\n\t *\n\t * @param {GLenum} textureType - The texture type.\n\t * @param {Texture} texture - The texture.\n\t */\n\tsetTextureParameters( textureType, texture ) {\n\n\t\tconst { gl, extensions, backend } = this;\n\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE );\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\tif ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t}\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\n\n\t\tconst hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;\n\n\t\t// follow WebGPU backend mapping for texture filtering\n\t\tconst minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tif ( texture.magFilter === NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2\n\n\t\t\tif ( texture.anisotropy > 1 ) {\n\n\t\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\t\t\tgl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tconst { gl, backend, defaultTextures } = this;\n\n\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tlet textureGPU = defaultTextures[ glTextureType ];\n\n\t\tif ( textureGPU === undefined ) {\n\n\t\t\ttextureGPU = gl.createTexture();\n\n\t\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\t// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\tdefaultTextures[ glTextureType ] = textureGPU;\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tisDefault: true\n\t\t} );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t * @return {undefined}\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { levels, width, height, depth } = options;\n\n\t\tconst glFormat = backend.utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = backend.utils.convert( texture.type );\n\t\tconst glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );\n\n\t\tconst textureGPU = gl.createTexture();\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( ! texture.isVideoTexture ) {\n\n\t\t\tgl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tglFormat,\n\t\t\tglType,\n\t\t\tglInternalFormat\n\t\t} );\n\n\t}\n\n\t/**\n\t * Uploads texture buffer data to the GPU memory.\n\t *\n\t * @param {WebGLBuffer} buffer - The buffer data.\n\t * @param {Texture} texture - The texture,\n\t */\n\tcopyBufferToTexture( buffer, texture ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\tconst { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );\n\n\t\tconst { width, height } = texture.source.data;\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );\n\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );\n\n\t\tbackend.state.unbindTexture();\n\t\t// debug\n\t\t// const framebuffer = gl.createFramebuffer();\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n\t\t// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );\n\n\t\t// const readout = new Float32Array( width * height * 4 );\n\n\t\t// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );\n\t\t// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );\n\n\t\t// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\t// console.log( readout );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tconst { gl } = this;\n\t\tconst { width, height } = options;\n\t\tconst { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );\n\n\t\tif ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\tconst getImage = ( source ) => {\n\n\t\t\tif ( source.isDataTexture ) {\n\n\t\t\t\treturn source.image.data;\n\n\t\t\t} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||\n\t\t\t\tsource instanceof OffscreenCanvas ) {\n\n\t\t\t\treturn source;\n\n\t\t\t}\n\n\t\t\treturn source.data;\n\n\t\t};\n\n\t\tthis.backend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tconst mipmaps = texture.mipmaps;\n\t\t\tconst image = options.image;\n\n\t\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\n\t\t\t\t\tif ( texture.format !== gl.RGBA ) {\n\n\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\tgl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'Unsupported compressed texture format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tconst images = options.images;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tconst image = getImage( images[ i ] );\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t} else if ( texture.isDataArrayTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\ttexture.update();\n\n\t\t\tgl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );\n\n\n\t\t} else {\n\n\t\t\tconst image = getImage( options.image );\n\n\t\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, glTextureType } = backend.get( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\tgl.generateMipmap( glTextureType );\n\n\t}\n\n\t/**\n\t * Deallocates the render buffers of the given render target.\n\t *\n\t * @param {RenderTarget} renderTarget - The render target.\n\t */\n\tdeallocateRenderBuffers( renderTarget ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\t// remove framebuffer reference\n\t\tif ( renderTarget ) {\n\n\t\t\tconst renderContextData = backend.get( renderTarget );\n\n\t\t\trenderContextData.renderBufferStorageSetup = undefined;\n\n\t\t\tif ( renderContextData.framebuffers ) {\n\n\t\t\t\tfor ( const cacheKey in renderContextData.framebuffers ) {\n\n\t\t\t\t\tgl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.framebuffers;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.depthRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.depthRenderbuffer );\n\t\t\t\tdelete renderContextData.depthRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.stencilRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );\n\t\t\t\tdelete renderContextData.stencilRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaFrameBuffer ) {\n\n\t\t\t\tgl.deleteFramebuffer( renderContextData.msaaFrameBuffer );\n\t\t\t\tdelete renderContextData.msaaFrameBuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaRenderbuffers ) {\n\n\t\t\t\tfor ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {\n\n\t\t\t\t\tgl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.msaaRenderbuffers;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, renderTarget } = backend.get( texture );\n\n\t\tthis.deallocateRenderBuffers( renderTarget );\n\t\tgl.deleteTexture( textureGPU );\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n\t * @param {Number} [level=0] - The mip level to copy.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );\n\n\t\tlet width, height, minX, minY;\n\t\tlet dstX, dstY;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\tminX = srcRegion.min.x;\n\t\t\tminY = srcRegion.min.y;\n\n\t\t} else {\n\n\t\t\twidth = srcTexture.image.width;\n\t\t\theight = srcTexture.image.height;\n\t\t\tminX = 0;\n\t\t\tminY = 0;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\n\t\t} else {\n\n\t\t\tdstX = 0;\n\t\t\tdstY = 0;\n\n\t\t}\n\n\t\tstate.bindTexture( glTextureType, dstTextureGPU );\n\n\t\t// As another texture upload may have changed pixelStorei\n\t\t// parameters, make sure they are correct for the dstTexture\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\tconst currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );\n\t\tconst currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );\n\t\tconst currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );\n\t\tconst currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );\n\t\tconst currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );\n\n\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );\n\n\t\tif ( srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture ) {\n\n\t\t\tconst srcTextureData = backend.get( srcTexture );\n\t\t\tconst dstTextureData = backend.get( dstTexture );\n\n\t\t\tconst srcRenderContextData = backend.get( srcTextureData.renderTarget );\n\t\t\tconst dstRenderContextData = backend.get( dstTextureData.renderTarget );\n\n\t\t\tconst srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];\n\t\t\tconst dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );\n\n\t\t\tlet mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\tif ( srcTexture.isDepthTexture ) mask = gl.DEPTH_BUFFER_BIT;\n\n\t\t\tgl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST );\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) gl.generateMipmap( gl.TEXTURE_2D );\n\n\t\tstate.unbindTexture();\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst { gl } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU } = this.backend.get( texture );\n\n\t\tconst { x, y, z: width, w: height } = rectangle;\n\n\t\tconst requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );\n\n\t\tconst srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;\n\n\t\tif ( requireDrawFrameBuffer ) {\n\n\t\t\tconst partial = ( x !== 0 || y !== 0 );\n\t\t\tlet mask;\n\t\t\tlet attachment;\n\n\t\t\tif ( texture.isDepthTexture === true ) {\n\n\t\t\t\tmask = gl.DEPTH_BUFFER_BIT;\n\t\t\t\tattachment = gl.DEPTH_ATTACHMENT;\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tmask |= gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmask = gl.COLOR_BUFFER_BIT;\n\t\t\t\tattachment = gl.COLOR_ATTACHMENT0;\n\n\t\t\t}\n\n\t\t\tif ( partial ) {\n\n\t\t\t\tconst renderTargetContextData = this.backend.get( renderContext.renderTarget );\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\n\t\t\t\tconst flippedY = srcHeight - y - height;\n\n\t\t\t\tgl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\n\t\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );\n\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t} else {\n\n\t\t\t\tconst fb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );\n\t\t\t\tgl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );\n\n\t\t\t\tgl.deleteFramebuffer( fb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps ) this.generateMipmaps( texture );\n\n\t\tthis.backend._setFramebuffer( renderContext );\n\n\t}\n\n\t/**\n\t * SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.\n\t *\n\t * @param {WebGLRenderbuffer} renderbuffer - The render buffer.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Number} samples - The MSAA sample count.\n\t * @param {Boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.\n\t */\n\tsetupRenderBufferStorage( renderbuffer, renderContext, samples, useMultisampledRTT = false ) {\n\n\t\tconst { gl } = this;\n\t\tconst renderTarget = renderContext.renderTarget;\n\n\t\tconst { depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;\n\n\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( depthBuffer && ! stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = gl.DEPTH_COMPONENT24;\n\n\t\t\tif ( useMultisampledRTT === true ) {\n\n\t\t\t\tconst multisampledRTTExt = this.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\n\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( gl.RENDERBUFFER, renderTarget.samples, glInternalFormat, width, height );\n\n\t\t\t} else if ( samples > 0 ) {\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === gl.FLOAT ) {\n\n\t\t\t\t\t\tglInternalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );\n\n\t\t\t}\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( depthBuffer && stencilBuffer ) {\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );\n\n\t\t\t}\n\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {Number} x - The x coordinate of the copy origin.\n\t * @param {Number} y - The y coordinate of the copy origin.\n\t * @param {Number} width - The width of the copy.\n\t * @param {Number} height - The height of the copy.\n\t * @param {Number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst { backend, gl } = this;\n\n\t\tconst { textureGPU, glFormat, glType } = this.backend.get( texture );\n\n\t\tconst fb = gl.createFramebuffer();\n\n\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\tconst target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;\n\n\t\tgl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );\n\n\t\tconst typedArrayType = this._getTypedArrayType( glType );\n\t\tconst bytesPerTexel = this._getBytesPerTexel( glType, glFormat );\n\n\t\tconst elementCount = width * height;\n\t\tconst byteLength = elementCount * bytesPerTexel;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );\n\t\tgl.readPixels( x, y, width, height, glFormat, glType, 0 );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tgl.deleteFramebuffer( fb );\n\n\t\treturn dstBuffer;\n\n\t}\n\n\t/**\n\t * Returns the corresponding typed array type for the given WebGL data type.\n\t *\n\t * @private\n\t * @param {GLenum} glType - The WebGL data type.\n\t * @return {TypedArray.constructor} The typed array type.\n\t */\n\t_getTypedArrayType( glType ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_INT ) return Uint32Array;\n\n\t\tif ( glType === gl.HALF_FLOAT ) return Uint16Array;\n\t\tif ( glType === gl.FLOAT ) return Float32Array;\n\n\t\tthrow new Error( `Unsupported WebGL type: ${glType}` );\n\n\t}\n\n\t/**\n\t * Returns the bytes-per-texel value for the given WebGL data type and texture format.\n\t *\n\t * @private\n\t * @param {GLenum} glType - The WebGL data type.\n\t * @param {GLenum} glFormat - The WebGL texture format.\n\t * @return {Number} The bytes-per-texel.\n\t */\n\t_getBytesPerTexel( glType, glFormat ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet bytesPerComponent = 0;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_5_5_1 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_6_5 ||\n\t\t\tglType === gl.UNSIGNED_SHORT ||\n\t\t\tglType === gl.HALF_FLOAT ) bytesPerComponent = 2;\n\n\t\tif ( glType === gl.UNSIGNED_INT ||\n\t\t\tglType === gl.FLOAT ) bytesPerComponent = 4;\n\n\t\tif ( glFormat === gl.RGBA ) return bytesPerComponent * 4;\n\t\tif ( glFormat === gl.RGB ) return bytesPerComponent * 3;\n\t\tif ( glFormat === gl.ALPHA ) return bytesPerComponent;\n\n\t}\n\n}\n\n/**\n * A WebGL 2 backend utility module for managing extensions.\n *\n * @private\n */\nclass WebGLExtensions {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext}\n\t\t */\n\t\tthis.gl = this.backend.gl;\n\n\t\t/**\n\t\t * A list with all the supported WebGL extensions.\n\t\t *\n\t\t * @type {Array<String>}\n\t\t */\n\t\tthis.availableExtensions = this.gl.getSupportedExtensions();\n\n\t\t/**\n\t\t * A dictionary with requested WebGL extensions.\n\t\t * The key is the name of the extension, the value\n\t\t * the requested extension object.\n\t\t *\n\t\t * @type {Object<String,Object>}\n\t\t */\n\t\tthis.extensions = {};\n\n\t}\n\n\t/**\n\t * Returns the extension object for the given extension name.\n\t *\n\t * @param {String} name - The extension name.\n\t * @return {Object} The extension object.\n\t */\n\tget( name ) {\n\n\t\tlet extension = this.extensions[ name ];\n\n\t\tif ( extension === undefined ) {\n\n\t\t\textension = this.gl.getExtension( name );\n\n\t\t\tthis.extensions[ name ] = extension;\n\n\t\t}\n\n\t\treturn extension;\n\n\t}\n\n\t/**\n\t * Returns `true` if the requested extension is available.\n\t *\n\t * @param {String} name - The extension name.\n\t * @return {Boolean} Whether the given extension is available or not.\n\t */\n\thas( name ) {\n\n\t\treturn this.availableExtensions.includes( name );\n\n\t}\n\n}\n\n/**\n * A WebGL 2 backend utility module for managing the device's capabilities.\n *\n * @private\n */\nclass WebGLCapabilities {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * This value holds the cached max anisotropy value.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.maxAnisotropy = null;\n\n\t}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value. This value\n\t * depends on the device and is reported by the `EXT_texture_filter_anisotropic`\n\t * WebGL extension.\n\t *\n\t * @return {Number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\tif ( this.maxAnisotropy !== null ) return this.maxAnisotropy;\n\n\t\tconst gl = this.backend.gl;\n\t\tconst extensions = this.backend.extensions;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tthis.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tthis.maxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn this.maxAnisotropy;\n\n\t}\n\n}\n\nconst GLFeatureName = {\n\n\t'WEBGL_multi_draw': 'WEBGL_multi_draw',\n\t'WEBGL_compressed_texture_astc': 'texture-compression-astc',\n\t'WEBGL_compressed_texture_etc': 'texture-compression-etc2',\n\t'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',\n\t'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',\n\t'EXT_texture_compression_bptc': 'texture-compression-bptc',\n\t'EXT_disjoint_timer_query_webgl2': 'timestamp-query',\n\n};\n\nclass WebGLBufferRenderer {\n\n\tconstructor( backend ) {\n\n\t\tthis.gl = backend.gl;\n\t\tthis.extensions = backend.extensions;\n\t\tthis.info = backend.renderer.info;\n\t\tthis.mode = null;\n\t\tthis.index = 0;\n\t\tthis.type = null;\n\t\tthis.object = null;\n\n\t}\n\n\trender( start, count ) {\n\n\t\tconst { gl, mode, object, type, info, index } = this;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElements( mode, count, type, start );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t}\n\n\t\tinfo.update( object, count, mode, 1 );\n\n\t}\n\n\trenderInstances( start, count, primcount ) {\n\n\t\tconst { gl, mode, type, index, object, info } = this;\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElementsInstanced( mode, count, type, start, primcount );\n\n\t\t} else {\n\n\t\t\tgl.drawArraysInstanced( mode, start, count, primcount );\n\n\t\t}\n\n\t\tinfo.update( object, count, mode, primcount );\n\n\t}\n\n\trenderMultiDraw( starts, counts, drawCount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ], counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\trenderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ] * primcount[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\t//\n\n}\n\nclass TimestampQueryPool {\n\n\tconstructor( maxQueries = 256 ) {\n\n\t\tthis.trackTimestamp = true;\n\t\tthis.maxQueries = maxQueries;\n\t\tthis.currentQueryIndex = 0; // how many queries allocated so far\n\t\tthis.queryOffsets = new Map(); // track offsets for different contexts\n\t\tthis.isDisposed = false;\n\t\tthis.lastValue = 0;\n\t\tthis.pendingResolve = false;\n\n\t}\n\n\t/**\n     * Allocate queries for a specific renderContext.\n\t *\n\t * @abstract\n     */\n\tallocateQueriesForContext( /* renderContext */ ) {}\n\n\t/**\n     * Resolve all timestamps and return data (or process them).\n\t *\n\t * @abstract\n\t * @returns {Promise<Number>|Number} The resolved timestamp value.\n     */\n\tasync resolveQueriesAsync() {}\n\n\t/**\n\t * Dispose of the query pool.\n\t *\n\t * @abstract\n\t */\n\tdispose() {}\n\n}\n\n/**\n * Manages a pool of WebGL timestamp queries for performance measurement.\n * Handles creation, execution, and resolution of timer queries using WebGL extensions.\n * @extends TimestampQueryPool\n */\nclass WebGLTimestampQueryPool extends TimestampQueryPool {\n\n\t/**\n     * Creates a new WebGL timestamp query pool.\n     * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.\n     * @param {string} type - The type identifier for this query pool.\n     * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.\n     */\n\tconstructor( gl, type, maxQueries = 2048 ) {\n\n\t\tsuper( maxQueries );\n\n\t\tthis.gl = gl;\n\t\tthis.type = type;\n\n\t\t// Check for timer query extensions\n\t\tthis.ext = gl.getExtension( 'EXT_disjoint_timer_query_webgl2' ) ||\n                  gl.getExtension( 'EXT_disjoint_timer_query' );\n\n\t\tif ( ! this.ext ) {\n\n\t\t\tconsole.warn( 'EXT_disjoint_timer_query not supported; timestamps will be disabled.' );\n\t\t\tthis.trackTimestamp = false;\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Create query objects\n\t\tthis.queries = [];\n\t\tfor ( let i = 0; i < this.maxQueries; i ++ ) {\n\n\t\t\tthis.queries.push( gl.createQuery() );\n\n\t\t}\n\n\t\tthis.activeQuery = null;\n\t\tthis.queryStates = new Map(); // Track state of each query: 'inactive', 'started', 'ended'\n\n\t}\n\n\t/**\n     * Allocates a pair of queries for a given render context.\n     * @param {Object} renderContext - The render context to allocate queries for.\n     * @returns {?number} The base offset for the allocated queries, or null if allocation failed.\n     */\n\tallocateQueriesForContext( renderContext ) {\n\n\t\tif ( ! this.trackTimestamp ) return null;\n\n\t\t// Check if we have enough space for a new query pair\n\t\tif ( this.currentQueryIndex + 2 > this.maxQueries ) {\n\n\t\t\twarnOnce( `WebGPUTimestampQueryPool [${ this.type }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${ this.type.toUpperCase() } ).` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst baseOffset = this.currentQueryIndex;\n\t\tthis.currentQueryIndex += 2;\n\n\t\t// Initialize query states\n\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\t\tthis.queryOffsets.set( renderContext.id, baseOffset );\n\n\t\treturn baseOffset;\n\n\t}\n\n\t/**\n     * Begins a timestamp query for the specified render context.\n     * @param {Object} renderContext - The render context to begin timing for.\n     */\n\tbeginQuery( renderContext ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst baseOffset = this.queryOffsets.get( renderContext.id );\n\t\tif ( baseOffset == null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Don't start a new query if there's an active one\n\t\tif ( this.activeQuery !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst query = this.queries[ baseOffset ];\n\t\tif ( ! query ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Only begin if query is inactive\n\t\t\tif ( this.queryStates.get( baseOffset ) === 'inactive' ) {\n\n\t\t\t\tthis.gl.beginQuery( this.ext.TIME_ELAPSED_EXT, query );\n\t\t\t\tthis.activeQuery = baseOffset;\n\t\t\t\tthis.queryStates.set( baseOffset, 'started' );\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'Error in beginQuery:', error );\n\t\t\tthis.activeQuery = null;\n\t\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\n\t\t}\n\n\t}\n\n\t/**\n     * Ends the active timestamp query for the specified render context.\n     * @param {Object} renderContext - The render context to end timing for.\n     * @param {string} renderContext.id - Unique identifier for the render context.\n     */\n\tendQuery( renderContext ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst baseOffset = this.queryOffsets.get( renderContext.id );\n\t\tif ( baseOffset == null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Only end if this is the active query\n\t\tif ( this.activeQuery !== baseOffset ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tthis.gl.endQuery( this.ext.TIME_ELAPSED_EXT );\n\t\t\tthis.queryStates.set( baseOffset, 'ended' );\n\t\t\tthis.activeQuery = null;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'Error in endQuery:', error );\n\t\t\t// Reset state on error\n\t\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\t\t\tthis.activeQuery = null;\n\n\t\t}\n\n\t}\n\n\t/**\n     * Asynchronously resolves all completed queries and returns the total duration.\n     * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.\n     */\n\tasync resolveQueriesAsync() {\n\n\t\tif ( ! this.trackTimestamp || this.pendingResolve ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\tthis.pendingResolve = true;\n\n\t\ttry {\n\n\t\t\t// Wait for all ended queries to complete\n\t\t\tconst resolvePromises = [];\n\n\t\t\tfor ( const [ baseOffset, state ] of this.queryStates ) {\n\n\t\t\t\tif ( state === 'ended' ) {\n\n\t\t\t\t\tconst query = this.queries[ baseOffset ];\n\t\t\t\t\tresolvePromises.push( this.resolveQuery( query ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( resolvePromises.length === 0 ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\tconst results = await Promise.all( resolvePromises );\n\t\t\tconst totalDuration = results.reduce( ( acc, val ) => acc + val, 0 );\n\n\t\t\t// Store the last valid result\n\t\t\tthis.lastValue = totalDuration;\n\n\t\t\t// Reset states\n\t\t\tthis.currentQueryIndex = 0;\n\t\t\tthis.queryOffsets.clear();\n\t\t\tthis.queryStates.clear();\n\t\t\tthis.activeQuery = null;\n\n\t\t\treturn totalDuration;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'Error resolving queries:', error );\n\t\t\treturn this.lastValue;\n\n\t\t} finally {\n\n\t\t\tthis.pendingResolve = false;\n\n\t\t}\n\n\t}\n\n\t/**\n     * Resolves a single query, checking for completion and disjoint operation.\n     * @private\n     * @param {WebGLQuery} query - The query object to resolve.\n     * @returns {Promise<number>} The elapsed time in milliseconds.\n     */\n\tasync resolveQuery( query ) {\n\n\t\treturn new Promise( ( resolve ) => {\n\n\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\tresolve( this.lastValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet timeoutId;\n\t\t\tlet isResolved = false;\n\n\t\t\tconst cleanup = () => {\n\n\t\t\t\tif ( timeoutId ) {\n\n\t\t\t\t\tclearTimeout( timeoutId );\n\t\t\t\t\ttimeoutId = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst finalizeResolution = ( value ) => {\n\n\t\t\t\tif ( ! isResolved ) {\n\n\t\t\t\t\tisResolved = true;\n\t\t\t\t\tcleanup();\n\t\t\t\t\tresolve( value );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst checkQuery = () => {\n\n\t\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\t\tfinalizeResolution( this.lastValue );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Check if the GPU timer was disjoint (i.e., timing was unreliable)\n\t\t\t\t\tconst disjoint = this.gl.getParameter( this.ext.GPU_DISJOINT_EXT );\n\t\t\t\t\tif ( disjoint ) {\n\n\t\t\t\t\t\tfinalizeResolution( this.lastValue );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst available = this.gl.getQueryParameter( query, this.gl.QUERY_RESULT_AVAILABLE );\n\t\t\t\t\tif ( ! available ) {\n\n\t\t\t\t\t\ttimeoutId = setTimeout( checkQuery, 1 );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst elapsed = this.gl.getQueryParameter( query, this.gl.QUERY_RESULT );\n\t\t\t\t\tresolve( Number( elapsed ) / 1e6 ); // Convert nanoseconds to milliseconds\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tconsole.error( 'Error checking query:', error );\n\t\t\t\t\tresolve( this.lastValue );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheckQuery();\n\n\t\t} );\n\n\t}\n\n\t/**\n     * Releases all resources held by this query pool.\n     * This includes deleting all query objects and clearing internal state.\n     */\n\tdispose() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.isDisposed = true;\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tfor ( const query of this.queries ) {\n\n\t\t\tthis.gl.deleteQuery( query );\n\n\t\t}\n\n\t\tthis.queries = [];\n\t\tthis.queryStates.clear();\n\t\tthis.queryOffsets.clear();\n\t\tthis.lastValue = 0;\n\t\tthis.activeQuery = null;\n\n\t}\n\n}\n\n/**\n * A backend implementation targeting WebGL 2.\n *\n * @private\n * @augments Backend\n */\nclass WebGLBackend extends Backend {\n\n\t/**\n\t * Constructs a new WebGPU backend.\n\t *\n\t * @param {Object} parameters - The configuration parameter.\n\t * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @param {WebGL2RenderingContext} [parameters.context=undefined] - A WebGL 2 rendering context.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGLBackend = true;\n\n\t\t/**\n\t\t * A reference to a backend module holding shader attribute-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLAttributeUtils?}\n\t\t * @default null\n\t\t */\n\t\tthis.attributeUtils = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding extension-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLExtensions?}\n\t\t * @default null\n\t\t */\n\t\tthis.extensions = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding capability-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLCapabilities?}\n\t\t * @default null\n\t\t */\n\t\tthis.capabilities = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding texture-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLTextureUtils?}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding renderer-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLBufferRenderer?}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferRenderer = null;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext?}\n\t\t * @default null\n\t\t */\n\t\tthis.gl = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding state-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLState?}\n\t\t * @default null\n\t\t */\n\t\tthis.state = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding common\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLUtils?}\n\t\t * @default null\n\t\t */\n\t\tthis.utils = null;\n\n\t\t/**\n\t\t * Dictionary for caching VAOs.\n\t\t *\n\t\t * @type {Object<String,WebGLVertexArrayObject>}\n\t\t */\n\t\tthis.vaoCache = {};\n\n\t\t/**\n\t\t * Dictionary for caching transform feedback objects.\n\t\t *\n\t\t * @type {Object<String,WebGLTransformFeedback>}\n\t\t */\n\t\tthis.transformFeedbackCache = {};\n\n\t\t/**\n\t\t * Controls if `gl.RASTERIZER_DISCARD` should be enabled or not.\n\t\t * Only relevant when using compute shaders.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.discard = false;\n\n\t\t/**\n\t\t * A reference to the `EXT_disjoint_timer_query_webgl2` extension. `null` if the\n\t\t * device does not support the extension.\n\t\t *\n\t\t * @type {EXTDisjointTimerQueryWebGL2?}\n\t\t * @default null\n\t\t */\n\t\tthis.disjoint = null;\n\n\t\t/**\n\t\t* A reference to the `KHR_parallel_shader_compile` extension. `null` if the\n\t\t* device does not support the extension.\n\t\t*\n\t\t* @type {KHRParallelShaderCompile?}\n\t\t* @default null\n\t\t*/\n\t\tthis.parallel = null;\n\n\t\t/**\n\t\t * Whether to track timestamps with a Timestamp Query API or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t\t/**\n\t\t * A reference to the current render context.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderContext}\n\t\t * @default null\n\t\t */\n\t\tthis._currentContext = null;\n\n\t\t/**\n\t\t * A unique collection of bindings.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakSet}\n\t\t */\n\t\tthis._knownBindings = new WeakSet();\n\n\t\t/**\n\t\t * The target framebuffer when rendering with\n\t\t * the WebXR device API.\n\t\t *\n\t\t * @private\n\t\t * @type {WebGLFramebuffer}\n\t\t * @default null\n\t\t */\n\t\tthis._xrFamebuffer = null;\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tinit( renderer ) {\n\n\t\tsuper.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\tconst contextAttributes = {\n\t\t\tantialias: false, // MSAA is applied via a custom renderbuffer\n\t\t\talpha: true, // always true for performance reasons\n\t\t\tdepth: false, // depth and stencil are set to false since the engine always renders into a framebuffer target first\n\t\t\tstencil: false\n\t\t};\n\n\t\tconst glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2', contextAttributes );\n\n\t \tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconst contextLossInfo = {\n\t\t\t\tapi: 'WebGL',\n\t\t\t\tmessage: event.statusMessage || 'Unknown reason',\n\t\t\t\treason: null,\n\t\t\t\toriginalEvent: event\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( contextLossInfo );\n\n\t\t}\n\n\t\tthis._onContextLost = onContextLost;\n\n\t\trenderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\tthis.gl = glContext;\n\n\t\tthis.extensions = new WebGLExtensions( this );\n\t\tthis.capabilities = new WebGLCapabilities( this );\n\t\tthis.attributeUtils = new WebGLAttributeUtils( this );\n\t\tthis.textureUtils = new WebGLTextureUtils( this );\n\t\tthis.bufferRenderer = new WebGLBufferRenderer( this );\n\n\t\tthis.state = new WebGLState( this );\n\t\tthis.utils = new WebGLUtils( this );\n\n\t\tthis.extensions.get( 'EXT_color_buffer_float' );\n\t\tthis.extensions.get( 'WEBGL_clip_cull_distance' );\n\t\tthis.extensions.get( 'OES_texture_float_linear' );\n\t\tthis.extensions.get( 'EXT_color_buffer_half_float' );\n\t\tthis.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\tthis.extensions.get( 'WEBGL_render_shared_exponent' );\n\t\tthis.extensions.get( 'WEBGL_multi_draw' );\n\n\t\tthis.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );\n\t\tthis.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.utils._clientWaitAsync();\n\n\t}\n\n\t/**\n\t * Ensures the backend is XR compatible.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolve when the renderer is XR compatible.\n\t */\n\tasync makeXRCompatible() {\n\n\t\tconst attributes = this.gl.getContextAttributes();\n\n\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\tawait this.gl.makeXRCompatible();\n\n\t\t}\n\n\t}\n\t/**\n\t * Sets the XR rendering destination.\n\t *\n\t * @param {WebGLFramebuffer} xrFamebuffer - The XR framebuffer.\n\t */\n\tsetXRTarget( xrFamebuffer ) {\n\n\t\tthis._xrFamebuffer = xrFamebuffer;\n\n\t}\n\n\t/**\n\t * Configures the given XR render target with external textures.\n\t *\n\t * This method is only relevant when using the WebXR Layers API.\n\t *\n\t * @param {XRRenderTarget} renderTarget - The XR render target.\n\t * @param {WebGLTexture} colorTexture - A native color texture.\n\t * @param {WebGLTexture?} [depthTexture=null] - A native depth texture.\n\t */\n\tsetXRRenderTargetTextures( renderTarget, colorTexture, depthTexture = null ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.set( renderTarget.texture, { textureGPU: colorTexture, glInternalFormat: gl.RGBA8 } ); // see #24698 why RGBA8 and not SRGB8_ALPHA8 is used\n\n\t\tif ( depthTexture !== null ) {\n\n\t\t\tconst glInternalFormat = renderTarget.stencilBuffer ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\n\t\t\tthis.set( renderTarget.depthTexture, { textureGPU: depthTexture, glInternalFormat: glInternalFormat } );\n\n\t\t\trenderTarget.autoAllocateDepthBuffer = false;\n\n\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t// are midframe flushes and an external depth texture.\n\t\t\tif ( this.extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inits a time stamp query for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tinitTimestampQuery( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\n\t\tif ( ! this.timestampQueryPool[ type ] ) {\n\n\t\t\t// TODO: Variable maxQueries?\n\t\t\tthis.timestampQueryPool[ type ] = new WebGLTimestampQueryPool( this.gl, type, 2048 );\n\n\t\t}\n\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\tconst baseOffset = timestampQueryPool.allocateQueriesForContext( renderContext );\n\n\t\tif ( baseOffset !== null ) {\n\n\t\t\ttimestampQueryPool.beginQuery( renderContext );\n\n\t\t}\n\n\t}\n\n\t// timestamp utils\n\n\t/**\n\t * Prepares the timestamp buffer.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tprepareTimestampBuffer( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\ttimestampQueryPool.endQuery( renderContext );\n\n\t}\n\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @return {WebGL2RenderingContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.gl;\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a render call and prepares\n\t * the WebGL state for upcoming render calls\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( renderContext ) {\n\n\t\tconst { state, gl } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t//\n\n\t\t//\n\n\t\tthis.initTimestampQuery( renderContext );\n\n\t\trenderContextData.previousContext = this._currentContext;\n\t\tthis._currentContext = renderContext;\n\n\t\tthis._setFramebuffer( renderContext );\n\n\t\tthis.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );\n\n\t\t//\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t} else {\n\n\t\t\tstate.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tstate.scissor( x, renderContext.height - height - y, width, height );\n\n\t\t}\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the async reading of all previous queries complete\n\t\t\trenderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\t\t\trenderContextData.occlusionQueries = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a render call and finalizes work\n\t * after draw calls.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( renderContext ) {\n\n\t\tconst { gl, state } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst previousContext = renderContextData.previousContext;\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t}\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tconst textures = renderContext.textures;\n\n\t\tif ( textures !== null ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps ) {\n\n\t\t\t\t\tthis.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._currentContext = previousContext;\n\n\t\tif ( renderContext.textures !== null && renderContext.renderTarget ) {\n\n\t\t\tconst renderTargetContextData = this.get( renderContext.renderTarget );\n\n\t\t\tconst { samples } = renderContext.renderTarget;\n\n\t\t\tif ( samples > 0 && this._useMultisampledRTT( renderContext.renderTarget ) === false ) {\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\n\t\t\t\tconst mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tconst textures = renderContext.textures;\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t// TODO Add support for MRT\n\n\t\t\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\t\t\tconst viewY = renderContext.height - height - y;\n\n\t\t\t\t\t\tgl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );\n\t\t\t\t\t\tgl.invalidateSubFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );\n\t\t\t\t\t\tgl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( previousContext !== null ) {\n\n\t\t\tthis._setFramebuffer( previousContext );\n\n\t\t\tif ( previousContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( previousContext );\n\n\t\t\t} else {\n\n\t\t\t\tstate.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( renderContext );\n\n\t}\n\n\t/**\n\t * This method processes the result of occlusion queries and writes it\n\t * into render context data.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tresolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueries && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\t\t\tconst { gl } = this;\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueries = null;\n\n\t\t\tconst check = () => {\n\n\t\t\t\tlet completed = 0;\n\n\t\t\t\t// check all queries and requeue as appropriate\n\t\t\t\tfor ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {\n\n\t\t\t\t\tconst query = currentOcclusionQueries[ i ];\n\n\t\t\t\t\tif ( query === null ) continue;\n\n\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {\n\n\t\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT ) === 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t\t\tcurrentOcclusionQueries[ i ] = null;\n\t\t\t\t\t\tgl.deleteQuery( query );\n\n\t\t\t\t\t\tcompleted ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( completed < currentOcclusionQueries.length ) {\n\n\t\t\t\t\trequestAnimationFrame( check );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderContextData.occluded = occluded;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheck();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {Boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( renderContext ) {\n\n\t\tconst { state } = this;\n\t\tconst { x, y, width, height } = renderContext.viewportValue;\n\n\t\tstate.viewport( x, renderContext.height - height - y, width, height );\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tconst state = this.state;\n\n\t\tstate.setScissorTest( boolean );\n\n\t}\n\n\t/**\n\t * Performs a clear operation.\n\t *\n\t * @param {Boolean} color - Whether the color buffer should be cleared or not.\n\t * @param {Boolean} depth - Whether the depth buffer should be cleared or not.\n\t * @param {Boolean} stencil - Whether the stencil buffer should be cleared or not.\n\t * @param {Object?} [descriptor=null] - The render context of the current set render target.\n\t * @param {Boolean} [setFrameBuffer=true] - TODO.\n\t */\n\tclear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\t// premultiply alpha\n\n\t\t\tclearColor.r *= clearColor.a;\n\t\t\tclearColor.g *= clearColor.a;\n\t\t\tclearColor.b *= clearColor.a;\n\n\t\t\tdescriptor = {\n\t\t\t\ttextures: null,\n\t\t\t\tclearColorValue: clearColor\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tlet clear = 0;\n\n\t\tif ( color ) clear |= gl.COLOR_BUFFER_BIT;\n\t\tif ( depth ) clear |= gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;\n\n\t\tif ( clear !== 0 ) {\n\n\t\t\tlet clearColor;\n\n\t\t\tif ( descriptor.clearColorValue ) {\n\n\t\t\t\tclearColor = descriptor.clearColorValue;\n\n\t\t\t} else {\n\n\t\t\t\tclearColor = this.getClearColor();\n\n\t\t\t\t// premultiply alpha\n\n\t\t\t\tclearColor.r *= clearColor.a;\n\t\t\t\tclearColor.g *= clearColor.a;\n\t\t\t\tclearColor.b *= clearColor.a;\n\n\t\t\t}\n\n\t\t\tif ( depth ) this.state.setDepthMask( true );\n\n\t\t\tif ( descriptor.textures === null ) {\n\n\t\t\t\tgl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );\n\t\t\t\tgl.clear( clear );\n\n\t\t\t} else {\n\n\t\t\t\tif ( setFrameBuffer ) this._setFramebuffer( descriptor );\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tfor ( let i = 0; i < descriptor.textures.length; i ++ ) {\n\n\t\t\t\t\t\tgl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( depth && stencil ) {\n\n\t\t\t\t\tgl.clearBufferfi( gl.DEPTH_STENCIL, 0, 1, 0 );\n\n\t\t\t\t} else if ( depth ) {\n\n\t\t\t\t\tgl.clearBufferfv( gl.DEPTH, 0, [ 1.0 ] );\n\n\t\t\t\t} else if ( stencil ) {\n\n\t\t\t\t\tgl.clearBufferiv( gl.STENCIL, 0, [ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * prepares the state for upcoming compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( computeGroup ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tthis.initTimestampQuery( computeGroup );\n\n\t}\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t */\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tif ( this.discard === false ) {\n\n\t\t\t// required here to handle async behaviour of render.compute()\n\t\t\tgl.enable( gl.RASTERIZER_DISCARD );\n\t\t\tthis.discard = true;\n\n\t\t}\n\n\t\tconst { programGPU, transformBuffers, attributes } = this.get( pipeline );\n\n\t\tconst vaoKey = this._getVaoKey( null, attributes );\n\n\t\tconst vaoGPU = this.vaoCache[ vaoKey ];\n\n\t\tif ( vaoGPU === undefined ) {\n\n\t\t\tthis._createVao( null, attributes );\n\n\t\t} else {\n\n\t\t\tgl.bindVertexArray( vaoGPU );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\tthis._bindUniforms( bindings );\n\n\t\tconst transformFeedbackGPU = this._getTransformFeedback( transformBuffers );\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\t\tgl.beginTransformFeedback( gl.POINTS );\n\n\t\tif ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {\n\n\t\t\tgl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( gl.POINTS, 0, computeNode.count );\n\n\t\t}\n\n\t\tgl.endTransformFeedback();\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\t// switch active buffers\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst dualAttributeData = transformBuffers[ i ];\n\n\t\t\tif ( dualAttributeData.pbo ) {\n\n\t\t\t\tthis.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );\n\n\t\t\t}\n\n\t\t\tdualAttributeData.switchBuffers();\n\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * finalizes work after compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( computeGroup ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.discard = false;\n\n\t\tgl.disable( gl.RASTERIZER_DISCARD );\n\n\t\tthis.prepareTimestampBuffer( computeGroup );\n\n\t\tif ( this._currentContext ) {\n\n\t\t\tthis._setFramebuffer( this._currentContext );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( renderObject/*, info*/ ) {\n\n\t\tconst { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;\n\t\tconst { programGPU } = this.get( pipeline );\n\n\t\tconst { gl, state } = this;\n\n\t\tconst contextData = this.get( context );\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t//\n\n\t\tthis._bindUniforms( renderObject.getBindings() );\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tstate.setMaterial( material, frontFaceCW, hardwareClippingPlanes );\n\n\t\tstate.useProgram( programGPU );\n\n\t\t//\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet vaoGPU = renderObjectData.staticVao;\n\n\t\tif ( vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id ) {\n\n\t\t\tconst vaoKey = this._getVaoKey( renderObject.getIndex(), renderObject.getAttributes() );\n\n\t\t\tvaoGPU = this.vaoCache[ vaoKey ];\n\n\t\t\tif ( vaoGPU === undefined ) {\n\n\t\t\t\tlet staticVao;\n\n\t\t\t\t( { vaoGPU, staticVao } = this._createVao( renderObject.getIndex(), renderObject.getAttributes() ) );\n\n\t\t\t\tif ( staticVao ) {\n\n\t\t\t\t\trenderObjectData.staticVao = vaoGPU;\n\t\t\t\t\trenderObjectData.geometryId = renderObject.geometry.id;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\t//\n\n\t\tconst index = renderObject.getIndex();\n\n\t\t//\n\n\t\tconst lastObject = contextData.lastOcclusionObject;\n\n\t\tif ( lastObject !== object && lastObject !== undefined ) {\n\n\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t\tcontextData.occlusionQueryIndex ++;\n\n\t\t\t}\n\n\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\tconst query = gl.createQuery();\n\n\t\t\t\tgl.beginQuery( gl.ANY_SAMPLES_PASSED, query );\n\n\t\t\t\tcontextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;\n\t\t\t\tcontextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;\n\n\t\t\t}\n\n\t\t\tcontextData.lastOcclusionObject = object;\n\n\t\t}\n\n\t\t//\n\t\tconst renderer = this.bufferRenderer;\n\n\t\tif ( object.isPoints ) renderer.mode = gl.POINTS;\n\t\telse if ( object.isLineSegments ) renderer.mode = gl.LINES;\n\t\telse if ( object.isLine ) renderer.mode = gl.LINE_STRIP;\n\t\telse if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;\n\t\telse {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );\n\t\t\t\trenderer.mode = gl.LINES;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.mode = gl.TRIANGLES;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { vertexCount, instanceCount } = drawParams;\n\t\tlet { firstVertex } = drawParams;\n\n\t\trenderer.object = object;\n\n\t\tif ( index !== null ) {\n\n\t\t\tfirstVertex *= index.array.BYTES_PER_ELEMENT;\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\trenderer.index = index.count;\n\t\t\trenderer.type = indexData.type;\n\n\t\t} else {\n\n\t\t\trenderer.index = 0;\n\n\t\t}\n\n\t\tconst draw = () => {\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t\t} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\t\twarnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t\t}\n\n\t\t\t} else if ( instanceCount > 1 ) {\n\n\t\t\t\trenderer.renderInstances( firstVertex, vertexCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( firstVertex, vertexCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0 ) {\n\n\t\t\tconst cameraData = this.get( renderObject.camera );\n\t\t\tconst cameras = renderObject.camera.cameras;\n\t\t\tconst cameraIndex = renderObject.getBindingGroup( 'cameraIndex' ).bindings[ 0 ];\n\n\t\t\tif ( cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length ) {\n\n\t\t\t\tconst data = new Uint32Array( [ 0, 0, 0, 0 ] );\n\t\t\t\tconst indexesGPU = [];\n\n\t\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\t\tconst bufferGPU = gl.createBuffer();\n\n\t\t\t\t\tdata[ 0 ] = i;\n\n\t\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW );\n\n\t\t\t\t\tindexesGPU.push( bufferGPU );\n\n\t\t\t\t}\n\n\t\t\t\tcameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this\n\n\t\t\t}\n\n\t\t\tconst cameraIndexData = this.get( cameraIndex );\n\t\t\tconst pixelRatio = this.renderer.getPixelRatio();\n\n\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\tconst subCamera = cameras[ i ];\n\n\t\t\t\tif ( object.layers.test( subCamera.layers ) ) {\n\n\t\t\t\t\tconst vp = subCamera.viewport;\n\n\t\t\t\t\tconst x = vp.x * pixelRatio;\n\t\t\t\t\tconst y = vp.y * pixelRatio;\n\t\t\t\t\tconst width = vp.width * pixelRatio;\n\t\t\t\t\tconst height = vp.height * pixelRatio;\n\n\t\t\t\t\tstate.viewport(\n\t\t\t\t\t\tMath.floor( x ),\n\t\t\t\t\t\tMath.floor( renderObject.context.height - height - y ),\n\t\t\t\t\t\tMath.floor( width ),\n\t\t\t\t\t\tMath.floor( height )\n\t\t\t\t\t);\n\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, cameraIndexData.index, cameraData.indexesGPU[ i ] );\n\n\t\t\t\t\tdraw();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdraw();\n\n\t\t}\n\n\t\t//\n\n\t\tgl.bindVertexArray( null );\n\n\t}\n\n\t/**\n\t * Explain why always null is returned.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( /*renderObject*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Explain why no cache key is computed.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {String} The cache key.\n\t */\n\tgetRenderCacheKey( /*renderObject*/ ) {\n\n\t\treturn '';\n\n\t}\n\n\t// textures\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {Number} x - The x coordinate of the copy origin.\n\t * @param {Number} y - The y coordinate of the copy origin.\n\t * @param {Number} width - The width of the copy.\n\t * @param {Number} height - The height of the copy.\n\t * @param {Number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * This method does nothing since WebGL 2 has no concept of samplers.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( /*texture*/ ) {\n\n\t\t//console.warn( 'Abstract class.' );\n\n\t}\n\n\t/**\n\t * This method does nothing since WebGL 2 has no concept of samplers.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( /*texture*/ ) {}\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {GLSLNodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new GLSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( program ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { stage, code } = program;\n\n\t\tconst shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );\n\n\t\tgl.shaderSource( shader, code );\n\t\tgl.compileShader( shader );\n\n\t\tthis.set( program, {\n\t\t\tshaderGPU: shader\n\t\t} );\n\n\t}\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst gl = this.gl;\n\t\tconst pipeline = renderObject.pipeline;\n\n\t\t// Program\n\n\t\tconst { fragmentProgram, vertexProgram } = pipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( vertexProgram ).shaderGPU;\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\t\tgl.linkProgram( programGPU );\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU,\n\t\t\tfragmentShader,\n\t\t\tvertexShader\n\t\t} );\n\n\t\tif ( promises !== null && this.parallel ) {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tconst parallel = this.parallel;\n\t\t\t\tconst checkStatus = () => {\n\n\t\t\t\t\tif ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {\n\n\t\t\t\t\t\tthis._completeCompile( renderObject, pipeline );\n\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trequestAnimationFrame( checkStatus );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tcheckStatus();\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._completeCompile( renderObject, pipeline );\n\n\t}\n\n\t/**\n\t * Formats the source code of error messages.\n\t *\n\t * @private\n\t * @param {String} string - The code.\n\t * @param {Number} errorLine - The error line.\n\t * @return {String} The formatted code.\n\t */\n\t_handleSource( string, errorLine ) {\n\n\t\tconst lines = string.split( '\\n' );\n\t\tconst lines2 = [];\n\n\t\tconst from = Math.max( errorLine - 6, 0 );\n\t\tconst to = Math.min( errorLine + 6, lines.length );\n\n\t\tfor ( let i = from; i < to; i ++ ) {\n\n\t\t\tconst line = i + 1;\n\t\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t\t}\n\n\t\treturn lines2.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Gets the shader compilation errors from the info log.\n\t *\n\t * @private\n\t * @param {WebGL2RenderingContext} gl - The rendering context.\n\t * @param {WebGLShader} shader - The WebGL shader object.\n\t * @param {String} type - The shader type.\n\t * @return {String} The shader errors.\n\t */\n\t_getShaderErrors( gl, shader, type ) {\n\n\t\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\t\tconst errors = gl.getShaderInfoLog( shader ).trim();\n\n\t\tif ( status && errors === '' ) return '';\n\n\t\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\t\tif ( errorMatches ) {\n\n\t\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t\t} else {\n\n\t\t\treturn errors;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Logs shader compilation errors.\n\t *\n\t * @private\n\t * @param {WebGLProgram} programGPU - The WebGL program.\n\t * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.\n\t * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.\n\t */\n\t_logProgramError( programGPU, glFragmentShader, glVertexShader ) {\n\n\t\tif ( this.renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst gl = this.gl;\n\n\t\t\tconst programLog = gl.getProgramInfoLog( programGPU ).trim();\n\n\t\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\n\t\t\t\tif ( typeof this.renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\tthis.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Completes the shader program setup for the given render object.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {RenderPipeline} pipeline - The render pipeline.\n\t */\n\t_completeCompile( renderObject, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\t\tconst pipelineData = this.get( pipeline );\n\t\tconst { programGPU, fragmentShader, vertexShader } = pipelineData;\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\t//\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tconst { state, gl } = this;\n\n\t\t// Program\n\n\t\tconst fragmentProgram = {\n\t\t\tstage: 'fragment',\n\t\t\tcode: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n\t\t};\n\n\t\tthis.createProgram( fragmentProgram );\n\n\t\tconst { computeProgram } = computePipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( computeProgram ).shaderGPU;\n\n\t\tconst transforms = computeProgram.transforms;\n\n\t\tconst transformVaryingNames = [];\n\t\tconst transformAttributeNodes = [];\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\ttransformVaryingNames.push( transform.varyingName );\n\t\t\ttransformAttributeNodes.push( transform.attributeNode );\n\n\t\t}\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\n\t\tgl.transformFeedbackVaryings(\n\t\t\tprogramGPU,\n\t\t\ttransformVaryingNames,\n\t\t\tgl.SEPARATE_ATTRIBS\n\t\t);\n\n\t\tgl.linkProgram( programGPU );\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\tconst attributeNodes = computeProgram.attributes;\n\t\tconst attributes = [];\n\t\tconst transformBuffers = [];\n\n\t\tfor ( let i = 0; i < attributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = attributeNodes[ i ].node.attribute;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < transformAttributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = transformAttributeNodes[ i ].attribute;\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\ttransformBuffers.push( attributeData );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.set( computePipeline, {\n\t\t\tprogramGPU,\n\t\t\ttransformBuffers,\n\t\t\tattributes\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings /*, cacheIndex, version*/ ) {\n\n\t\tif ( this._knownBindings.has( bindings ) === false ) {\n\n\t\t\tthis._knownBindings.add( bindings );\n\n\t\t\tlet uniformBuffers = 0;\n\t\t\tlet textures = 0;\n\n\t\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\t\tthis.set( bindGroup, {\n\t\t\t\t\ttextures: textures,\n\t\t\t\t\tuniformBuffers: uniformBuffers\n\t\t\t\t} );\n\n\t\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\t\tif ( binding.isUniformBuffer ) uniformBuffers ++;\n\t\t\t\t\tif ( binding.isSampledTexture ) textures ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updateBindings( bindGroup, bindings );\n\n\t}\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tupdateBindings( bindGroup /*, bindings, cacheIndex, version*/ ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst bindGroupData = this.get( bindGroup );\n\n\t\tlet i = bindGroupData.uniformBuffers;\n\t\tlet t = bindGroupData.textures;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\tconst data = binding.buffer;\n\t\t\t\tconst bufferGPU = gl.createBuffer();\n\n\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: i ++,\n\t\t\t\t\tbufferGPU\n\t\t\t\t} );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst { textureGPU, glTextureType } = this.get( binding.texture );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: t ++,\n\t\t\t\t\ttextureGPU,\n\t\t\t\t\tglTextureType\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\tconst bindingData = this.get( binding );\n\t\t\tconst bufferGPU = bindingData.bufferGPU;\n\t\t\tconst data = binding.buffer;\n\n\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t}\n\n\t}\n\n\t// attributes\n\n\t/**\n\t * Creates the GPU buffer of an indexed shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( attribute ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @param {String} name - The feature's name.\n\t * @return {Boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tconst keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );\n\n\t\tconst extensions = this.extensions;\n\n\t\tfor ( let i = 0; i < keysMatching.length; i ++ ) {\n\n\t\t\tif ( extensions.has( keysMatching[ i ] ) ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @return {Number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n\t * @param {Number} [level=0] - The mip level to copy.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tthis.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tthis.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );\n\n\t}\n\n\t/**\n\t * Configures the active framebuffer from the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} descriptor - The render context.\n\t */\n\t_setFramebuffer( descriptor ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tlet currentFrameBuffer = null;\n\n\t\tif ( descriptor.textures !== null ) {\n\n\t\t\tconst renderTarget = descriptor.renderTarget;\n\t\t\tconst renderTargetContextData = this.get( renderTarget );\n\t\t\tconst { samples, depthBuffer, stencilBuffer } = renderTarget;\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\t\t\tconst isRenderTarget3D = renderTarget.isRenderTarget3D === true;\n\t\t\tconst isRenderTargetArray = renderTarget.isRenderTargetArray === true;\n\t\t\tconst isXRRenderTarget = renderTarget.isXRRenderTarget === true;\n\t\t\tconst hasExternalTextures = ( isXRRenderTarget === true && renderTarget.hasExternalTextures === true );\n\n\t\t\tlet msaaFb = renderTargetContextData.msaaFrameBuffer;\n\t\t\tlet depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n\t\t\tconst multisampledRTTExt = this.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\t\tconst useMultisampledRTT = this._useMultisampledRTT( renderTarget );\n\n\t\t\tconst cacheKey = getCacheKey( descriptor );\n\n\t\t\tlet fb;\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.cubeFramebuffers[ cacheKey ];\n\n\t\t\t} else if ( isXRRenderTarget && hasExternalTextures === false ) {\n\n\t\t\t\tfb = this._xrFamebuffer;\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.framebuffers[ cacheKey ];\n\n\t\t\t}\n\n\t\t\tif ( fb === undefined ) {\n\n\t\t\t\tfb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tconst { textureGPU } = this.get( textures[ 0 ] );\n\n\t\t\t\t\tconst cubeFace = this.renderer._activeCubeFace;\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetContextData.framebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tconst attachment = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t\t\tif ( isRenderTarget3D || isRenderTargetArray ) {\n\n\t\t\t\t\t\t\tconst layer = this.renderer._activeCubeFace;\n\n\t\t\t\t\t\t\tgl.framebufferTextureLayer( gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, layer );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useMultisampledRTT ) {\n\n\t\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.drawBuffers( descriptor, fb );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTarget.isXRRenderTarget && renderTarget.autoAllocateDepthBuffer === true ) {\n\n\t\t\t\t\tconst renderbuffer = gl.createRenderbuffer();\n\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( renderbuffer, descriptor, 0, useMultisampledRTT );\n\t\t\t\t\trenderTargetContextData.xrDepthRenderbuffer = renderbuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( descriptor.depthTexture !== null ) {\n\n\t\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tif ( useMultisampledRTT ) {\n\n\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// rebind external XR textures\n\n\t\t\t\tif ( isXRRenderTarget && hasExternalTextures ) {\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\t\t// rebind color\n\n\t\t\t\t\tconst textureData = this.get( descriptor.textures[ 0 ] );\n\n\t\t\t\t\tif ( useMultisampledRTT ) {\n\n\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// rebind depth\n\n\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\n\t\t\t\t\tif ( renderTarget.autoAllocateDepthBuffer === true ) {\n\n\t\t\t\t\t\tconst renderbuffer = renderTargetContextData.xrDepthRenderbuffer;\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\n\t\t\t\t\t\tif ( useMultisampledRTT ) {\n\n\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( samples > 0 && useMultisampledRTT === false ) {\n\n\t\t\t\tif ( msaaFb === undefined ) {\n\n\t\t\t\t\tconst invalidationArray = [];\n\n\t\t\t\t\tmsaaFb = gl.createFramebuffer();\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );\n\n\t\t\t\t\tconst msaaRenderbuffers = [];\n\n\t\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tmsaaRenderbuffers[ i ] = gl.createRenderbuffer();\n\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\t\t\t\t\t\tinvalidationArray.push( gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tif ( depthBuffer ) {\n\n\t\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst texture = descriptor.textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.msaaFrameBuffer = msaaFb;\n\t\t\t\t\trenderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n\n\t\t\t\t\tif ( depthRenderbuffer === undefined ) {\n\n\t\t\t\t\t\tdepthRenderbuffer = gl.createRenderbuffer();\n\t\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor, samples );\n\n\t\t\t\t\t\trenderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n\n\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.invalidationArray = invalidationArray;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t} else {\n\n\t\t\t\tcurrentFrameBuffer = fb;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );\n\n\t}\n\n\t/**\n\t * Computes the VAO key for the given index and attributes.\n\t *\n\t * @private\n\t * @param {BufferAttribute?} index - The index. `null` for non-indexed geometries.\n\t * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n\t * @return {String} The VAO key.\n\t */\n\t_getVaoKey( index, attributes ) {\n\n\t\tlet key = '';\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\tkey += ':' + indexData.id;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attributeData = this.get( attributes[ i ] );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t}\n\n\t\treturn key;\n\n\t}\n\n\t/**\n\t * Creates a VAO from the index and attributes.\n\t *\n\t * @private\n\t * @param {BufferAttribute?} index - The index. `null` for non-indexed geometries.\n\t * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n\t * @return {Object} The VAO data.\n\t */\n\t_createVao( index, attributes ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst vaoGPU = gl.createVertexArray();\n\t\tlet key = '';\n\n\t\tlet staticVao = true;\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU );\n\n\t\t\tkey += ':' + indexData.id;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attribute = attributes[ i ];\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );\n\t\t\tgl.enableVertexAttribArray( i );\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) staticVao = false;\n\n\t\t\tlet stride, offset;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\tstride = attribute.data.stride * attributeData.bytesPerElement;\n\t\t\t\toffset = attribute.offset * attributeData.bytesPerElement;\n\n\t\t\t} else {\n\n\t\t\t\tstride = 0;\n\t\t\t\toffset = 0;\n\n\t\t\t}\n\n\t\t\tif ( attributeData.isInteger ) {\n\n\t\t\t\tgl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );\n\n\t\t\t} else {\n\n\t\t\t\tgl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );\n\n\t\t\t}\n\n\t\t\tif ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.meshPerAttribute );\n\n\t\t\t} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n\t\tthis.vaoCache[ key ] = vaoGPU;\n\n\t\treturn { vaoGPU, staticVao };\n\n\t}\n\n\t/**\n\t * Creates a transform feedback from the given transform buffers.\n\t *\n\t * @private\n\t * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.\n\t * @return {WebGLTransformFeedback} The transform feedback.\n\t */\n\t_getTransformFeedback( transformBuffers ) {\n\n\t\tlet key = '';\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tkey += ':' + transformBuffers[ i ].id;\n\n\t\t}\n\n\t\tlet transformFeedbackGPU = this.transformFeedbackCache[ key ];\n\n\t\tif ( transformFeedbackGPU !== undefined ) {\n\n\t\t\treturn transformFeedbackGPU;\n\n\t\t}\n\n\t\tconst { gl } = this;\n\n\t\ttransformFeedbackGPU = gl.createTransformFeedback();\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst attributeData = transformBuffers[ i ];\n\n\t\t\tgl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );\n\n\t\t}\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\tthis.transformFeedbackCache[ key ] = transformFeedbackGPU;\n\n\t\treturn transformFeedbackGPU;\n\n\t}\n\n\t/**\n\t * Setups the given bindings.\n\t *\n\t * @private\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {WebGLProgram} programGPU - The WebGL program.\n\t */\n\t_setupBindings( bindings, programGPU ) {\n\n\t\tconst gl = this.gl;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\tconst location = gl.getUniformBlockIndex( programGPU, binding.name );\n\t\t\t\t\tgl.uniformBlockBinding( programGPU, location, index );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tconst location = gl.getUniformLocation( programGPU, binding.name );\n\t\t\t\t\tgl.uniform1i( location, index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Binds the given uniforms.\n\t *\n\t * @private\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\t_bindUniforms( bindings ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\t// TODO USE bindBufferRange to group multiple uniform buffers\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tstate.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension\n\t * should be used when MSAA is enabled.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The render target that should be multisampled.\n\t * @return {Boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.\n\t */\n\t_useMultisampledRTT( renderTarget ) {\n\n\t\treturn renderTarget.samples > 0 && this.extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTarget.autoAllocateDepthBuffer !== false;\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tconst extension = this.extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.loseContext();\n\n\t\tthis.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );\n\n\t}\n\n}\n\nconst GPUPrimitiveTopology = {\n\tPointList: 'point-list',\n\tLineList: 'line-list',\n\tLineStrip: 'line-strip',\n\tTriangleList: 'triangle-list',\n\tTriangleStrip: 'triangle-strip',\n};\n\nconst GPUCompareFunction = {\n\tNever: 'never',\n\tLess: 'less',\n\tEqual: 'equal',\n\tLessEqual: 'less-equal',\n\tGreater: 'greater',\n\tNotEqual: 'not-equal',\n\tGreaterEqual: 'greater-equal',\n\tAlways: 'always'\n};\n\nconst GPUStoreOp = {\n\tStore: 'store',\n\tDiscard: 'discard'\n};\n\nconst GPULoadOp = {\n\tLoad: 'load',\n\tClear: 'clear'\n};\n\nconst GPUFrontFace = {\n\tCCW: 'ccw',\n\tCW: 'cw'\n};\n\nconst GPUCullMode = {\n\tNone: 'none',\n\tFront: 'front',\n\tBack: 'back'\n};\n\nconst GPUIndexFormat = {\n\tUint16: 'uint16',\n\tUint32: 'uint32'\n};\n\nconst GPUTextureFormat = {\n\n\t// 8-bit formats\n\n\tR8Unorm: 'r8unorm',\n\tR8Snorm: 'r8snorm',\n\tR8Uint: 'r8uint',\n\tR8Sint: 'r8sint',\n\n\t// 16-bit formats\n\n\tR16Uint: 'r16uint',\n\tR16Sint: 'r16sint',\n\tR16Float: 'r16float',\n\tRG8Unorm: 'rg8unorm',\n\tRG8Snorm: 'rg8snorm',\n\tRG8Uint: 'rg8uint',\n\tRG8Sint: 'rg8sint',\n\n\t// 32-bit formats\n\n\tR32Uint: 'r32uint',\n\tR32Sint: 'r32sint',\n\tR32Float: 'r32float',\n\tRG16Uint: 'rg16uint',\n\tRG16Sint: 'rg16sint',\n\tRG16Float: 'rg16float',\n\tRGBA8Unorm: 'rgba8unorm',\n\tRGBA8UnormSRGB: 'rgba8unorm-srgb',\n\tRGBA8Snorm: 'rgba8snorm',\n\tRGBA8Uint: 'rgba8uint',\n\tRGBA8Sint: 'rgba8sint',\n\tBGRA8Unorm: 'bgra8unorm',\n\tBGRA8UnormSRGB: 'bgra8unorm-srgb',\n\t// Packed 32-bit formats\n\tRGB9E5UFloat: 'rgb9e5ufloat',\n\tRGB10A2Unorm: 'rgb10a2unorm',\n\tRG11B10uFloat: 'rgb10a2unorm',\n\n\t// 64-bit formats\n\n\tRG32Uint: 'rg32uint',\n\tRG32Sint: 'rg32sint',\n\tRG32Float: 'rg32float',\n\tRGBA16Uint: 'rgba16uint',\n\tRGBA16Sint: 'rgba16sint',\n\tRGBA16Float: 'rgba16float',\n\n\t// 128-bit formats\n\n\tRGBA32Uint: 'rgba32uint',\n\tRGBA32Sint: 'rgba32sint',\n\tRGBA32Float: 'rgba32float',\n\n\t// Depth and stencil formats\n\n\tStencil8: 'stencil8',\n\tDepth16Unorm: 'depth16unorm',\n\tDepth24Plus: 'depth24plus',\n\tDepth24PlusStencil8: 'depth24plus-stencil8',\n\tDepth32Float: 'depth32float',\n\n\t// 'depth32float-stencil8' extension\n\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\n\t// BC compressed formats usable if 'texture-compression-bc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tBC1RGBAUnorm: 'bc1-rgba-unorm',\n\tBC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n\tBC2RGBAUnorm: 'bc2-rgba-unorm',\n\tBC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n\tBC3RGBAUnorm: 'bc3-rgba-unorm',\n\tBC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n\tBC4RUnorm: 'bc4-r-unorm',\n\tBC4RSnorm: 'bc4-r-snorm',\n\tBC5RGUnorm: 'bc5-rg-unorm',\n\tBC5RGSnorm: 'bc5-rg-snorm',\n\tBC6HRGBUFloat: 'bc6h-rgb-ufloat',\n\tBC6HRGBFloat: 'bc6h-rgb-float',\n\tBC7RGBAUnorm: 'bc7-rgba-unorm',\n\tBC7RGBAUnormSRGB: 'bc7-rgba-srgb',\n\n\t// ETC2 compressed formats usable if 'texture-compression-etc2' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tETC2RGB8Unorm: 'etc2-rgb8unorm',\n\tETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n\tETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n\tETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n\tETC2RGBA8Unorm: 'etc2-rgba8unorm',\n\tETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n\tEACR11Unorm: 'eac-r11unorm',\n\tEACR11Snorm: 'eac-r11snorm',\n\tEACRG11Unorm: 'eac-rg11unorm',\n\tEACRG11Snorm: 'eac-rg11snorm',\n\n\t// ASTC compressed formats usable if 'texture-compression-astc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tASTC4x4Unorm: 'astc-4x4-unorm',\n\tASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n\tASTC5x4Unorm: 'astc-5x4-unorm',\n\tASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n\tASTC5x5Unorm: 'astc-5x5-unorm',\n\tASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n\tASTC6x5Unorm: 'astc-6x5-unorm',\n\tASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n\tASTC6x6Unorm: 'astc-6x6-unorm',\n\tASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n\tASTC8x5Unorm: 'astc-8x5-unorm',\n\tASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n\tASTC8x6Unorm: 'astc-8x6-unorm',\n\tASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n\tASTC8x8Unorm: 'astc-8x8-unorm',\n\tASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n\tASTC10x5Unorm: 'astc-10x5-unorm',\n\tASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n\tASTC10x6Unorm: 'astc-10x6-unorm',\n\tASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n\tASTC10x8Unorm: 'astc-10x8-unorm',\n\tASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n\tASTC10x10Unorm: 'astc-10x10-unorm',\n\tASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n\tASTC12x10Unorm: 'astc-12x10-unorm',\n\tASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n\tASTC12x12Unorm: 'astc-12x12-unorm',\n\tASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',\n\n};\n\nconst GPUAddressMode = {\n\tClampToEdge: 'clamp-to-edge',\n\tRepeat: 'repeat',\n\tMirrorRepeat: 'mirror-repeat'\n};\n\nconst GPUFilterMode = {\n\tLinear: 'linear',\n\tNearest: 'nearest'\n};\n\nconst GPUBlendFactor = {\n\tZero: 'zero',\n\tOne: 'one',\n\tSrc: 'src',\n\tOneMinusSrc: 'one-minus-src',\n\tSrcAlpha: 'src-alpha',\n\tOneMinusSrcAlpha: 'one-minus-src-alpha',\n\tDst: 'dst',\n\tOneMinusDstColor: 'one-minus-dst',\n\tDstAlpha: 'dst-alpha',\n\tOneMinusDstAlpha: 'one-minus-dst-alpha',\n\tSrcAlphaSaturated: 'src-alpha-saturated',\n\tConstant: 'constant',\n\tOneMinusConstant: 'one-minus-constant'\n};\n\nconst GPUBlendOperation = {\n\tAdd: 'add',\n\tSubtract: 'subtract',\n\tReverseSubtract: 'reverse-subtract',\n\tMin: 'min',\n\tMax: 'max'\n};\n\nconst GPUColorWriteFlags = {\n\tNone: 0,\n\tRed: 0x1,\n\tGreen: 0x2,\n\tBlue: 0x4,\n\tAlpha: 0x8,\n\tAll: 0xF\n};\n\nconst GPUStencilOperation = {\n\tKeep: 'keep',\n\tZero: 'zero',\n\tReplace: 'replace',\n\tInvert: 'invert',\n\tIncrementClamp: 'increment-clamp',\n\tDecrementClamp: 'decrement-clamp',\n\tIncrementWrap: 'increment-wrap',\n\tDecrementWrap: 'decrement-wrap'\n};\n\nconst GPUBufferBindingType = {\n\tUniform: 'uniform',\n\tStorage: 'storage',\n\tReadOnlyStorage: 'read-only-storage'\n};\n\nconst GPUStorageTextureAccess = {\n\tWriteOnly: 'write-only',\n\tReadOnly: 'read-only',\n\tReadWrite: 'read-write',\n};\n\nconst GPUTextureSampleType = {\n\tFloat: 'float',\n\tUnfilterableFloat: 'unfilterable-float',\n\tDepth: 'depth',\n\tSInt: 'sint',\n\tUInt: 'uint'\n};\n\nconst GPUTextureDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tThreeD: '3d'\n};\n\nconst GPUTextureViewDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tTwoDArray: '2d-array',\n\tCube: 'cube',\n\tCubeArray: 'cube-array',\n\tThreeD: '3d'\n};\n\nconst GPUTextureAspect = {\n\tAll: 'all',\n\tStencilOnly: 'stencil-only',\n\tDepthOnly: 'depth-only'\n};\n\nconst GPUInputStepMode = {\n\tVertex: 'vertex',\n\tInstance: 'instance'\n};\n\nconst GPUFeatureName = {\n\tDepthClipControl: 'depth-clip-control',\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\tTextureCompressionBC: 'texture-compression-bc',\n\tTextureCompressionETC2: 'texture-compression-etc2',\n\tTextureCompressionASTC: 'texture-compression-astc',\n\tTimestampQuery: 'timestamp-query',\n\tIndirectFirstInstance: 'indirect-first-instance',\n\tShaderF16: 'shader-f16',\n\tRG11B10UFloat: 'rg11b10ufloat-renderable',\n\tBGRA8UNormStorage: 'bgra8unorm-storage',\n\tFloat32Filterable: 'float32-filterable',\n\tClipDistances: 'clip-distances',\n\tDualSourceBlending: 'dual-source-blending',\n\tSubgroups: 'subgroups'\n};\n\n/**\n * Represents a sampler binding type.\n *\n * @private\n * @augments Binding\n */\nclass Sampler extends Binding {\n\n\t/**\n\t * Constructs a new sampler.\n\t *\n\t * @param {String} name - The samplers's name.\n\t * @param {Texture?} texture - The texture this binding is referring to.\n\t */\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * The texture the sampler is referring to.\n\t\t *\n\t\t * @type {Texture?}\n\t\t */\n\t\tthis.texture = texture;\n\n\t\t/**\n\t\t * The binding's version.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = texture ? texture.version : 0;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampler = true;\n\n\t}\n\n}\n\n/**\n * A special form of sampler binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments Sampler\n */\nclass NodeSampler extends Sampler {\n\n\t/**\n\t * Constructs a new node-based sampler.\n\t *\n\t * @param {String} name - The samplers's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( name, textureNode, groupNode ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\t/**\n\t\t * The texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * Updates the texture value of this sampler.\n\t */\n\tupdate() {\n\n\t\tthis.texture = this.textureNode.value;\n\n\t}\n\n}\n\n/**\n * Represents a storage buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass StorageBuffer extends Buffer {\n\n\t/**\n\t * Constructs a new uniform buffer.\n\t *\n\t * @param {String} name - The buffer's name.\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tconstructor( name, attribute ) {\n\n\t\tsuper( name, attribute ? attribute.array : null );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {BufferAttribute}\n\t\t */\n\t\tthis.attribute = attribute;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBuffer = true;\n\n\t}\n\n}\n\nlet _id = 0;\n\n/**\n * A special form of storage buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments StorageBuffer\n */\nclass NodeStorageBuffer extends StorageBuffer {\n\n\t/**\n\t * Constructs a new node-based storage buffer.\n\t *\n\t * @param {StorageBufferNode} nodeUniform - The storage buffer node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {StorageBufferNode}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t\t/**\n\t\t * The access type.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * The storage buffer.\n\t *\n\t * @type {BufferAttribute}\n\t */\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\n/**\n * A WebGPU backend utility module used by {@link WebGPUTextureUtils}.\n *\n * @private\n */\nclass WebGPUTexturePassUtils extends DataMap {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {GPUDevice} device - The WebGPU device.\n\t */\n\tconstructor( device ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The WebGPU device.\n\t\t *\n\t\t * @type {GPUDevice}\n\t\t */\n\t\tthis.device = device;\n\n\t\tconst mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n\n\t\tconst mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n\n\t\tconst flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n\n\t\t/**\n\t\t * The mipmap GPU sampler.\n\t\t *\n\t\t * @type {GPUSampler}\n\t\t */\n\t\tthis.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );\n\n\t\t/**\n\t\t * The flipY GPU sampler.\n\t\t *\n\t\t * @type {GPUSampler}\n\t\t */\n\t\tthis.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()\n\n\t\t/**\n\t\t * A cache for GPU render pipelines used for copy/transfer passes.\n\t\t * Every texture format requires a unique pipeline.\n\t\t *\n\t\t * @type {Object<String,GPURenderPipeline>}\n\t\t */\n\t\tthis.transferPipelines = {};\n\n\t\t/**\n\t\t * A cache for GPU render pipelines used for flipY passes.\n\t\t * Every texture format requires a unique pipeline.\n\t\t *\n\t\t * @type {Object<String,GPURenderPipeline>}\n\t\t */\n\t\tthis.flipYPipelines = {};\n\n\t\t/**\n\t\t * The mipmap vertex shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.mipmapVertexShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapVertex',\n\t\t\tcode: mipmapVertexSource\n\t\t} );\n\n\t\t/**\n\t\t * The mipmap fragment shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.mipmapFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapFragment',\n\t\t\tcode: mipmapFragmentSource\n\t\t} );\n\n\t\t/**\n\t\t * The flipY fragment shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.flipYFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'flipYFragment',\n\t\t\tcode: flipYFragmentSource\n\t\t} );\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the internal copy render pass. The pass\n\t * requires a unique render pipeline for each texture format.\n\t *\n\t * @param {String} format - The GPU texture format\n\t * @return {GPURenderPipeline} The GPU render pipeline.\n\t */\n\tgetTransferPipeline( format ) {\n\n\t\tlet pipeline = this.transferPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `mipmap-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.mipmapFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.transferPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the flipY render pass. The pass\n\t * requires a unique render pipeline for each texture format.\n\t *\n\t * @param {String} format - The GPU texture format\n\t * @return {GPURenderPipeline} The GPU render pipeline.\n\t */\n\tgetFlipYPipeline( format ) {\n\n\t\tlet pipeline = this.flipYPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `flipY-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.flipYFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.flipYPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Flip the contents of the given GPU texture along its vertical axis.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {Number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t */\n\tflipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst format = textureGPUDescriptor.format;\n\t\tconst { width, height } = textureGPUDescriptor.size;\n\n\t\tconst transferPipeline = this.getTransferPipeline( format );\n\t\tconst flipYPipeline = this.getFlipYPipeline( format );\n\n\t\tconst tempTexture = this.device.createTexture( {\n\t\t\tsize: { width, height, depthOrArrayLayers: 1 },\n\t\t\tformat,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n\t\t} );\n\n\t\tconst srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst dstView = tempTexture.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer: 0\n\t\t} );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tconst pass = ( pipeline, sourceView, destinationView ) => {\n\n\t\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.flipYSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: sourceView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: destinationView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\t\t\tpassEncoder.end();\n\n\t\t};\n\n\t\tpass( transferPipeline, srcView, dstView );\n\t\tpass( flipYPipeline, dstView, srcView );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\ttempTexture.destroy();\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given GPU texture.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {Number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t */\n\tgenerateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst textureData = this.get( textureGPU );\n\n\t\tif ( textureData.useCount === undefined ) {\n\n\t\t\ttextureData.useCount = 0;\n\t\t\ttextureData.layers = [];\n\n\t\t}\n\n\t\tconst passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tthis._mipmapRunBundles( commandEncoder, passes );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\tif ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;\n\n\t\ttextureData.useCount ++;\n\n\t}\n\n\t/**\n\t * Since multiple copy render passes are required to generate mipmaps, the passes\n\t * are managed as render bundles to improve performance.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {Number} baseArrayLayer - The index of the first array layer accessible to the texture view.\n\t * @return {Array} An array of render bundles.\n\t */\n\t_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {\n\n\t\tconst pipeline = this.getTransferPipeline( textureGPUDescriptor.format );\n\n\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\tlet srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst passes = [];\n\n\t\tfor ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.mipmapSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: srcView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst dstView = textureGPU.createView( {\n\t\t\t\tbaseMipLevel: i,\n\t\t\t\tmipLevelCount: 1,\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\tbaseArrayLayer\n\t\t\t} );\n\n\t\t\tconst passDescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: dstView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tconst passEncoder = this.device.createRenderBundleEncoder( {\n\t\t\t\tcolorFormats: [ textureGPUDescriptor.format ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\n\t\t\tpasses.push( {\n\t\t\t\trenderBundles: [ passEncoder.finish() ],\n\t\t\t\tpassDescriptor\n\t\t\t} );\n\n\t\t\tsrcView = dstView;\n\n\t\t}\n\n\t\treturn passes;\n\n\t}\n\n\t/**\n\t * Executes the render bundles.\n\t *\n\t * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.\n\t * @param {Array} passes - An array of render bundles.\n\t */\n\t_mipmapRunBundles( commandEncoder, passes ) {\n\n\t\tconst levels = passes.length;\n\n\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\tconst pass = passes[ i ];\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );\n\n\t\t\tpassEncoder.executeBundles( pass.renderBundles );\n\n\t\t\tpassEncoder.end();\n\n\t\t}\n\n\t}\n\n}\n\nconst _compareToWebGPU = {\n\t[ NeverCompare ]: 'never',\n\t[ LessCompare ]: 'less',\n\t[ EqualCompare ]: 'equal',\n\t[ LessEqualCompare ]: 'less-equal',\n\t[ GreaterCompare ]: 'greater',\n\t[ GreaterEqualCompare ]: 'greater-equal',\n\t[ AlwaysCompare ]: 'always',\n\t[ NotEqualCompare ]: 'not-equal'\n};\n\nconst _flipMap = [ 0, 1, 3, 2, 4, 5 ];\n\n/**\n * A WebGPU backend utility module for managing textures.\n *\n * @private\n */\nclass WebGPUTextureUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the pass utils.\n\t\t *\n\t\t * @type {WebGPUTexturePassUtils?}\n\t\t * @default null\n\t\t */\n\t\tthis._passUtils = null;\n\n\t\t/**\n\t\t * A dictionary for managing default textures. The key\n\t\t * is the texture format, the value the texture object.\n\t\t *\n\t\t * @type {Object<String,Texture>}\n\t\t */\n\t\tthis.defaultTexture = {};\n\n\t\t/**\n\t\t * A dictionary for managing default cube textures. The key\n\t\t * is the texture format, the value the texture object.\n\t\t *\n\t\t * @type {Object<String,CubeTexture>}\n\t\t */\n\t\tthis.defaultCubeTexture = {};\n\n\t\t/**\n\t\t * A default video frame.\n\t\t *\n\t\t * @type {VideoFrame?}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultVideoFrame = null;\n\n\t\t/**\n\t\t * Represents the color attachment of the default framebuffer.\n\t\t *\n\t\t * @type {GPUTexture?}\n\t\t * @default null\n\t\t */\n\t\tthis.colorBuffer = null;\n\n\t\t/**\n\t\t * Represents the depth attachment of the default framebuffer.\n\t\t *\n\t\t * @type {DepthTexture}\n\t\t */\n\t\tthis.depthTexture = new DepthTexture();\n\t\tthis.depthTexture.name = 'depthBuffer';\n\n\t}\n\n\t/**\n\t * Creates a GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst textureGPU = backend.get( texture );\n\n\t\tconst samplerDescriptorGPU = {\n\t\t\taddressModeU: this._convertAddressMode( texture.wrapS ),\n\t\t\taddressModeV: this._convertAddressMode( texture.wrapT ),\n\t\t\taddressModeW: this._convertAddressMode( texture.wrapR ),\n\t\t\tmagFilter: this._convertFilterMode( texture.magFilter ),\n\t\t\tminFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmipmapFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmaxAnisotropy: 1\n\t\t};\n\n\t\t// anisotropy can only be used when all filter modes are set to linear.\n\n\t\tif ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {\n\n\t\t\tsamplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n\n\t\t}\n\n\t\tif ( texture.isDepthTexture && texture.compareFunction !== null ) {\n\n\t\t\tsamplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];\n\n\t\t}\n\n\t\ttextureGPU.sampler = device.createSampler( samplerDescriptorGPU );\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tlet textureGPU;\n\n\t\tconst format = getFormat( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureGPU = this._getDefaultCubeTextureGPU( format );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tthis.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();\n\n\t\t} else {\n\n\t\t\ttextureGPU = this._getDefaultTextureGPU( format );\n\n\t\t}\n\n\t\tthis.backend.get( texture ).texture = textureGPU;\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t * @return {undefined}\n\t */\n\tcreateTexture( texture, options = {} ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.initialized ) {\n\n\t\t\tthrow new Error( 'WebGPUTextureUtils: Texture already initialized.' );\n\n\t\t}\n\n\t\tif ( options.needsMipmaps === undefined ) options.needsMipmaps = false;\n\t\tif ( options.levels === undefined ) options.levels = 1;\n\t\tif ( options.depth === undefined ) options.depth = 1;\n\n\t\tconst { width, height, depth, levels } = options;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tif ( options.renderTarget ) {\n\n\t\t\t\toptions.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\toptions.format = this.backend.utils.getPreferredCanvasFormat();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst dimension = this._getDimension( texture );\n\t\tconst format = texture.internalFormat || options.format || getFormat( texture, backend.device );\n\n\t\ttextureData.format = format;\n\n\t\tconst { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData( texture );\n\n\t\tlet usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n\n\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\tusage |= GPUTextureUsage.STORAGE_BINDING;\n\n\t\t}\n\n\t\tif ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {\n\n\t\t\tusage |= GPUTextureUsage.RENDER_ATTACHMENT;\n\n\t\t}\n\n\t\tconst textureDescriptorGPU = {\n\t\t\tlabel: texture.name,\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: depth,\n\t\t\t},\n\t\t\tmipLevelCount: levels,\n\t\t\tsampleCount: primarySamples,\n\t\t\tdimension: dimension,\n\t\t\tformat: format,\n\t\t\tusage: usage\n\t\t};\n\n\t\t// texture creation\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\t\t\tconst videoFrame = new VideoFrame( video );\n\n\t\t\ttextureDescriptorGPU.size.width = videoFrame.displayWidth;\n\t\t\ttextureDescriptorGPU.size.height = videoFrame.displayHeight;\n\n\t\t\tvideoFrame.close();\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tif ( format === undefined ) {\n\n\t\t\t\tconsole.warn( 'WebGPURenderer: Texture format not supported.' );\n\n\t\t\t\treturn this.createDefaultTexture( texture );\n\n\t\t\t}\n\n\t\t\ttextureData.texture = backend.device.createTexture( textureDescriptorGPU );\n\n\t\t}\n\n\t\tif ( isMSAA ) {\n\n\t\t\tconst msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );\n\n\t\t\tmsaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n\t\t\tmsaaTextureDescriptorGPU.sampleCount = samples;\n\n\t\t\ttextureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );\n\n\t\t}\n\n\t\ttextureData.initialized = true;\n\n\t\ttextureData.textureDescriptorGPU = textureDescriptorGPU;\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.texture !== undefined ) textureData.texture.destroy();\n\n\t\tif ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tdelete textureData.sampler;\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst depth = texture.image.depth || 1;\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the color buffer representing the color\n\t * attachment of the default framebuffer.\n\t *\n\t * @return {GPUTexture} The color buffer.\n\t */\n\tgetColorBuffer() {\n\n\t\tif ( this.colorBuffer ) this.colorBuffer.destroy();\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tthis.colorBuffer = backend.device.createTexture( {\n\t\t\tlabel: 'colorBuffer',\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t},\n\t\t\tsampleCount: backend.utils.getSampleCount( backend.renderer.samples ),\n\t\t\tformat: backend.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n\t\t} );\n\n\t\treturn this.colorBuffer;\n\n\t}\n\n\t/**\n\t * Returns the depth buffer representing the depth\n\t * attachment of the default framebuffer.\n\t *\n\t * @param {Boolean} [depth=true] - Whether depth is enabled or not.\n\t * @param {Boolean} [stencil=false] -  Whether stencil is enabled or not.\n\t * @return {GPUTexture} The depth buffer.\n\t */\n\tgetDepthBuffer( depth = true, stencil = false ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tconst depthTexture = this.depthTexture;\n\t\tconst depthTextureGPU = backend.get( depthTexture ).texture;\n\n\t\tlet format, type;\n\n\t\tif ( stencil ) {\n\n\t\t\tformat = DepthStencilFormat;\n\t\t\ttype = UnsignedInt248Type;\n\n\t\t} else if ( depth ) {\n\n\t\t\tformat = DepthFormat;\n\t\t\ttype = UnsignedIntType;\n\n\t\t}\n\n\t\tif ( depthTextureGPU !== undefined ) {\n\n\t\t\tif ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {\n\n\t\t\t\treturn depthTextureGPU;\n\n\t\t\t}\n\n\t\t\tthis.destroyTexture( depthTexture );\n\n\t\t}\n\n\t\tdepthTexture.name = 'depthBuffer';\n\t\tdepthTexture.format = format;\n\t\tdepthTexture.type = type;\n\t\tdepthTexture.image.width = width;\n\t\tdepthTexture.image.height = height;\n\n\t\tthis.createTexture( depthTexture, { width, height } );\n\n\t\treturn backend.get( depthTexture ).texture;\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tconst { textureDescriptorGPU } = textureData;\n\n\t\tif ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\t// transfer texture data\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\tfor ( let i = 0; i < options.image.depth; i ++ ) {\n\n\t\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tthis._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tthis._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tthis._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {Number} x - The x coordinate of the copy origin.\n\t * @param {Number} y - The y coordinate of the copy origin.\n\t * @param {Number} width - The width of the copy.\n\t * @param {Number} height - The height of the copy.\n\t * @param {Number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst textureGPU = textureData.texture;\n\t\tconst format = textureData.textureDescriptorGPU.format;\n\t\tconst bytesPerTexel = this._getBytesPerTexel( format );\n\n\t\tlet bytesPerRow = width * bytesPerTexel;\n\t\tbytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes\n\n\t\tconst readBuffer = device.createBuffer(\n\t\t\t{\n\t\t\t\tsize: width * height * bytesPerTexel,\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t}\n\t\t);\n\n\t\tconst encoder = device.createCommandEncoder();\n\n\t\tencoder.copyTextureToBuffer(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\torigin: { x, y, z: faceIndex },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbuffer: readBuffer,\n\t\t\t\tbytesPerRow: bytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t}\n\n\t\t);\n\n\t\tconst typedArrayType = this._getTypedArrayType( format );\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t\tawait readBuffer.mapAsync( GPUMapMode.READ );\n\n\t\tconst buffer = readBuffer.getMappedRange();\n\n\t\treturn new typedArrayType( buffer );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture is an environment map.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @return {Boolean} Whether the given texture is an environment map or not.\n\t */\n\t_isEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t/**\n\t * Returns the default GPU texture for the given format.\n\t *\n\t * @private\n\t * @param {String} format - The GPU format.\n\t * @return {GPUTexture} The GPU texture.\n\t */\n\t_getDefaultTextureGPU( format ) {\n\n\t\tlet defaultTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultTexture === undefined ) {\n\n\t\t\tconst texture = new Texture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, format } );\n\n\t\t\tthis.defaultTexture[ format ] = defaultTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultTexture ).texture;\n\n\t}\n\n\t/**\n\t * Returns the default GPU cube texture for the given format.\n\t *\n\t * @private\n\t * @param {String} format - The GPU format.\n\t * @return {GPUTexture} The GPU texture.\n\t */\n\t_getDefaultCubeTextureGPU( format ) {\n\n\t\tlet defaultCubeTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultCubeTexture === undefined ) {\n\n\t\t\tconst texture = new CubeTexture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, depth: 6 } );\n\n\t\t\tthis.defaultCubeTexture[ format ] = defaultCubeTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultCubeTexture ).texture;\n\n\t}\n\n\t/**\n\t * Returns the default video frame used as default data in context of video textures.\n\t *\n\t * @private\n\t * @return {VideoFrame} The video frame.\n\t */\n\t_getDefaultVideoFrame() {\n\n\t\tlet defaultVideoFrame = this.defaultVideoFrame;\n\n\t\tif ( defaultVideoFrame === null ) {\n\n\t\t\tconst init = {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tcodedWidth: 1,\n\t\t\t\tcodedHeight: 1,\n\t\t\t\tformat: 'RGBA',\n\t\t\t};\n\n\t\t\tthis.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );\n\n\t\t}\n\n\t\treturn defaultVideoFrame;\n\n\t}\n\n\t/**\n\t * Uploads cube texture image data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Array} images - The cube image data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {Boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t */\n\t_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst image = images[ i ];\n\n\t\t\tconst flipIndex = flipY === true ? _flipMap[ i ] : i;\n\n\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uploads texture image data to the GPU memory.\n\t *\n\t * @private\n\t * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {Number} originDepth - The origin depth.\n\t * @param {Boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t */\n\t_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tdevice.queue.copyExternalImageToTexture(\n\t\t\t{\n\t\t\t\tsource: image,\n\t\t\t\tflipY: flipY\n\t\t\t}, {\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t}, {\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t}\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns the pass utils singleton.\n\t *\n\t * @private\n\t * @return {WebGPUTexturePassUtils} The utils instance.\n\t */\n\t_getPassUtils() {\n\n\t\tlet passUtils = this._passUtils;\n\n\t\tif ( passUtils === null ) {\n\n\t\t\tthis._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );\n\n\t\t}\n\n\t\treturn passUtils;\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given GPU texture.\n\t *\n\t * @private\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureDescriptorGPU - The texture descriptor.\n\t * @param {Number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t */\n\t_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {\n\n\t\tthis._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );\n\n\t}\n\n\t/**\n\t * Flip the contents of the given GPU texture along its vertical axis.\n\t *\n\t * @private\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureDescriptorGPU - The texture descriptor.\n\t * @param {Number} [originDepth=0] - The origin depth.\n\t */\n\t_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {\n\n\t\tthis._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t}\n\n\t/**\n\t * Uploads texture buffer data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Object} image - An object defining the image buffer data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {Number} originDepth - The origin depth.\n\t * @param {Boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t * @param {Number} [depth=0] - TODO.\n\t */\n\t_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\t\t// @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n\t\tconst device = this.backend.device;\n\n\t\tconst data = image.data;\n\n\t\tconst bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );\n\t\tconst bytesPerRow = image.width * bytesPerTexel;\n\n\t\tdevice.queue.writeTexture(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t},\n\t\t\tdata,\n\t\t\t{\n\t\t\t\toffset: image.width * image.height * bytesPerTexel * depth,\n\t\t\t\tbytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t} );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uploads compressed texture data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Array<Object>} mipmaps - An array with mipmap data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t */\n\t_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n\t\tconst device = this.backend.device;\n\n\t\tconst blockData = this._getBlockData( textureDescriptorGPU.format );\n\t\tconst isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n\n\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\tconst width = mipmap.width;\n\t\t\tconst height = mipmap.height;\n\t\t\tconst depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n\n\t\t\tconst bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;\n\t\t\tconst bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );\n\n\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\tdevice.queue.writeTexture(\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: textureGPU,\n\t\t\t\t\t\tmipLevel: i,\n\t\t\t\t\t\torigin: { x: 0, y: 0, z: j }\n\t\t\t\t\t},\n\t\t\t\t\tmipmap.data,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: j * bytesPerImage,\n\t\t\t\t\t\tbytesPerRow,\n\t\t\t\t\t\trowsPerImage: Math.ceil( height / blockData.height )\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: Math.ceil( width / blockData.width ) * blockData.width,\n\t\t\t\t\t\theight: Math.ceil( height / blockData.height ) * blockData.height,\n\t\t\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is only relevant for compressed texture formats. It returns a block\n\t * data descriptor for the given GPU compressed texture format.\n\t *\n\t * @private\n\t * @param {String} format - The GPU compressed texture format.\n\t * @return {Object} The block data descriptor.\n\t */\n\t_getBlockData( format ) {\n\n\t\tif ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1\n\t\tif ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3\n\t\tif ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5\n\t\tif ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1\n\t\tif ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2\n\t\tif ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)\n\t\tif ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)\n\n\t\tif ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };\n\n\t\tif ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };\n\n\t}\n\n\t/**\n\t * Converts the three.js uv wrapping constants to GPU address mode constants.\n\t *\n\t * @private\n\t * @param {Number} value - The three.js constant defining a uv wrapping mode.\n\t * @return {String} The GPU address mode.\n\t */\n\t_convertAddressMode( value ) {\n\n\t\tlet addressMode = GPUAddressMode.ClampToEdge;\n\n\t\tif ( value === RepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.Repeat;\n\n\t\t} else if ( value === MirroredRepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.MirrorRepeat;\n\n\t\t}\n\n\t\treturn addressMode;\n\n\t}\n\n\t/**\n\t * Converts the three.js filter constants to GPU filter constants.\n\t *\n\t * @private\n\t * @param {Number} value - The three.js constant defining a filter mode.\n\t * @return {String} The GPU filter mode.\n\t */\n\t_convertFilterMode( value ) {\n\n\t\tlet filterMode = GPUFilterMode.Linear;\n\n\t\tif ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {\n\n\t\t\tfilterMode = GPUFilterMode.Nearest;\n\n\t\t}\n\n\t\treturn filterMode;\n\n\t}\n\n\t/**\n\t * Returns the bytes-per-texel value for the given GPU texture format.\n\t *\n\t * @private\n\t * @param {String} format - The GPU texture format.\n\t * @return {Number} The bytes-per-texel.\n\t */\n\t_getBytesPerTexel( format ) {\n\n\t\t// 8-bit formats\n\t\tif ( format === GPUTextureFormat.R8Unorm ||\n\t\t\tformat === GPUTextureFormat.R8Snorm ||\n\t\t\tformat === GPUTextureFormat.R8Uint ||\n\t\t\tformat === GPUTextureFormat.R8Sint ) return 1;\n\n\t\t// 16-bit formats\n\t\tif ( format === GPUTextureFormat.R16Uint ||\n\t\t\tformat === GPUTextureFormat.R16Sint ||\n\t\t\tformat === GPUTextureFormat.R16Float ||\n\t\t\tformat === GPUTextureFormat.RG8Unorm ||\n\t\t\tformat === GPUTextureFormat.RG8Snorm ||\n\t\t\tformat === GPUTextureFormat.RG8Uint ||\n\t\t\tformat === GPUTextureFormat.RG8Sint ) return 2;\n\n\t\t// 32-bit formats\n\t\tif ( format === GPUTextureFormat.R32Uint ||\n\t\t\tformat === GPUTextureFormat.R32Sint ||\n\t\t\tformat === GPUTextureFormat.R32Float ||\n\t\t\tformat === GPUTextureFormat.RG16Uint ||\n\t\t\tformat === GPUTextureFormat.RG16Sint ||\n\t\t\tformat === GPUTextureFormat.RG16Float ||\n\t\t\tformat === GPUTextureFormat.RGBA8Unorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8UnormSRGB ||\n\t\t\tformat === GPUTextureFormat.RGBA8Snorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA8Sint ||\n\t\t\tformat === GPUTextureFormat.BGRA8Unorm ||\n\t\t\tformat === GPUTextureFormat.BGRA8UnormSRGB ||\n\t\t\t// Packed 32-bit formats\n\t\t\tformat === GPUTextureFormat.RGB9E5UFloat ||\n\t\t\tformat === GPUTextureFormat.RGB10A2Unorm ||\n\t\t\tformat === GPUTextureFormat.RG11B10UFloat ||\n\t\t\tformat === GPUTextureFormat.Depth32Float ||\n\t\t\tformat === GPUTextureFormat.Depth24Plus ||\n\t\t\tformat === GPUTextureFormat.Depth24PlusStencil8 ||\n\t\t\tformat === GPUTextureFormat.Depth32FloatStencil8 ) return 4;\n\n\t\t// 64-bit formats\n\t\tif ( format === GPUTextureFormat.RG32Uint ||\n\t\t\tformat === GPUTextureFormat.RG32Sint ||\n\t\t\tformat === GPUTextureFormat.RG32Float ||\n\t\t\tformat === GPUTextureFormat.RGBA16Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Float ) return 8;\n\n\t\t// 128-bit formats\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Float ) return 16;\n\n\n\t}\n\n\t/**\n\t * Returns the corresponding typed array type for the given GPU texture format.\n\t *\n\t * @private\n\t * @param {String} format - The GPU texture format.\n\t * @return {TypedArray.constructor} The typed array type.\n\t */\n\t_getTypedArrayType( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;\n\n\n\t\tif ( format === GPUTextureFormat.R16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.R16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.R16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;\n\n\n\t\tif ( format === GPUTextureFormat.R32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.R32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.R32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;\n\n\t\tif ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;\n\n\t\tif ( format === GPUTextureFormat.Depth32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;\n\n\t}\n\n\t/**\n\t * Returns the GPU dimensions for the given texture.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @return {String} The GPU dimension.\n\t */\n\t_getDimension( texture ) {\n\n\t\tlet dimension;\n\n\t\tif ( texture.isData3DTexture ) {\n\n\t\t\tdimension = GPUTextureDimension.ThreeD;\n\n\t\t} else {\n\n\t\t\tdimension = GPUTextureDimension.TwoD;\n\n\t\t}\n\n\t\treturn dimension;\n\n\t}\n\n}\n\n/**\n * Returns the GPU format for the given texture.\n *\n * @param {Texture} texture - The texture.\n * @param {GPUDevice?} [device=null] - The GPU device which is used for feature detection.\n * It is not necessary to apply the device for most formats.\n * @return {String} The GPU format.\n */\nfunction getFormat( texture, device = null ) {\n\n\tconst format = texture.format;\n\tconst type = texture.type;\n\tconst colorSpace = texture.colorSpace;\n\n\tlet formatGPU;\n\n\tif ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT3_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGB_ETC2_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAFormat:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t} else {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBAFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Uint;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt5999Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGB9E5UFloat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth16Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24Plus;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthStencilFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt248Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24PlusStencil8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tif ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {\n\n\t\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32FloatStencil8;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t}\n\n\treturn formatGPU;\n\n}\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\n\nconst wgslTypeLib$1 = {\n\t'f32': 'float',\n\t'i32': 'int',\n\t'u32': 'uint',\n\t'bool': 'bool',\n\n\t'vec2<f32>': 'vec2',\n \t'vec2<i32>': 'ivec2',\n \t'vec2<u32>': 'uvec2',\n \t'vec2<bool>': 'bvec2',\n\n\t'vec2f': 'vec2',\n\t'vec2i': 'ivec2',\n\t'vec2u': 'uvec2',\n\t'vec2b': 'bvec2',\n\n\t'vec3<f32>': 'vec3',\n\t'vec3<i32>': 'ivec3',\n\t'vec3<u32>': 'uvec3',\n\t'vec3<bool>': 'bvec3',\n\n\t'vec3f': 'vec3',\n\t'vec3i': 'ivec3',\n\t'vec3u': 'uvec3',\n\t'vec3b': 'bvec3',\n\n\t'vec4<f32>': 'vec4',\n\t'vec4<i32>': 'ivec4',\n\t'vec4<u32>': 'uvec4',\n\t'vec4<bool>': 'bvec4',\n\n\t'vec4f': 'vec4',\n\t'vec4i': 'ivec4',\n\t'vec4u': 'uvec4',\n\t'vec4b': 'bvec4',\n\n\t'mat2x2<f32>': 'mat2',\n\t'mat2x2f': 'mat2',\n\n\t'mat3x3<f32>': 'mat3',\n\t'mat3x3f': 'mat3',\n\n\t'mat4x4<f32>': 'mat4',\n\t'mat4x4f': 'mat4',\n\n\t'sampler': 'sampler',\n\n\t'texture_1d': 'texture',\n\n\t'texture_2d': 'texture',\n\t'texture_2d_array': 'texture',\n\t'texture_multisampled_2d': 'cubeTexture',\n\n\t'texture_depth_2d': 'depthTexture',\n\t'texture_depth_multisampled_2d': 'depthTexture',\n\n\t'texture_3d': 'texture3D',\n\n\t'texture_cube': 'cubeTexture',\n\t'texture_cube_array': 'cubeTexture',\n\n\t'texture_storage_1d': 'storageTexture',\n\t'texture_storage_2d': 'storageTexture',\n\t'texture_storage_2d_array': 'storageTexture',\n\t'texture_storage_3d': 'storageTexture'\n\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\t\tlet match = null;\n\n\t\twhile ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );\n\n\t\t}\n\n\t\t// Process matches to correctly pair names and types\n\t\tconst inputs = [];\n\t\tfor ( let i = 0; i < propsMatches.length; i ++ ) {\n\n\t\t\tconst { name, type } = propsMatches[ i ];\n\n\t\t\tlet resolvedType = type;\n\n\t\t\tif ( resolvedType.startsWith( 'ptr' ) ) {\n\n\t\t\t\tresolvedType = 'pointer';\n\n\t\t\t} else {\n\n\t\t\t\tif ( resolvedType.startsWith( 'texture' ) ) {\n\n\t\t\t\t\tresolvedType = type.split( '<' )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tresolvedType = wgslTypeLib$1[ resolvedType ];\n\n\t\t\t}\n\n\t\t\tinputs.push( new NodeFunctionInput( resolvedType, name ) );\n\n\t\t}\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\t\tconst outputType = declaration[ 3 ] || 'void';\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = wgslTypeLib$1[ outputType ] || outputType;\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\toutputType\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a WSL node function.\n *\n * @augments NodeFunction\n */\nclass WGSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new WGSL node function.\n\t *\n\t * @param {String} source - The WGSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.outputType = outputType;\n\n\t}\n\n\t/**\n\t * This method returns the WGSL code of the node function.\n\t *\n\t * @param {String} [name=this.name] - The function's name.\n\t * @return {String} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tconst outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;\n\n\t}\n\n}\n\n/**\n * A WGSL node parser.\n *\n * @augments NodeParser\n */\nclass WGSLNodeParser extends NodeParser {\n\n\t/**\n\t * The method parses the given WGSL code an returns a node function.\n\t *\n\t * @param {String} source - The WGSL code.\n\t * @return {WGSLNodeFunction} A node function.\n\t */\n\tparseFunction( source ) {\n\n\t\treturn new WGSLNodeFunction( source );\n\n\t}\n\n}\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };\n\nconst accessNames = {\n\t[ NodeAccess.READ_ONLY ]: 'read',\n\t[ NodeAccess.WRITE_ONLY ]: 'write',\n\t[ NodeAccess.READ_WRITE ]: 'read_write'\n};\n\nconst wrapNames = {\n\t[ RepeatWrapping ]: 'repeat',\n\t[ ClampToEdgeWrapping ]: 'clamp',\n\t[ MirroredRepeatWrapping ]: 'mirror'\n};\n\nconst gpuShaderStageLib = {\n\t'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n\t'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n\t'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\n\nconst supports = {\n\tinstance: true,\n\tswizzleAssign: false,\n\tstorageBuffer: true\n};\n\nconst wgslFnOpLib = {\n\t'^^': 'tsl_xor'\n};\n\nconst wgslTypeLib = {\n\tfloat: 'f32',\n\tint: 'i32',\n\tuint: 'u32',\n\tbool: 'bool',\n\tcolor: 'vec3<f32>',\n\n\tvec2: 'vec2<f32>',\n\tivec2: 'vec2<i32>',\n\tuvec2: 'vec2<u32>',\n\tbvec2: 'vec2<bool>',\n\n\tvec3: 'vec3<f32>',\n\tivec3: 'vec3<i32>',\n\tuvec3: 'vec3<u32>',\n\tbvec3: 'vec3<bool>',\n\n\tvec4: 'vec4<f32>',\n\tivec4: 'vec4<i32>',\n\tuvec4: 'vec4<u32>',\n\tbvec4: 'vec4<bool>',\n\n\tmat2: 'mat2x2<f32>',\n\tmat3: 'mat3x3<f32>',\n\tmat4: 'mat4x4<f32>'\n};\n\nconst wgslCodeCache = {};\n\nconst wgslPolyfill = {\n\ttsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),\n\tmod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),\n\tmod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),\n\tmod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),\n\tmod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),\n\tequals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),\n\tequals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),\n\tequals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),\n\tequals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),\n\trepeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),\n\tmirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),\n\tclampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),\n\tbiquadraticTexture: new CodeNode( /* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n` )\n};\n\nconst wgslMethods = {\n\tdFdx: 'dpdx',\n\tdFdy: '- dpdy',\n\tmod_float: 'tsl_mod_float',\n\tmod_vec2: 'tsl_mod_vec2',\n\tmod_vec3: 'tsl_mod_vec3',\n\tmod_vec4: 'tsl_mod_vec4',\n\tequals_bool: 'tsl_equals_bool',\n\tequals_bvec2: 'tsl_equals_bvec2',\n\tequals_bvec3: 'tsl_equals_bvec3',\n\tequals_bvec4: 'tsl_equals_bvec4',\n\tinversesqrt: 'inverseSqrt',\n\tbitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {\n\n\twgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );\n\twgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );\n\n\twgslMethods.pow_float = 'tsl_pow_float';\n\twgslMethods.pow_vec2 = 'tsl_pow_vec2';\n\twgslMethods.pow_vec3 = 'tsl_pow_vec3';\n\twgslMethods.pow_vec4 = 'tsl_pow_vec4';\n\n}\n\n//\n\nlet diagnostics = '';\n\nif ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {\n\n\tdiagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n\n}\n\n/**\n * A node builder targeting WGSL.\n *\n * This module generates WGSL shader code from node materials and also\n * generates the respective bindings and vertex buffer definitions. These\n * data are later used by the renderer to create render and compute pipelines\n * for render objects.\n *\n * @augments NodeBuilder\n */\nclass WGSLNodeBuilder extends NodeBuilder {\n\n\t/**\n\t * Constructs a new WGSL node builder renderer.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new WGSLNodeParser() );\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage ('vertex', 'fragment', 'compute')\n\t\t * another dictionary which manages UBOs per group ('render','frame','object').\n\t\t *\n\t\t * @type {Object<String,Object<String,NodeUniformsGroup>>}\n\t\t */\n\t\tthis.uniformGroups = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Map of builtins.\n\t\t *\n\t\t * @type {Object<String,Map<String,Object>>}\n\t\t */\n\t\tthis.builtins = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Set of directives.\n\t\t *\n\t\t * @type {Object<String,Set<String>>}\n\t\t */\n\t\tthis.directives = {};\n\n\t\t/**\n\t\t * A map for managing scope arrays. Only relevant for when using\n\t\t * {@link module:WorkgroupInfoNode} in context of compute shaders.\n\t\t *\n\t\t * @type {Map<String,Object>}\n\t\t */\n\t\tthis.scopedArrays = new Map();\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {Boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampled textures.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The WGSL snippet.\n\t */\n\t_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;\n\n\t\t\t}\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling video textures.\n\t *\n\t * @private\n\t * @param {String} textureProperty - The name of the video texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The WGSL snippet.\n\t */\n\t_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The WGSL snippet.\n\t */\n\t_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( texture ) === false ) {\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates a wrap function used in context of textures.\n\t *\n\t * @param {Texture} texture - The texture to generate the function for.\n\t * @return {String} The name of the generated function.\n\t */\n\tgenerateWrapFunction( texture ) {\n\n\t\tconst functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }_${texture.isData3DTexture ? '3d' : '2d'}T`;\n\n\t\tlet nodeCode = wgslCodeCache[ functionName ];\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst includes = [];\n\n\t\t\t// For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate\n\t\t\tconst coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';\n\t\t\tlet code = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {\\n\\n\\treturn ${coordType}(\\n`;\n\n\t\t\tconst addWrapSnippet = ( wrap, axis ) => {\n\n\t\t\t\tif ( wrap === RepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.repeatWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_repeatWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === ClampToEdgeWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.clampWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_clampWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === MirroredRepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.mirrorWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_mirrorWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += `\\t\\tcoord.${ axis }`;\n\n\t\t\t\t\tconsole.warn( `WebGPURenderer: Unsupported texture wrap type \"${ wrap }\" for vertex shader.` );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\taddWrapSnippet( texture.wrapS, 'x' );\n\n\t\t\tcode += ',\\n';\n\n\t\t\taddWrapSnippet( texture.wrapT, 'y' );\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tcode += ',\\n';\n\t\t\t\taddWrapSnippet( texture.wrapR, 'z' );\n\n\t\t\t}\n\n\t\t\tcode += '\\n\\t);\\n\\n}\\n';\n\n\t\t\twgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );\n\n\t\t}\n\n\t\tnodeCode.build( this );\n\n\t\treturn functionName;\n\n\t}\n\n\t/**\n\t * Generates the array declaration string.\n\t *\n\t * @param {String} type - The type.\n\t * @param {Number?} [count] - The count.\n\t * @return {String} The generated value as a shader string.\n\t */\n\tgenerateArrayDeclaration( type, count ) {\n\n\t\treturn `array< ${ this.getType( type ) }, ${ count } >`;\n\n\t}\n\n\t/**\n\t * Generates a WGSL variable that holds the texture dimension of the given texture.\n\t * It also returns information about the the number of layers (elements) of an arrayed\n\t * texture as well as the cube face count of cube textures.\n\t *\n\t * @param {Texture} texture - The texture to generate the function for.\n\t * @param {String} textureProperty - The name of the video texture uniform in the shader.\n\t * @param {String} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {String} The name of the dimension variable.\n\t */\n\tgenerateTextureDimension( texture, textureProperty, levelSnippet ) {\n\n\t\tconst textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );\n\n\t\tif ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};\n\n\t\tlet textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];\n\n\t\tif ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {\n\n\t\t\tlet textureDimensionsParams;\n\t\t\tlet dimensionType;\n\n\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\t\t\tconst isMultisampled = primarySamples > 1;\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tdimensionType = 'vec3<u32>';\n\n\t\t\t} else {\n\n\t\t\t\t// Regular 2D textures, depth textures, etc.\n\t\t\t\tdimensionType = 'vec2<u32>';\n\n\t\t\t}\n\n\t\t\t// Build parameters string based on texture type and multisampling\n\t\t\tif ( isMultisampled || texture.isVideoTexture || texture.isStorageTexture ) {\n\n\t\t\t\ttextureDimensionsParams = textureProperty;\n\n\t\t\t} else {\n\n\t\t\t\ttextureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${ levelSnippet } )` : ''}`;\n\n\t\t\t}\n\n\t\t\ttextureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, dimensionType ) );\n\n\t\t\ttextureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;\n\n\t\t\tif ( texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\t\ttextureData.arrayLayerCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode(\n\t\t\t\t\t\t`textureNumLayers(${textureProperty})`,\n\t\t\t\t\t\t'u32'\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// For cube textures, we know it's always 6 faces\n\t\t\tif ( texture.isTextureCube ) {\n\n\t\t\t\ttextureData.cubeFaceCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode( '6u', 'u32' )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureDimensionNode.build( this );\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for a manual filtered texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {\n\n\t\tthis._include( 'biquadraticTexture' );\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\treturn `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.\n\t * Since it's a lookup, no sampling or filtering is applied.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\tconst vecType = texture.isData3DTexture ? 'vec3' : 'vec2';\n\t\tconst coordSnippet = `${vecType}<u32>(${wrapFunction}(${uvSnippet}) * ${vecType}<f32>(${textureDimension}))`;\n\n\t\treturn this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tif ( texture.isVideoTexture === true || texture.isStorageTexture === true ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;\n\n\t\t} else if ( depthSnippet ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet that writes a single texel to a texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} valueSnippet - A WGSL snippet that represent the new texel value.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {\n\n\t\treturn `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;\n\n\t}\n\n\t/**\n\t * Returns `true` if the sampled values of the given texture should be compared against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {Boolean} Whether the sampled values of the given texture should be compared against a reference value or not.\n\t */\n\tisSampleCompare( texture ) {\n\n\t\treturn texture.isDepthTexture === true && texture.compareFunction !== null;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture is unfilterable.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {Boolean} Whether the given texture is unfilterable or not.\n\t */\n\tisUnfilterable( texture ) {\n\n\t\treturn this.getComponentTypeFromTexture( texture ) !== 'float' ||\n\t\t\t( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||\n\t\t\t( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||\n\t\t\tthis.renderer.backend.utils.getTextureSampleData( texture ).primarySamples > 1;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling/loading the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else if ( this.isUnfilterable( texture ) ) {\n\n\t\t\tsnippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {Array<String>} gradSnippet - An array holding both gradient WGSL snippets.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\t// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n\t\t\treturn `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values\n\t * against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} compareSnippet -  A WGSL snippet that represents the reference value.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with a bias to the mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The name of the texture uniform in the shader.\n\t * @param {String} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {String} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.\n\t * @param {String?} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The WGSL snippet.\n\t */\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a WGSL snippet that represents the property name of the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The property name.\n\t */\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\treturn `varyings.${ node.name }`;\n\n\t\t\t}\n\n\t\t} else if ( node.isNodeUniform === true ) {\n\n\t\t\tconst name = node.name;\n\t\t\tconst type = node.type;\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\treturn name;\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tif ( this.isCustomStruct( node ) ) {\n\n\t\t\t\t\treturn name;\n\n\t\t\t\t}\n\n\t\t\t\treturn name + '.value';\n\n\t\t\t} else {\n\n\t\t\t\treturn node.groupNode.name + '.' + name;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.getPropertyName( node );\n\n\t}\n\n\t/**\n\t * Returns the output struct name.\n\t *\n\t * @return {String} The name of the output struct.\n\t */\n\tgetOutputStructName() {\n\n\t\treturn 'output';\n\n\t}\n\n\t/**\n\t * Returns uniforms group count for the given shader stage.\n\t *\n\t * @private\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {Number} The uniforms group count for the given shader stage.\n\t */\n\t_getUniformGroupCount( shaderStage ) {\n\n\t\treturn Object.keys( this.uniforms[ shaderStage ] ).length;\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t *\n\t * @param {String} op - The operator name to resolve.\n\t * @return {String} The resolved operator name.\n\t */\n\tgetFunctionOperator( op ) {\n\n\t\tconst fnOp = wgslFnOpLib[ op ];\n\n\t\tif ( fnOp !== undefined ) {\n\n\t\t\tthis._include( fnOp );\n\n\t\t\treturn fnOp;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the node access for the given node and shader stage.\n\t *\n\t * @param {StorageTextureNode|StorageBufferNode} node - The storage node.\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The node access.\n\t */\n\tgetNodeAccess( node, shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' )\n\t\t\treturn NodeAccess.READ_ONLY;\n\n\t\treturn node.access;\n\n\t}\n\n\t/**\n\t * Returns A WGSL snippet representing the storage access.\n\t *\n\t * @param {StorageTextureNode|StorageBufferNode} node - The storage node.\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The WGSL snippet representing the storage access.\n\t */\n\tgetStorageAccess( node, shaderStage ) {\n\n\t\treturn accessNames[ this.getNodeAccess( node, shaderStage ) ];\n\n\t}\n\n\t/**\n\t * This method is one of the more important ones since it's responsible\n\t * for generating a matching binding instance for the given uniform node.\n\t *\n\t * These bindings are later used in the renderer to create bind groups\n\t * and layouts.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {String} type - The node data type.\n\t * @param {String} shaderStage - The shader stage.\n\t * @param {String?} [name=null] - An optional uniform name.\n\t * @return {NodeUniform} The node uniform object.\n\t */\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tif ( nodeData.uniformGPU === undefined ) {\n\n\t\t\tlet uniformGPU;\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\tlet texture = null;\n\n\t\t\t\tconst access = this.getNodeAccess( node, shaderStage );\n\n\t\t\t\tif ( type === 'texture' || type === 'storageTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.store = node.isStorageTextureNode === true;\n\t\t\t\ttexture.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( node.value ) === false && texture.store === false ) {\n\n\t\t\t\t\tconst sampler = new NodeSampler( `${ uniformNode.name }_sampler`, uniformNode.node, group );\n\t\t\t\t\tsampler.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tbindings.push( sampler, texture );\n\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbindings.push( texture );\n\n\t\t\t\t\tuniformGPU = [ texture ];\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n\n\t\t\t\tconst buffer = new bufferClass( node, group );\n\t\t\t\tbuffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t\tuniformNode.name = name ? name : 'NodeBuffer_' + uniformNode.id;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( groupName, group );\n\t\t\t\t\tuniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\t/**\n\t * This method should be used whenever builtins are required in nodes.\n\t * The internal builtins data structure will make sure builtins are\n\t * defined in the WGSL source.\n\t *\n\t * @param {String} name - The builtin name.\n\t * @param {String} property - The property name.\n\t * @param {String} type - The node data type.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} The property name.\n\t */\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tproperty,\n\t\t\t\ttype\n\t\t\t} );\n\n\t\t}\n\n\t\treturn property;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given builtin is defined in the given shader stage.\n\t *\n\t * @param {String} name - The builtin name.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {String} Whether the given builtin is defined in the given shader stage or not.\n\t */\n\thasBuiltin( name, shaderStage = this.shaderStage ) {\n\n\t\treturn ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );\n\n\t}\n\n\t/**\n\t * Returns the vertex index builtin.\n\t *\n\t * @return {String} The vertex index.\n\t */\n\tgetVertexIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'vertexIndex';\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {String} The WGSL function code.\n\t */\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( input.name + ' : ' + this.getType( input.type ) );\n\n\t\t}\n\n\t\t//\n\n\t\tlet code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {\n${ flowData.vars }\n${ flowData.code }\n`;\n\n\t\tif ( flowData.result ) {\n\n\t\t\tcode += `\\treturn ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tcode += '\\n}\\n';\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Returns the instance index builtin.\n\t *\n\t * @return {String} The instance index.\n\t */\n\tgetInstanceIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'instanceIndex';\n\n\t}\n\n\t/**\n\t * Returns the invocation local index builtin.\n\t *\n\t * @return {String} The invocation local index.\n\t */\n\tgetInvocationLocalIndex() {\n\n\t\treturn this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the subgroup size builtin.\n\t *\n\t * @return {String} The subgroup size.\n\t */\n\tgetSubgroupSize() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the invocation subgroup index builtin.\n\t *\n\t * @return {String} The invocation subgroup index.\n\t */\n\tgetInvocationSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the subgroup index builtin.\n\t *\n\t * @return {String} The subgroup index.\n\t */\n\tgetSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Overwritten as a NOP since this method is intended for the WebGL 2 backend.\n\t *\n\t * @return {null} Null.\n\t */\n\tgetDrawIndex() {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the front facing builtin.\n\t *\n\t * @return {String} The front facing builtin.\n\t */\n\tgetFrontFacing() {\n\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\n\n\t}\n\n\t/**\n\t * Returns the frag coord builtin.\n\t *\n\t * @return {String} The frag coord builtin.\n\t */\n\tgetFragCoord() {\n\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';\n\n\t}\n\n\t/**\n\t * Returns the frag depth builtin.\n\t *\n\t * @return {String} The frag depth builtin.\n\t */\n\tgetFragDepth() {\n\n\t\treturn 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );\n\n\t}\n\n\t/**\n\t * Returns the clip distances builtin.\n\t *\n\t * @return {String} The clip distances builtin.\n\t */\n\tgetClipDistance() {\n\n\t\treturn 'varyings.hw_clip_distances';\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not.\n\t *\n\t * @return {Boolean} Returns always `false` in context of WGSL.\n\t */\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Enables the given directive for the given shader stage.\n\t *\n\t * @param {String} name - The directive name.\n\t * @param {String} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.\n\t */\n\tenableDirective( name, shaderStage = this.shaderStage ) {\n\n\t\tconst stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );\n\t\tstage.add( name );\n\n\t}\n\n\t/**\n\t * Returns the directives of the given shader stage as a WGSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} A WGSL snippet that enables the directives of the given stage.\n\t */\n\tgetDirectives( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst directives = this.directives[ shaderStage ];\n\n\t\tif ( directives !== undefined ) {\n\n\t\t\tfor ( const directive of directives ) {\n\n\t\t\t\tsnippets.push( `enable ${directive};` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Enables the 'subgroups' directive.\n\t */\n\tenableSubGroups() {\n\n\t\tthis.enableDirective( 'subgroups' );\n\n\t}\n\n\t/**\n\t * Enables the 'subgroups-f16' directive.\n\t */\n\tenableSubgroupsF16() {\n\n\t\tthis.enableDirective( 'subgroups-f16' );\n\n\t}\n\n\t/**\n\t * Enables the 'clip_distances' directive.\n\t */\n\tenableClipDistances() {\n\n\t\tthis.enableDirective( 'clip_distances' );\n\n\t}\n\n\t/**\n\t * Enables the 'f16' directive.\n\t */\n\tenableShaderF16() {\n\n\t\tthis.enableDirective( 'f16' );\n\n\t}\n\n\t/**\n\t * Enables the 'dual_source_blending' directive.\n\t */\n\tenableDualSourceBlending() {\n\n\t\tthis.enableDirective( 'dual_source_blending' );\n\n\t}\n\n\t/**\n\t * Enables hardware clipping.\n\t *\n\t * @param {String} planeCount - The clipping plane count.\n\t */\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableClipDistances();\n\t\tthis.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );\n\n\t}\n\n\t/**\n\t * Returns the builtins of the given shader stage as a WGSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} A WGSL snippet that represents the builtins of the given stage.\n\t */\n\tgetBuiltins( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst builtins = this.builtins[ shaderStage ];\n\n\t\tif ( builtins !== undefined ) {\n\n\t\t\tfor ( const { name, property, type } of builtins.values() ) {\n\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\t/**\n\t * This method should be used when a new scoped buffer is used in context of\n\t * compute shaders. It adds the array to the internal data structure which is\n\t * later used to generate the respective WGSL.\n\t *\n\t * @param {String} name - The array name.\n\t * @param {String} scope - The scope.\n\t * @param {String} bufferType - The buffer type.\n\t * @param {String} bufferCount - The buffer count.\n\t * @return {String} The array name.\n\t */\n\tgetScopedArray( name, scope, bufferType, bufferCount ) {\n\n\t\tif ( this.scopedArrays.has( name ) === false ) {\n\n\t\t\tthis.scopedArrays.set( name, {\n\t\t\t\tname,\n\t\t\t\tscope,\n\t\t\t\tbufferType,\n\t\t\t\tbufferCount\n\t\t\t} );\n\n\t\t}\n\n\t\treturn name;\n\n\t}\n\n\t/**\n\t * Returns the scoped arrays of the given shader stage as a WGSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String|undefined} The WGSL snippet that defines the scoped arrays.\n\t * Returns `undefined` when used in the vertex or fragment stage.\n\t */\n\tgetScopedArrays( shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst snippets = [];\n\n\t\tfor ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {\n\n\t\t\tconst type = this.getType( bufferType );\n\n\t\t\tsnippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the shader attributes of the given shader stage as a WGSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The WGSL snippet that defines the shader attributes.\n\t */\n\tgetAttributes( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'globalId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );\n\n\t\t\tif ( this.renderer.hasFeature( 'subgroups' ) ) {\n\n\t\t\t\tthis.enableDirective( 'subgroups', shaderStage );\n\t\t\t\tthis.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst builtins = this.getBuiltins( 'attribute' );\n\n\t\t\tif ( builtins ) snippets.push( builtins );\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\n\n\t\t\t\tconst attribute = attributes[ index ];\n\t\t\t\tconst name = attribute.name;\n\t\t\t\tconst type = this.getType( attribute.type );\n\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\t/**\n\t * Returns the members of the given struct type node as a WGSL string.\n\t *\n\t * @param {StructTypeNode} struct - The struct type node.\n\t * @return {String} The WGSL snippet that defines the struct members.\n\t */\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of struct.members ) {\n\n\t\t\tconst prefix = struct.output ? '@location( ' + member.index + ' ) ' : '';\n\n\t\t\tlet type = this.getType( member.type );\n\n\t\t\tif ( member.atomic ) {\n\n\t\t\t\ttype = 'atomic< ' + type + ' >';\n\n\t\t\t}\n\n\t\t\tsnippets.push( `\\t${ prefix + member.name } : ${ type }` );\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n' );\n\n\t}\n\n\t/**\n\t * Returns the structs of the given shader stage as a WGSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The WGSL snippet that defines the structs.\n\t */\n\tgetStructs( shaderStage ) {\n\n\t\tlet result = '';\n\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tif ( structs.length > 0 ) {\n\n\t\t\tconst snippets = [];\n\n\t\t\tfor ( const struct of structs ) {\n\n\t\t\t\tlet snippet = `struct ${ struct.name } {\\n`;\n\t\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\t\tsnippet += '\\n};';\n\n\t\t\t\tsnippets.push( snippet );\n\n\t\t\t}\n\n\t\t\tresult = '\\n' + snippets.join( '\\n\\n' ) + '\\n';\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns a WGSL string representing a variable.\n\t *\n\t * @param {String} type - The variable's type.\n\t * @param {String} name - The variable's name.\n\t * @param {Number?} [count=null] - The array length.\n\t * @return {String} The WGSL snippet that defines a variable.\n\t */\n\tgetVar( type, name, count = null ) {\n\n\t\tlet snippet = `var ${ name } : `;\n\n\t\tif ( count !== null ) {\n\n\t\t\tsnippet += this.generateArrayDeclaration( type, count );\n\n\t\t} else {\n\n\t\t\tsnippet += this.getType( type );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the variables of the given shader stage as a WGSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The WGSL snippet that defines the variables.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name, variable.count ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\n\n\t}\n\n\t/**\n\t * Returns the varyings of the given shader stage as a WGSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The WGSL snippet that defines the varyings.\n\t */\n\tgetVaryings( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst vars = this.vars[ shaderStage ];\n\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\n\n\t\t\t\tconst varying = varyings[ index ];\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\n\n\t\t\t\t\tif ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {\n\n\t\t\t\t\t\tattributesSnippet += ' @interpolate( flat )';\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\n\n\t\t\t\t} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {\n\n\t\t\t\t\tvars.push( varying );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( shaderStage );\n\n\t\tif ( builtins ) snippets.push( builtins );\n\n\t\tconst code = snippets.join( ',\\n\\t' );\n\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\\t' + code ) : code;\n\n\t}\n\n\tisCustomStruct( nodeUniform ) {\n\n\t\treturn nodeUniform.value.isStorageBufferAttribute && nodeUniform.node.structTypeNode !== null;\n\n\t}\n\n\t/**\n\t * Returns the uniforms of the given shader stage as a WGSL string.\n\t *\n\t * @param {String} shaderStage - The shader stage.\n\t * @return {String} The WGSL snippet that defines the uniforms.\n\t */\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst bufferSnippets = [];\n\t\tconst structSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\tconst uniformIndexes = this.bindingsIndexes[ groupName ];\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {\n\n\t\t\t\t\tif ( this.isSampleCompare( texture ) ) {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet textureType;\n\n\t\t\t\tlet multisampled = '';\n\n\t\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\tmultisampled = '_multisampled';\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_2d_array<f32>';\n\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\n\n\t\t\t\t\ttextureType = `texture_depth${multisampled}_2d`;\n\n\t\t\t\t} else if ( texture.isVideoTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_external';\n\n\t\t\t\t} else if ( texture.isData3DTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_3d<f32>';\n\n\t\t\t\t} else if ( uniform.node.isStorageTextureNode === true ) {\n\n\t\t\t\t\tconst format = getFormat( texture );\n\t\t\t\t\tconst access = this.getStorageAccess( uniform.node, shaderStage );\n\n\t\t\t\t\ttextureType = `texture_storage_2d<${ format }, ${ access }>`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );\n\n\t\t\t\t\ttextureType = `texture${ multisampled }_2d<${ componentPrefix }32>`;\n\n\t\t\t\t}\n\n\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );\n\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.getNodeType( this ) );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';\n\n\t\t\t\tif ( this.isCustomStruct( uniform ) ) {\n\n\t\t\t\t\tbufferSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var<${ bufferAccessMode }> ${ uniform.name } : ${ bufferType };` );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${ bufferType }>` : `${ bufferType }`;\n\t\t\t\t\tconst bufferSnippet = `\\tvalue : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >`;\n\n\t\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( uniform.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\n\t\t\t\tconst group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {\n\t\t\t\t\tindex: uniformIndexes.binding ++,\n\t\t\t\t\tid: uniformIndexes.group,\n\t\t\t\t\tsnippets: []\n\t\t\t\t} );\n\n\t\t\t\tgroup.snippets.push( `\\t${ uniform.name } : ${ vectorType }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst group = uniformGroups[ name ];\n\n\t\t\tstructSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\\n' ), 'uniform', group.index, group.id ) );\n\n\t\t}\n\n\t\tlet code = bindingSnippets.join( '\\n' );\n\t\tcode += bufferSnippets.join( '\\n' );\n\t\tcode += structSnippets.join( '\\n' );\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t */\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tthis.shaderStage = shaderStage;\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.directives = this.getDirectives( shaderStage );\n\t\t\tstageData.scopedArrays = this.getScopedArrays( shaderStage );\n\n\t\t\t//\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tconst outputNode = mainNode.outputNode;\n\t\t\tconst isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += `varyings.Vertex = ${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( isOutputStruct ) {\n\n\t\t\t\t\t\t\tstageData.returnType = outputNode.getNodeType( this );\n\t\t\t\t\t\t\tstageData.structs += 'var<private> output : ' + stageData.returnType + ';';\n\n\t\t\t\t\t\t\tflow += `return ${ flowSlotData.result };`;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet structSnippet = '\\t@location(0) color: vec4<f32>';\n\n\t\t\t\t\t\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\t\t\t\t\t\tif ( builtins ) structSnippet += ',\\n\\t' + builtins;\n\n\t\t\t\t\t\t\tstageData.returnType = 'OutputStruct';\n\t\t\t\t\t\t\tstageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );\n\t\t\t\t\t\t\tstageData.structs += '\\nvar<private> output : OutputStruct;';\n\n\t\t\t\t\t\t\tflow += `output.color = ${ flowSlotData.result };\\n\\n\\treturn output;`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tthis.shaderStage = null;\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @param {String} method - The method name to resolve.\n\t * @param {String} [output=null] - An optional output.\n\t * @return {String} The resolved WGSL method name.\n\t */\n\tgetMethod( method, output = null ) {\n\n\t\tlet wgslMethod;\n\n\t\tif ( output !== null ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method + '_' + output );\n\n\t\t}\n\n\t\tif ( wgslMethod === undefined ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method );\n\n\t\t}\n\n\t\treturn wgslMethod || method;\n\n\t}\n\n\t/**\n\t * Returns the WGSL type of the given node data type.\n\t *\n\t * @param {String} type - The node data type.\n\t * @return {String} The WGSL type.\n\t */\n\tgetType( type ) {\n\n\t\treturn wgslTypeLib[ type ] || type;\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @param {String} name - The requested feature.\n\t * @return {Boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tif ( name === 'float32Filterable' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'float32-filterable' );\n\n\t\t\t} else if ( name === 'clipDistance' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'clip-distances' );\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @private\n\t * @param {String} method - The method name to resolve.\n\t * @return {String} The resolved WGSL method name.\n\t */\n\t_getWGSLMethod( method ) {\n\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn wgslMethods[ method ];\n\n\t}\n\n\t/**\n\t * Includes the given method name into the current\n\t * function node.\n\t *\n\t * @private\n\t * @param {String} name - The method name to include.\n\t * @return {CodeNode} The respective code node.\n\t */\n\t_include( name ) {\n\n\t\tconst codeNode = wgslPolyfill[ name ];\n\t\tcodeNode.build( this );\n\n\t\tif ( this.currentFunctionNode !== null ) {\n\n\t\t\tthis.currentFunctionNode.includes.push( codeNode );\n\n\t\t}\n\n\t\treturn codeNode;\n\n\t}\n\n\t/**\n\t * Returns a WGSL vertex shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {String} The vertex shader.\n\t */\n\t_getWGSLVertexCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL fragment shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {String} The vertex shader.\n\t */\n\t_getWGSLFragmentCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// global\n${ diagnostics }\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL compute shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @param {String} workgroupSize - The workgroup size.\n\t * @return {String} The vertex shader.\n\t */\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = globalId.x + globalId.y * numWorkgroups.x * u32(${workgroupSize}) + globalId.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL struct based on the given name and variables.\n\t *\n\t * @private\n\t * @param {String} name - The struct name.\n\t * @param {String} vars - The struct variables.\n\t * @return {String} The WGSL snippet representing a struct.\n\t */\n\t_getWGSLStruct( name, vars ) {\n\n\t\treturn `\nstruct ${name} {\n${vars}\n};`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL struct binding.\n\t *\n\t * @private\n\t * @param {String} name - The struct name.\n\t * @param {String} vars - The struct variables.\n\t * @param {String} access - The access.\n\t * @param {Number} [binding=0] - The binding index.\n\t * @param {Number} [group=0] - The group index.\n\t * @return {String} The WGSL snippet representing a struct binding.\n\t */\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\n\n\t\tconst structName = name + 'Struct';\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\n\n\t\treturn `${structSnippet}\n@binding( ${ binding } ) @group( ${ group } )\nvar<${access}> ${ name } : ${ structName };`;\n\n\t}\n\n}\n\n/**\n * A WebGPU backend utility module with common helpers.\n *\n * @private\n */\nclass WebGPUUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Returns the depth/stencil GPU format for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {String} The depth/stencil GPU texture format.\n\t */\n\tgetCurrentDepthStencilFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.depthTexture !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.depthTexture );\n\n\t\t} else if ( renderContext.depth && renderContext.stencil ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24PlusStencil8;\n\n\t\t} else if ( renderContext.depth ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24Plus;\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t/**\n\t * Returns the GPU format for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {String} The GPU texture format.\n\t */\n\tgetTextureFormatGPU( texture ) {\n\n\t\treturn this.backend.get( texture ).format;\n\n\t}\n\n\t/**\n\t * Returns an object that defines the multi-sampling state of the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {Object} The multi-sampling state.\n\t */\n\tgetTextureSampleData( texture ) {\n\n\t\tlet samples;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tsamples = 1;\n\n\t\t} else if ( texture.isDepthTexture && ! texture.renderTarget ) {\n\n\t\t\tconst renderer = this.backend.renderer;\n\t\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t\tsamples = renderTarget ? renderTarget.samples : renderer.samples;\n\n\t\t} else if ( texture.renderTarget ) {\n\n\t\t\tsamples = texture.renderTarget.samples;\n\n\t\t}\n\n\t\tsamples = samples || 1;\n\n\t\tconst isMSAA = samples > 1 && texture.renderTarget !== null && ( texture.isDepthTexture !== true && texture.isFramebufferTexture !== true );\n\t\tconst primarySamples = isMSAA ? 1 : samples;\n\n\t\treturn { samples, primarySamples, isMSAA };\n\n\t}\n\n\t/**\n\t * Returns the default color attachment's GPU format of the current render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {String} The GPU texture format of the default color attachment.\n\t */\n\tgetCurrentColorFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.textures[ 0 ] );\n\n\t\t} else {\n\n\t\t\tformat = this.getPreferredCanvasFormat(); // default context format\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t/**\n\t * Returns the output color space of the current render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {String} The output color space.\n\t */\n\tgetCurrentColorSpace( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn renderContext.textures[ 0 ].colorSpace;\n\n\t\t}\n\n\t\treturn this.backend.renderer.outputColorSpace;\n\n\t}\n\n\t/**\n\t * Returns GPU primitive topology for the given object and material.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The material.\n\t * @return {String} The GPU primitive topology.\n\t */\n\tgetPrimitiveTopology( object, material ) {\n\n\t\tif ( object.isPoints ) return GPUPrimitiveTopology.PointList;\n\t\telse if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;\n\t\telse if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;\n\t\telse if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;\n\n\t}\n\n\t/**\n\t * Returns a modified sample count from the given sample count value.\n\t *\n\t * That is required since WebGPU does not support arbitrary sample counts.\n\t *\n\t * @param {Number} sampleCount - The input sample count.\n\t * @return {Number} The (potentially updated) output sample count.\n\t */\n\tgetSampleCount( sampleCount ) {\n\n\t\tlet count = 1;\n\n\t\tif ( sampleCount > 1 ) {\n\n\t\t\t// WebGPU only supports power-of-two sample counts and 2 is not a valid value\n\t\t\tcount = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );\n\n\t\t\tif ( count === 2 ) {\n\n\t\t\t\tcount = 4;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t/**\n\t * Returns the sample count of the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {Number} The sample count.\n\t */\n\tgetSampleCountRenderContext( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn this.getSampleCount( renderContext.sampleCount );\n\n\t\t}\n\n\t\treturn this.getSampleCount( this.backend.renderer.samples );\n\n\t}\n\n\t/**\n\t * Returns the preferred canvas format.\n\t *\n\t * There is a separate method for this so it's possible to\n\t * honor edge cases for specific devices.\n\t *\n\t * @return {String} The GPU texture format of the canvas.\n\t */\n\tgetPreferredCanvasFormat() {\n\n\t\tconst outputType = this.backend.parameters.outputType;\n\n\t\tif ( outputType === undefined ) {\n\n\t\t\treturn navigator.gpu.getPreferredCanvasFormat();\n\n\t\t} else if ( outputType === UnsignedByteType ) {\n\n\t\t\treturn GPUTextureFormat.BGRA8Unorm;\n\n\t\t} else if ( outputType === HalfFloatType ) {\n\n\t\t\treturn GPUTextureFormat.RGBA16Float;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unsupported outputType' );\n\n\t\t}\n\n\t}\n\n}\n\nconst typedArraysToVertexFormatPrefix = new Map( [\n\t[ Int8Array, [ 'sint8', 'snorm8' ]],\n\t[ Uint8Array, [ 'uint8', 'unorm8' ]],\n\t[ Int16Array, [ 'sint16', 'snorm16' ]],\n\t[ Uint16Array, [ 'uint16', 'unorm16' ]],\n\t[ Int32Array, [ 'sint32', 'snorm32' ]],\n\t[ Uint32Array, [ 'uint32', 'unorm32' ]],\n\t[ Float32Array, [ 'float32', ]],\n] );\n\nconst typedAttributeToVertexFormatPrefix = new Map( [\n\t[ Float16BufferAttribute, [ 'float16', ]],\n] );\n\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map( [\n\t[ Int32Array, 'sint32' ],\n\t[ Int16Array, 'sint32' ], // patch for INT16\n\t[ Uint32Array, 'uint32' ],\n\t[ Uint16Array, 'uint32' ], // patch for UINT16\n\t[ Float32Array, 'float32' ]\n] );\n\n/**\n * A WebGPU backend utility module for managing shader attributes.\n *\n * @private\n */\nclass WebGPUAttributeUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer for the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.\n\t */\n\tcreateAttribute( attribute, usage ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet buffer = bufferData.buffer;\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tconst device = backend.device;\n\n\t\t\tlet array = bufferAttribute.array;\n\n\t\t\t// patch for INT16 and UINT16\n\t\t\tif ( attribute.normalized === false ) {\n\n\t\t\t\tif ( array.constructor === Int16Array ) {\n\n\t\t\t\t\tarray = new Int32Array( array );\n\n\t\t\t\t} else if ( array.constructor === Uint16Array ) {\n\n\t\t\t\t\tarray = new Uint32Array( array );\n\n\t\t\t\t\tif ( usage & GPUBufferUsage.INDEX ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( array[ i ] === 0xffff ) array[ i ] = 0xffffffff; // use correct primitive restart index\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbufferAttribute.array = array;\n\n\t\t\tif ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {\n\n\t\t\t\tarray = new array.constructor( bufferAttribute.count * 4 );\n\n\t\t\t\tfor ( let i = 0; i < bufferAttribute.count; i ++ ) {\n\n\t\t\t\t\tarray.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );\n\n\t\t\t\t}\n\n\t\t\t\t// Update BufferAttribute\n\t\t\t\tbufferAttribute.itemSize = 4;\n\t\t\t\tbufferAttribute.array = array;\n\n\t\t\t}\n\n\t\t\tconst size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441\n\n\t\t\tbuffer = device.createBuffer( {\n\t\t\t\tlabel: bufferAttribute.name,\n\t\t\t\tsize: size,\n\t\t\t\tusage: usage,\n\t\t\t\tmappedAtCreation: true\n\t\t\t} );\n\n\t\t\tnew array.constructor( buffer.getMappedRange() ).set( array );\n\n\t\t\tbuffer.unmap();\n\n\t\t\tbufferData.buffer = buffer;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = backend.get( bufferAttribute ).buffer;\n\n\t\tconst array = bufferAttribute.array;\n\t\tconst isTypedArray = this._isTypedArray( array );\n\t\tconst updateRanges = bufferAttribute.updateRanges;\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tdevice.queue.writeBuffer(\n\t\t\t\tbuffer,\n\t\t\t\t0,\n\t\t\t\tarray,\n\t\t\t\t0\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tconst byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\tconst dataOffset = range.start * byteOffsetFactor;\n\t\t\t\tconst size = range.count * byteOffsetFactor;\n\n\t\t\t\tdevice.queue.writeBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\t0,\n\t\t\t\t\tarray,\n\t\t\t\t\tdataOffset,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method creates the vertex buffer layout data which are\n\t * require when creating a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.\n\t */\n\tcreateShaderVertexBuffers( renderObject ) {\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst vertexBuffers = new Map();\n\n\t\tfor ( let slot = 0; slot < attributes.length; slot ++ ) {\n\n\t\t\tconst geometryAttribute = attributes[ slot ];\n\t\t\tconst bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n\t\t\tconst bufferAttribute = this._getBufferAttribute( geometryAttribute );\n\n\t\t\tlet vertexBufferLayout = vertexBuffers.get( bufferAttribute );\n\n\t\t\tif ( vertexBufferLayout === undefined ) {\n\n\t\t\t\tlet arrayStride, stepMode;\n\n\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\t\tarrayStride = geometryAttribute.data.stride * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarrayStride = geometryAttribute.itemSize * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t}\n\n\t\t\t\t// patch for INT16 and UINT16\n\t\t\t\tif ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {\n\n\t\t\t\t\tarrayStride = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvertexBufferLayout = {\n\t\t\t\t\tarrayStride,\n\t\t\t\t\tattributes: [],\n\t\t\t\t\tstepMode\n\t\t\t\t};\n\n\t\t\t\tvertexBuffers.set( bufferAttribute, vertexBufferLayout );\n\n\t\t\t}\n\n\t\t\tconst format = this._getVertexFormat( geometryAttribute );\n\t\t\tconst offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;\n\n\t\t\tvertexBufferLayout.attributes.push( {\n\t\t\t\tshaderLocation: slot,\n\t\t\t\toffset,\n\t\t\t\tformat\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Array.from( vertexBuffers.values() );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tdata.buffer.destroy();\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\t\tconst bufferGPU = data.buffer;\n\t\tconst size = bufferGPU.size;\n\n\t\tconst readBufferGPU = device.createBuffer( {\n\t\t\tlabel: `${ attribute.name }_readback`,\n\t\t\tsize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\t\tconst cmdEncoder = device.createCommandEncoder( {\n\t\t\tlabel: `readback_encoder_${ attribute.name }`\n\t\t} );\n\n\t\tcmdEncoder.copyBufferToBuffer(\n\t\t\tbufferGPU,\n\t\t\t0,\n\t\t\treadBufferGPU,\n\t\t\t0,\n\t\t\tsize\n\t\t);\n\n\t\tconst gpuCommands = cmdEncoder.finish();\n\t\tdevice.queue.submit( [ gpuCommands ] );\n\n\t\tawait readBufferGPU.mapAsync( GPUMapMode.READ );\n\n\t\tconst arrayBuffer = readBufferGPU.getMappedRange();\n\n\t\tconst dstBuffer = new attribute.array.constructor( arrayBuffer.slice( 0 ) );\n\n\t\treadBufferGPU.unmap();\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t/**\n\t * Returns the vertex format of the given buffer attribute.\n\t *\n\t * @private\n\t * @param {BufferAttribute} geometryAttribute - The buffer attribute.\n\t * @return {String} The vertex format (e.g. 'float32x3').\n\t */\n\t_getVertexFormat( geometryAttribute ) {\n\n\t\tconst { itemSize, normalized } = geometryAttribute;\n\t\tconst ArrayType = geometryAttribute.array.constructor;\n\t\tconst AttributeType = geometryAttribute.constructor;\n\n\t\tlet format;\n\n\t\tif ( itemSize === 1 ) {\n\n\t\t\tformat = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );\n\n\t\t} else {\n\n\t\t\tconst prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );\n\t\t\tconst prefix = prefixOptions[ normalized ? 1 : 0 ];\n\n\t\t\tif ( prefix ) {\n\n\t\t\t\tconst bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n\t\t\t\tconst paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;\n\t\t\t\tconst paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n\n\t\t\t\tif ( paddedItemSize % 1 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );\n\n\t\t\t\t}\n\n\t\t\t\tformat = `${prefix}x${paddedItemSize}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! format ) {\n\n\t\t\tconsole.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given array is a typed array.\n\t *\n\t * @private\n\t * @param {Any} array - The array.\n\t * @return {Boolean} Whether the given array is a typed array or not.\n\t */\n\t_isTypedArray( array ) {\n\n\t\treturn ArrayBuffer.isView( array ) && ! ( array instanceof DataView );\n\n\t}\n\n\t/**\n\t * Utility method for handling interleaved buffer attributes correctly.\n\t * To process them, their `InterleavedBuffer` is returned.\n\t *\n\t * @private\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {BufferAttribute|InterleavedBuffer}\n\t */\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\n/**\n * A WebGPU backend utility module for managing bindings.\n *\n * When reading the documentation it's helpful to keep in mind that\n * all class definitions starting with 'GPU*' are modules from the\n * WebGPU API. So for example `BindGroup` is a class from the engine\n * whereas `GPUBindGroup` is a class from WebGPU.\n *\n * @private\n */\nclass WebGPUBindingUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A cache for managing bind group layouts.\n\t\t *\n\t\t * @type {WeakMap<Array<Binding>,GPUBindGroupLayout>}\n\t\t */\n\t\tthis.bindGroupLayoutCache = new WeakMap();\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group layout for the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @return {GPUBindGroupLayout} The GPU bind group layout.\n\t */\n\tcreateBindingsLayout( bindGroup ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst entries = [];\n\n\t\tlet index = 0;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tconst bindingGPU = {\n\t\t\t\tbinding: index ++,\n\t\t\t\tvisibility: binding.visibility\n\t\t\t};\n\n\t\t\tif ( binding.isUniformBuffer || binding.isStorageBuffer ) {\n\n\t\t\t\tconst buffer = {}; // GPUBufferBindingLayout\n\n\t\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\t\tif ( binding.visibility & 4 ) {\n\n\t\t\t\t\t\t// compute\n\n\t\t\t\t\t\tif ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.Storage;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.buffer = buffer;\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst sampler = {}; // GPUSamplerBindingLayout\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( binding.texture.compareFunction !== null ) {\n\n\t\t\t\t\t\tsampler.type = 'comparison';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.sampler = sampler;\n\n\t\t\t} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {\n\n\t\t\t\tbindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n\n\t\t\t} else if ( binding.isSampledTexture && binding.store ) {\n\n\t\t\t\tconst storageTexture = {}; // GPUStorageTextureBindingLayout\n\t\t\t\tstorageTexture.format = this.backend.get( binding.texture ).texture.format;\n\n\t\t\t\tconst access = binding.access;\n\n\t\t\t\tif ( access === NodeAccess.READ_WRITE ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadWrite;\n\n\t\t\t\t} else if ( access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.WriteOnly;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadOnly;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.storageTexture = storageTexture;\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texture = {}; // GPUTextureBindingLayout\n\n\t\t\t\tconst { primarySamples } = backend.utils.getTextureSampleData( binding.texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\ttexture.multisampled = true;\n\n\t\t\t\t\tif ( ! binding.texture.isDepthTexture ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Depth;\n\n\t\t\t\t} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {\n\n\t\t\t\t\tconst type = binding.texture.type;\n\n\t\t\t\t\tif ( type === IntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.SInt;\n\n\t\t\t\t\t} else if ( type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UInt;\n\n\t\t\t\t\t} else if ( type === FloatType ) {\n\n\t\t\t\t\t\tif ( this.backend.hasFeature( 'float32-filterable' ) ) {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Float;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.Cube;\n\n\t\t\t\t} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.texture = texture;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( `WebGPUBindingUtils: Unsupported binding \"${ binding }\".` );\n\n\t\t\t}\n\n\t\t\tentries.push( bindingGPU );\n\n\t\t}\n\n\t\treturn device.createBindGroupLayout( { entries } );\n\n\t}\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings, cacheIndex, version = 0 ) {\n\n\t\tconst { backend, bindGroupLayoutCache } = this;\n\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t// setup (static) binding layout and (dynamic) binding group\n\n\t\tlet bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );\n\n\t\tif ( bindLayoutGPU === undefined ) {\n\n\t\t\tbindLayoutGPU = this.createBindingsLayout( bindGroup );\n\t\t\tbindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );\n\n\t\t}\n\n\t\tlet bindGroupGPU;\n\n\t\tif ( cacheIndex > 0 ) {\n\n\t\t\tif ( bindingsData.groups === undefined ) {\n\n\t\t\t\tbindingsData.groups = [];\n\t\t\t\tbindingsData.versions = [];\n\n\t\t\t}\n\n\t\t\tif ( bindingsData.versions[ cacheIndex ] === version ) {\n\n\t\t\t\tbindGroupGPU = bindingsData.groups[ cacheIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bindGroupGPU === undefined ) {\n\n\t\t\tbindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );\n\n\t\t\tif ( cacheIndex > 0 ) {\n\n\t\t\t\tbindingsData.groups[ cacheIndex ] = bindGroupGPU;\n\t\t\t\tbindingsData.versions[ cacheIndex ] = version;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbindingsData.group = bindGroupGPU;\n\t\tbindingsData.layout = bindLayoutGPU;\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = binding.buffer;\n\t\tconst bufferGPU = backend.get( binding ).buffer;\n\n\t\tdevice.queue.writeBuffer( bufferGPU, 0, buffer, 0 );\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group for the camera index.\n\t *\n\t * @param {Uint32Array} data - The index data.\n\t * @param {GPUBindGroupLayout} layout - The GPU bind group layout.\n\t * @return {GPUBindGroup} The GPU bind group.\n\t */\n\tcreateBindGroupIndex( data, layout ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\t\tconst index = data[ 0 ];\n\n\t\tconst buffer = device.createBuffer( {\n\t\t\tlabel: 'bindingCameraIndex_' + index,\n\t\t\tsize: 16, // uint(4) * 4\n\t\t\tusage: usage\n\t\t} );\n\n\t\tdevice.queue.writeBuffer( buffer, 0, data, 0 );\n\n\t\tconst entries = [ { binding: 0, resource: { buffer } } ];\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroupCameraIndex_' + index,\n\t\t\tlayout,\n\t\t\tentries\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group for the given bind group and GPU layout.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.\n\t * @return {GPUBindGroup} The GPU bind group.\n\t */\n\tcreateBindGroup( bindGroup, layoutGPU ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tlet bindingPoint = 0;\n\t\tconst entriesGPU = [];\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst byteLength = binding.byteLength;\n\n\t\t\t\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\tconst bufferGPU = device.createBuffer( {\n\t\t\t\t\t\tlabel: 'bindingBuffer_' + binding.name,\n\t\t\t\t\t\tsize: byteLength,\n\t\t\t\t\t\tusage: usage\n\t\t\t\t\t} );\n\n\t\t\t\t\tbindingData.buffer = bufferGPU;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\t\t//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\t//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n\t\t\t\t\tbindingData.buffer = backend.get( attribute ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst textureGPU = backend.get( binding.texture );\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst textureData = backend.get( binding.texture );\n\n\t\t\t\tlet resourceGPU;\n\n\t\t\t\tif ( textureData.externalTexture !== undefined ) {\n\n\t\t\t\t\tresourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n\t\t\t\t\tconst propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;\n\n\t\t\t\t\tresourceGPU = textureData[ propertyName ];\n\n\t\t\t\t\tif ( resourceGPU === undefined ) {\n\n\t\t\t\t\t\tconst aspectGPU = GPUTextureAspect.All;\n\n\t\t\t\t\t\tlet dimensionViewGPU;\n\n\t\t\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.Cube;\n\n\t\t\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t\t\t} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoD;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );\n\n\t\t\t}\n\n\t\t\tbindingPoint ++;\n\n\t\t}\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroup_' + bindGroup.name,\n\t\t\tlayout: layoutGPU,\n\t\t\tentries: entriesGPU\n\t\t} );\n\n\t}\n\n}\n\n/**\n * A WebGPU backend utility module for managing pipelines.\n *\n * @private\n */\nclass WebGPUPipelineUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Returns the sample count derived from the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {Number} The sample count.\n\t */\n\t_getSampleCount( renderContext ) {\n\n\t\treturn this.backend.utils.getSampleCountRenderContext( renderContext );\n\n\t}\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst { object, material, geometry, pipeline } = renderObject;\n\t\tconst { vertexProgram, fragmentProgram } = pipeline;\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\t\tconst utils = backend.utils;\n\n\t\tconst pipelineData = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindGroup of renderObject.getBindings() ) {\n\n\t\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );\n\n\t\t// blending\n\n\t\tlet blending;\n\n\t\tif ( material.transparent === true && material.blending !== NoBlending ) {\n\n\t\t\tblending = this._getBlending( material );\n\n\t\t}\n\n\t\t// stencil\n\n\t\tlet stencilFront = {};\n\n\t\tif ( material.stencilWrite === true ) {\n\n\t\t\tstencilFront = {\n\t\t\t\tcompare: this._getStencilCompare( material ),\n\t\t\t\tfailOp: this._getStencilOperation( material.stencilFail ),\n\t\t\t\tdepthFailOp: this._getStencilOperation( material.stencilZFail ),\n\t\t\t\tpassOp: this._getStencilOperation( material.stencilZPass )\n\t\t\t};\n\n\t\t}\n\n\t\tconst colorWriteMask = this._getColorWriteMask( material );\n\n\t\tconst targets = [];\n\n\t\tif ( renderObject.context.textures !== null ) {\n\n\t\t\tconst textures = renderObject.context.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst colorFormat = utils.getTextureFormatGPU( textures[ i ] );\n\n\t\t\t\ttargets.push( {\n\t\t\t\t\tformat: colorFormat,\n\t\t\t\t\tblend: blending,\n\t\t\t\t\twriteMask: colorWriteMask\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\n\t\t\ttargets.push( {\n\t\t\t\tformat: colorFormat,\n\t\t\t\tblend: blending,\n\t\t\t\twriteMask: colorWriteMask\n\t\t\t} );\n\n\t\t}\n\n\t\tconst vertexModule = backend.get( vertexProgram ).module;\n\t\tconst fragmentModule = backend.get( fragmentProgram ).module;\n\n\t\tconst primitiveState = this._getPrimitiveState( object, geometry, material );\n\t\tconst depthCompare = this._getDepthCompare( material );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\n\t\tconst sampleCount = this._getSampleCount( renderObject.context );\n\n\t\tconst pipelineDescriptor = {\n\t\t\tlabel: `renderPipeline_${ material.name || material.type }_${ material.id }`,\n\t\t\tvertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),\n\t\t\tfragment: Object.assign( {}, fragmentModule, { targets } ),\n\t\t\tprimitive: primitiveState,\n\t\t\tmultisample: {\n\t\t\t\tcount: sampleCount,\n\t\t\t\talphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1\n\t\t\t},\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t};\n\n\n\t\tconst depthStencil = {};\n\t\tconst renderDepth = renderObject.context.depth;\n\t\tconst renderStencil = renderObject.context.stencil;\n\n\t\tif ( renderDepth === true || renderStencil === true ) {\n\n\t\t\tif ( renderDepth === true ) {\n\n\t\t\t\tdepthStencil.format = depthStencilFormat;\n\t\t\t\tdepthStencil.depthWriteEnabled = material.depthWrite;\n\t\t\t\tdepthStencil.depthCompare = depthCompare;\n\n\t\t\t}\n\n\t\t\tif ( renderStencil === true ) {\n\n\t\t\t\tdepthStencil.stencilFront = stencilFront;\n\t\t\t\tdepthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)\n\t\t\t\tdepthStencil.stencilReadMask = material.stencilFuncMask;\n\t\t\t\tdepthStencil.stencilWriteMask = material.stencilWriteMask;\n\n\t\t\t}\n\n\t\t\tpipelineDescriptor.depthStencil = depthStencil;\n\n\t\t}\n\n\n\t\tif ( promises === null ) {\n\n\t\t\tpipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );\n\n\t\t} else {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tdevice.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {\n\n\t\t\t\t\tpipelineData.pipeline = pipeline;\n\t\t\t\t\tresolve();\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates GPU render bundle encoder for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {GPURenderBundleEncoder} The GPU render bundle encoder.\n\t */\n\tcreateBundleEncoder( renderContext ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { utils, device } = backend;\n\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderContext );\n\t\tconst sampleCount = this._getSampleCount( renderContext );\n\n\t\tconst descriptor = {\n\t\t\tlabel: 'renderBundleEncoder',\n\t\t\tcolorFormats: [ colorFormat ],\n\t\t\tdepthStencilFormat,\n\t\t\tsampleCount\n\t\t};\n\n\t\treturn device.createRenderBundleEncoder( descriptor );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( pipeline, bindings ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst computeProgram = backend.get( pipeline.computeProgram ).module;\n\n\t\tconst pipelineGPU = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindingsGroup of bindings ) {\n\n\t\t\tconst bindingsData = backend.get( bindingsGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\tpipelineGPU.pipeline = device.createComputePipeline( {\n\t\t\tcompute: computeProgram,\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t} );\n\n\t}\n\n\t/**\n\t * Returns the blending state as a descriptor object required\n\t * for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Material} material - The material.\n\t * @return {Object} The blending state.\n\t */\n\t_getBlending( material ) {\n\n\t\tlet color, alpha;\n\n\t\tconst blending = material.blending;\n\t\tconst blendSrc = material.blendSrc;\n\t\tconst blendDst = material.blendDst;\n\t\tconst blendEquation = material.blendEquation;\n\n\n\t\tif ( blending === CustomBlending ) {\n\n\t\t\tconst blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;\n\t\t\tconst blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;\n\t\t\tconst blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;\n\n\t\t\tcolor = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrc ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDst ),\n\t\t\t\toperation: this._getBlendOperation( blendEquation )\n\t\t\t};\n\n\t\t\talpha = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrcAlpha ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDstAlpha ),\n\t\t\t\toperation: this._getBlendOperation( blendEquationAlpha )\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst premultipliedAlpha = material.premultipliedAlpha;\n\n\t\t\tconst setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {\n\n\t\t\t\tcolor = {\n\t\t\t\t\tsrcFactor: srcRGB,\n\t\t\t\t\tdstFactor: dstRGB,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t\talpha = {\n\t\t\t\t\tsrcFactor: srcAlpha,\n\t\t\t\t\tdstFactor: dstAlpha,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( color !== undefined && alpha !== undefined ) {\n\n\t\t\treturn { color, alpha };\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );\n\n\t\t}\n\n\t}\n\t/**\n\t * Returns the GPU blend factor which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Number} blend - The blend factor as a three.js constant.\n\t * @return {String} The GPU blend factor.\n\t */\n\t_getBlendFactor( blend ) {\n\n\t\tlet blendFactor;\n\n\t\tswitch ( blend ) {\n\n\t\t\tcase ZeroFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase OneFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.One;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Src;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrc;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase DstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Dst;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstColor;\n\t\t\t\tbreak;\n\n\t\t\tcase DstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.DstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaSaturateFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlphaSaturated;\n\t\t\t\tbreak;\n\n\t\t\tcase BlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Constant;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusBlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusConstant;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );\n\n\t\t}\n\n\t\treturn blendFactor;\n\n\t}\n\n\t/**\n\t * Returns the GPU stencil compare function which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Material} material - The material.\n\t * @return {String} The GPU stencil compare function.\n\t */\n\t_getStencilCompare( material ) {\n\n\t\tlet stencilCompare;\n\n\t\tconst stencilFunc = material.stencilFunc;\n\n\t\tswitch ( stencilFunc ) {\n\n\t\t\tcase NeverStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Never;\n\t\t\t\tbreak;\n\n\t\t\tcase AlwaysStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Always;\n\t\t\t\tbreak;\n\n\t\t\tcase LessStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Less;\n\t\t\t\tbreak;\n\n\t\t\tcase LessEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.LessEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase EqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Equal;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Greater;\n\t\t\t\tbreak;\n\n\t\t\tcase NotEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.NotEqual;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );\n\n\t\t}\n\n\t\treturn stencilCompare;\n\n\t}\n\n\t/**\n\t * Returns the GPU stencil operation which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Number} op - A three.js constant defining the stencil operation.\n\t * @return {String} The GPU stencil operation.\n\t */\n\t_getStencilOperation( op ) {\n\n\t\tlet stencilOperation;\n\n\t\tswitch ( op ) {\n\n\t\t\tcase KeepStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Keep;\n\t\t\t\tbreak;\n\n\t\t\tcase ZeroStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase ReplaceStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Replace;\n\t\t\t\tbreak;\n\n\t\t\tcase InvertStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Invert;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );\n\n\t\t}\n\n\t\treturn stencilOperation;\n\n\t}\n\n\t/**\n\t * Returns the GPU blend operation which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Number} blendEquation - A three.js constant defining the blend equation.\n\t * @return {String} The GPU blend operation.\n\t */\n\t_getBlendOperation( blendEquation ) {\n\n\t\tlet blendOperation;\n\n\t\tswitch ( blendEquation ) {\n\n\t\t\tcase AddEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Add;\n\t\t\t\tbreak;\n\n\t\t\tcase SubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Subtract;\n\t\t\t\tbreak;\n\n\t\t\tcase ReverseSubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.ReverseSubtract;\n\t\t\t\tbreak;\n\n\t\t\tcase MinEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Min;\n\t\t\t\tbreak;\n\n\t\t\tcase MaxEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Max;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );\n\n\t\t}\n\n\t\treturn blendOperation;\n\n\t}\n\n\t/**\n\t * Returns the primitive state as a descriptor object required\n\t * for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The geometry.\n\t * @param {Material} material - The material.\n\t * @return {Object} The primitive state.\n\t */\n\t_getPrimitiveState( object, geometry, material ) {\n\n\t\tconst descriptor = {};\n\t\tconst utils = this.backend.utils;\n\n\t\tdescriptor.topology = utils.getPrimitiveTopology( object, material );\n\n\t\tif ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {\n\n\t\t\tdescriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t}\n\n\t\tswitch ( material.side ) {\n\n\t\t\tcase FrontSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.Back;\n\t\t\t\tbreak;\n\n\t\t\tcase BackSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.Front;\n\t\t\t\tbreak;\n\n\t\t\tcase DoubleSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.None;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * Returns the GPU color write mask which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Material} material - The material.\n\t * @return {String} The GPU color write mask.\n\t */\n\t_getColorWriteMask( material ) {\n\n\t\treturn ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;\n\n\t}\n\n\t/**\n\t * Returns the GPU depth compare function which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Material} material - The material.\n\t * @return {String} The GPU depth compare function.\n\t */\n\t_getDepthCompare( material ) {\n\n\t\tlet depthCompare;\n\n\t\tif ( material.depthTest === false ) {\n\n\t\t\tdepthCompare = GPUCompareFunction.Always;\n\n\t\t} else {\n\n\t\t\tconst depthFunc = material.depthFunc;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Never;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Always;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Less;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.LessEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Equal;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Greater;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.NotEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn depthCompare;\n\n\t}\n\n}\n\n/**\n * Manages a pool of WebGPU timestamp queries for performance measurement.\n * Extends the base TimestampQueryPool to provide WebGPU-specific implementation.\n * @extends TimestampQueryPool\n */\nclass WebGPUTimestampQueryPool extends TimestampQueryPool {\n\n\t/**\n     * Creates a new WebGPU timestamp query pool.\n     * @param {GPUDevice} device - The WebGPU device to create queries on.\n     * @param {string} type - The type identifier for this query pool.\n     * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.\n     */\n\tconstructor( device, type, maxQueries = 2048 ) {\n\n\t\tsuper( maxQueries );\n\t\tthis.device = device;\n\t\tthis.type = type;\n\n\t\tthis.querySet = this.device.createQuerySet( {\n\t\t\ttype: 'timestamp',\n\t\t\tcount: this.maxQueries,\n\t\t\tlabel: `queryset_global_timestamp_${type}`\n\t\t} );\n\n\t\tconst bufferSize = this.maxQueries * 8;\n\t\tthis.resolveBuffer = this.device.createBuffer( {\n\t\t\tlabel: `buffer_timestamp_resolve_${type}`,\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t} );\n\n\t\tthis.resultBuffer = this.device.createBuffer( {\n\t\t\tlabel: `buffer_timestamp_result_${type}`,\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\t}\n\n\t/**\n     * Allocates a pair of queries for a given render context.\n     * @param {Object} renderContext - The render context to allocate queries for.\n     * @returns {?number} The base offset for the allocated queries, or null if allocation failed.\n     */\n\tallocateQueriesForContext( renderContext ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) return null;\n\n\t\tif ( this.currentQueryIndex + 2 > this.maxQueries ) {\n\n\t\t\twarnOnce( `WebGPUTimestampQueryPool [${ this.type }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${ this.type.toUpperCase() } ).` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst baseOffset = this.currentQueryIndex;\n\t\tthis.currentQueryIndex += 2;\n\n\t\tthis.queryOffsets.set( renderContext.id, baseOffset );\n\t\treturn baseOffset;\n\n\t}\n\n\t/**\n     * Asynchronously resolves all pending queries and returns the total duration.\n     * If there's already a pending resolve operation, returns that promise instead.\n     * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.\n     */\n\tasync resolveQueriesAsync() {\n\n\t\tif ( ! this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\tif ( this.pendingResolve ) {\n\n\t\t\treturn this.pendingResolve;\n\n\t\t}\n\n\t\tthis.pendingResolve = this._resolveQueries();\n\n\t\ttry {\n\n\t\t\tconst result = await this.pendingResolve;\n\t\t\treturn result;\n\n\t\t} finally {\n\n\t\t\tthis.pendingResolve = null;\n\n\t\t}\n\n\t}\n\n\t/**\n     * Internal method to resolve queries and calculate total duration.\n     * @private\n     * @returns {Promise<number>} The total duration in milliseconds.\n     */\n\tasync _resolveQueries() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tif ( this.resultBuffer.mapState !== 'unmapped' ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\tconst currentOffsets = new Map( this.queryOffsets );\n\t\t\tconst queryCount = this.currentQueryIndex;\n\t\t\tconst bytesUsed = queryCount * 8;\n\n\t\t\t// Reset state before GPU work\n\t\t\tthis.currentQueryIndex = 0;\n\t\t\tthis.queryOffsets.clear();\n\n\t\t\tconst commandEncoder = this.device.createCommandEncoder();\n\n\t\t\tcommandEncoder.resolveQuerySet(\n\t\t\t\tthis.querySet,\n\t\t\t\t0,\n\t\t\t\tqueryCount,\n\t\t\t\tthis.resolveBuffer,\n\t\t\t\t0\n\t\t\t);\n\n\t\t\tcommandEncoder.copyBufferToBuffer(\n\t\t\t\tthis.resolveBuffer,\n\t\t\t\t0,\n\t\t\t\tthis.resultBuffer,\n\t\t\t\t0,\n\t\t\t\tbytesUsed\n\t\t\t);\n\n\t\t\tconst commandBuffer = commandEncoder.finish();\n\t\t\tthis.device.queue.submit( [ commandBuffer ] );\n\n\t\t\tif ( this.resultBuffer.mapState !== 'unmapped' ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\t// Create and track the mapping operation\n\t\t\tawait this.resultBuffer.mapAsync( GPUMapMode.READ, 0, bytesUsed );\n\n\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\tif ( this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t\t}\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\tconst times = new BigUint64Array( this.resultBuffer.getMappedRange( 0, bytesUsed ) );\n\t\t\tlet totalDuration = 0;\n\n\t\t\tfor ( const [ , baseOffset ] of currentOffsets ) {\n\n\t\t\t\tconst startTime = times[ baseOffset ];\n\t\t\t\tconst endTime = times[ baseOffset + 1 ];\n\t\t\t\tconst duration = Number( endTime - startTime ) / 1e6;\n\t\t\t\ttotalDuration += duration;\n\n\t\t\t}\n\n\t\t\tthis.resultBuffer.unmap();\n\t\t\tthis.lastValue = totalDuration;\n\n\t\t\treturn totalDuration;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'Error resolving queries:', error );\n\t\t\tif ( this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t}\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t}\n\n\tasync dispose() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.isDisposed = true;\n\n\t\t// Wait for pending resolve operation\n\t\tif ( this.pendingResolve ) {\n\n\t\t\ttry {\n\n\t\t\t\tawait this.pendingResolve;\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( 'Error waiting for pending resolve:', error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Ensure buffer is unmapped before destroying\n\t\tif ( this.resultBuffer && this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\ttry {\n\n\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( 'Error unmapping buffer:', error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Destroy resources\n\t\tif ( this.querySet ) {\n\n\t\t\tthis.querySet.destroy();\n\t\t\tthis.querySet = null;\n\n\t\t}\n\n\t\tif ( this.resolveBuffer ) {\n\n\t\t\tthis.resolveBuffer.destroy();\n\t\t\tthis.resolveBuffer = null;\n\n\t\t}\n\n\t\tif ( this.resultBuffer ) {\n\n\t\t\tthis.resultBuffer.destroy();\n\t\t\tthis.resultBuffer = null;\n\n\t\t}\n\n\t\tthis.queryOffsets.clear();\n\t\tthis.pendingResolve = null;\n\n\t}\n\n}\n\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\n\n/**\n * A backend implementation targeting WebGPU.\n *\n * @private\n * @augments Backend\n */\nclass WebGPUBackend extends Backend {\n\n\t/**\n\t * Constructs a new WebGPU backend.\n\t *\n\t * @param {Object} parameters - The configuration parameter.\n\t * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @param {Boolean} [parameters.trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.\n\t * @param {String} [parameters.powerPreference=undefined] - The power preference.\n\t * @param {Object} [parameters.requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.\n\t * @param {GPUDevice} [parameters.device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.\n\t * @param {Number} [parameters.outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGPUBackend = true;\n\n\t\t// some parameters require default values other than \"undefined\"\n\t\tthis.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;\n\n\t\tthis.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;\n\n\t\t/**\n\t\t * Whether to track timestamps with a Timestamp Query API or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t\t/**\n\t\t * A reference to the device.\n\t\t *\n\t\t * @type {GPUDevice?}\n\t\t * @default null\n\t\t */\n\t\tthis.device = null;\n\n\t\t/**\n\t\t * A reference to the context.\n\t\t *\n\t\t * @type {GPUCanvasContext?}\n\t\t * @default null\n\t\t */\n\t\tthis.context = null;\n\n\t\t/**\n\t\t * A reference to the color attachment of the default framebuffer.\n\t\t *\n\t\t * @type {GPUTexture?}\n\t\t * @default null\n\t\t */\n\t\tthis.colorBuffer = null;\n\n\t\t/**\n\t\t * A reference to the default render pass descriptor.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding common utility functions.\n\t\t *\n\t\t * @type {WebGPUUtils}\n\t\t */\n\t\tthis.utils = new WebGPUUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader attribute-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUAttributeUtils}\n\t\t */\n\t\tthis.attributeUtils = new WebGPUAttributeUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader binding-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUBindingUtils}\n\t\t */\n\t\tthis.bindingUtils = new WebGPUBindingUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader pipeline-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUPipelineUtils}\n\t\t */\n\t\tthis.pipelineUtils = new WebGPUPipelineUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader texture-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUTextureUtils}\n\t\t */\n\t\tthis.textureUtils = new WebGPUTextureUtils( this );\n\n\t\t/**\n\t\t * A map that manages the resolve buffers for occlusion queries.\n\t\t *\n\t\t * @type {Map<Number,GPUBuffer>}\n\t\t */\n\t\tthis.occludedResolveCache = new Map();\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the backend has been initialized.\n\t */\n\tasync init( renderer ) {\n\n\t\tawait super.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\t// create the device if it is not passed with parameters\n\n\t\tlet device;\n\n\t\tif ( parameters.device === undefined ) {\n\n\t\t\tconst adapterOptions = {\n\t\t\t\tpowerPreference: parameters.powerPreference\n\t\t\t};\n\n\t\t\tconst adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;\n\n\t\t\tif ( adapter === null ) {\n\n\t\t\t\tthrow new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );\n\n\t\t\t}\n\n\t\t\t// feature support\n\n\t\t\tconst features = Object.values( GPUFeatureName );\n\n\t\t\tconst supportedFeatures = [];\n\n\t\t\tfor ( const name of features ) {\n\n\t\t\t\tif ( adapter.features.has( name ) ) {\n\n\t\t\t\t\tsupportedFeatures.push( name );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst deviceDescriptor = {\n\t\t\t\trequiredFeatures: supportedFeatures,\n\t\t\t\trequiredLimits: parameters.requiredLimits\n\t\t\t};\n\n\t\t\tdevice = await adapter.requestDevice( deviceDescriptor );\n\n\t\t} else {\n\n\t\t\tdevice = parameters.device;\n\n\t\t}\n\n\t\tdevice.lost.then( ( info ) => {\n\n\t\t\tconst deviceLossInfo = {\n\t\t\t\tapi: 'WebGPU',\n\t\t\t\tmessage: info.message || 'Unknown reason',\n\t\t\t\treason: info.reason || null,\n\t\t\t\toriginalEvent: info\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( deviceLossInfo );\n\n\t\t} );\n\n\t\tconst context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );\n\n\t\tthis.device = device;\n\t\tthis.context = context;\n\n\t\tconst alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n\n\t\tthis.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );\n\n\t\tthis.context.configure( {\n\t\t\tdevice: this.device,\n\t\t\tformat: this.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n\t\t\talphaMode: alphaMode\n\t\t} );\n\n\t\tthis.updateSize();\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGPUCoordinateSystem;\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @return {GPUCanvasContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Returns the default render pass descriptor.\n\t *\n\t * In WebGPU, the default framebuffer must be configured\n\t * like custom framebuffers so the backend needs a render\n\t * pass descriptor even when rendering directly to screen.\n\t *\n\t * @private\n\t * @return {Object} The render pass descriptor.\n\t */\n\t_getDefaultRenderPassDescriptor() {\n\n\t\tlet descriptor = this.defaultRenderPassdescriptor;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: null\n\t\t\t\t} ],\n\t\t\t};\n\n\t\t\tif ( this.renderer.depth === true || this.renderer.stencil === true ) {\n\n\t\t\t\tdescriptor.depthStencilAttachment = {\n\t\t\t\t\tview: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\t\tcolorAttachment.view = this.colorBuffer.createView();\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.resolveTarget = undefined;\n\n\t\t\t}\n\n\t\t\tthis.defaultRenderPassdescriptor = descriptor;\n\n\t\t}\n\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n\n\t\t} else {\n\n\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * Returns the render pass descriptor for the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.\n\t * @return {Object} The render pass descriptor.\n\t */\n\t_getRenderPassDescriptor( renderContext, colorAttachmentsConfig = {} ) {\n\n\t\tconst renderTarget = renderContext.renderTarget;\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tlet descriptors = renderTargetData.descriptors;\n\n\t\tif ( descriptors === undefined ||\n\t\t\trenderTargetData.width !== renderTarget.width ||\n\t\t\trenderTargetData.height !== renderTarget.height ||\n\t\t\trenderTargetData.dimensions !== renderTarget.dimensions ||\n\t\t\trenderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel ||\n\t\t\trenderTargetData.activeCubeFace !== renderContext.activeCubeFace ||\n\t\t\trenderTargetData.samples !== renderTarget.samples ||\n\t\t\trenderTargetData.loadOp !== colorAttachmentsConfig.loadOp\n\t\t) {\n\n\t\t\tdescriptors = {};\n\n\t\t\trenderTargetData.descriptors = descriptors;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\tconst cacheKey = renderContext.getCacheKey();\n\n\t\tlet descriptor = descriptors[ cacheKey ];\n\n\t\tif ( descriptor === undefined ) {\n\n\t\t\tconst textures = renderContext.textures;\n\t\t\tconst colorAttachments = [];\n\n\t\t\tlet sliceIndex;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst textureData = this.get( textures[ i ] );\n\n\t\t\t\tconst viewDescriptor = {\n\t\t\t\t\tlabel: `colorAttachment_${ i }`,\n\t\t\t\t\tbaseMipLevel: renderContext.activeMipmapLevel,\n\t\t\t\t\tmipLevelCount: 1,\n\t\t\t\t\tbaseArrayLayer: renderContext.activeCubeFace,\n\t\t\t\t\tarrayLayerCount: 1,\n\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t};\n\n\t\t\t\tif ( renderTarget.isRenderTarget3D ) {\n\n\t\t\t\t\tsliceIndex = renderContext.activeCubeFace;\n\n\t\t\t\t\tviewDescriptor.baseArrayLayer = 0;\n\t\t\t\t\tviewDescriptor.dimension = GPUTextureViewDimension.ThreeD;\n\t\t\t\t\tviewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;\n\n\t\t\t\t} else if ( renderTarget.isRenderTargetArray ) {\n\n\t\t\t\t\tviewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;\n\t\t\t\t\tviewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;\n\n\t\t\t\t}\n\n\t\t\t\tconst textureView = textureData.texture.createView( viewDescriptor );\n\n\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tview = textureView;\n\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t}\n\n\t\t\t\tcolorAttachments.push( {\n\t\t\t\t\tview,\n\t\t\t\t\tdepthSlice: sliceIndex,\n\t\t\t\t\tresolveTarget,\n\t\t\t\t\tloadOp: GPULoadOp.Load,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\t...colorAttachmentsConfig\n\t\t\t\t} );\n\n\t\t\t}\n\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments,\n\t\t\t};\n\n\t\t\tif ( renderContext.depth ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\n\t\t\t\tconst depthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.texture.createView()\n\t\t\t\t};\n\t\t\t\tdescriptor.depthStencilAttachment = depthStencilAttachment;\n\n\t\t\t}\n\n\t\t\tdescriptors[ cacheKey ] = descriptor;\n\n\t\t\trenderTargetData.width = renderTarget.width;\n\t\t\trenderTargetData.height = renderTarget.height;\n\t\t\trenderTargetData.samples = renderTarget.samples;\n\t\t\trenderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;\n\t\t\trenderTargetData.activeCubeFace = renderContext.activeCubeFace;\n\t\t\trenderTargetData.dimensions = renderTarget.dimensions;\n\t\t\trenderTargetData.depthSlice = sliceIndex;\n\t\t\trenderTargetData.loadOp = colorAttachments[ 0 ].loadOp;\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a render call and prepares\n\t * the WebGPU state for upcoming render calls\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst device = this.device;\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tlet occlusionQuerySet;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();\n\t\t\tif ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the buffer.mapAsyc() completes.\n\t\t\trenderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\t//\n\n\t\t\tocclusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );\n\n\t\t\trenderContextData.occlusionQuerySet = occlusionQuerySet;\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\n\t\t}\n\n\t\tlet descriptor;\n\n\t\tif ( renderContext.textures === null ) {\n\n\t\t\tdescriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t} else {\n\n\t\t\tdescriptor = this._getRenderPassDescriptor( renderContext, { loadOp: GPULoadOp.Load } );\n\n\t\t}\n\n\t\tthis.initTimestampQuery( renderContext, descriptor );\n\n\t\tdescriptor.occlusionQuerySet = occlusionQuerySet;\n\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst colorAttachments = descriptor.colorAttachments;\n\n\t\t\tfor ( let i = 0; i < colorAttachments.length; i ++ ) {\n\n\t\t\t\tconst colorAttachment = colorAttachments[ i ];\n\n\t\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\t\tcolorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderContext.depth ) {\n\n\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderContext.stencil ) {\n\n\t\t\tif ( renderContext.clearStencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );\n\t\tconst currentPass = encoder.beginRenderPass( descriptor );\n\n\t\t//\n\n\t\trenderContextData.descriptor = descriptor;\n\t\trenderContextData.encoder = encoder;\n\t\trenderContextData.currentPass = currentPass;\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.renderBundles = [];\n\n\t\t//\n\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tcurrentPass.setScissorRect( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a render call and finalizes work\n\t * after draw calls.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( renderContextData.renderBundles.length > 0 ) {\n\n\t\t\trenderContextData.currentPass.executeBundles( renderContextData.renderBundles );\n\n\t\t}\n\n\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\n\t\t}\n\n\t\trenderContextData.currentPass.end();\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tconst bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n\t\t\t//\n\n\t\t\tlet queryResolveBuffer = this.occludedResolveCache.get( bufferSize );\n\n\t\t\tif ( queryResolveBuffer === undefined ) {\n\n\t\t\t\tqueryResolveBuffer = this.device.createBuffer(\n\t\t\t\t\t{\n\t\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.occludedResolveCache.set( bufferSize, queryResolveBuffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst readBuffer = this.device.createBuffer(\n\t\t\t\t{\n\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n\t\t\trenderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );\n\t\t\trenderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );\n\n\t\t\trenderContextData.occlusionQueryBuffer = readBuffer;\n\n\t\t\t//\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tthis.device.queue.submit( [ renderContextData.encoder.finish() ] );\n\n\n\t\t//\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps === true ) {\n\n\t\t\t\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {Boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\t/**\n\t * This method processes the result of occlusion queries and writes it\n\t * into render context data.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {Promise} A Promise that resolves when the occlusion query results have been processed.\n\t */\n\tasync resolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = null;\n\n\t\t\tawait currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );\n\n\t\t\tconst buffer = currentOcclusionQueryBuffer.getMappedRange();\n\t\t\tconst results = new BigUint64Array( buffer );\n\n\t\t\tfor ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {\n\n\t\t\t\tif ( results[ i ] === BigInt( 0 ) ) {\n\n\t\t\t\t\toccluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentOcclusionQueryBuffer.destroy();\n\n\t\t\trenderContextData.occluded = occluded;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( renderContext ) {\n\n\t\tconst { currentPass } = this.get( renderContext );\n\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\n\t\tcurrentPass.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t}\n\n\t/**\n\t * Performs a clear operation.\n\t *\n\t * @param {Boolean} color - Whether the color buffer should be cleared or not.\n\t * @param {Boolean} depth - Whether the depth buffer should be cleared or not.\n\t * @param {Boolean} stencil - Whether the stencil buffer should be cleared or not.\n\t * @param {RenderContext?} [renderTargetContext=null] - The render context of the current set render target.\n\t */\n\tclear( color, depth, stencil, renderTargetContext = null ) {\n\n\t\tconst device = this.device;\n\t\tconst renderer = this.renderer;\n\n\t\tlet colorAttachments = [];\n\n\t\tlet depthStencilAttachment;\n\t\tlet clearValue;\n\n\t\tlet supportsDepth;\n\t\tlet supportsStencil;\n\n\t\tif ( color ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\tif ( this.renderer.alpha === true ) {\n\n\t\t\t\t// premultiply alpha\n\n\t\t\t\tconst a = clearColor.a;\n\n\t\t\t\tclearValue = { r: clearColor.r * a, g: clearColor.g * a, b: clearColor.b * a, a: a };\n\n\t\t\t} else {\n\n\t\t\t\tclearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderTargetContext === null ) {\n\n\t\t\tsupportsDepth = renderer.depth;\n\t\t\tsupportsStencil = renderer.stencil;\n\n\t\t\tconst descriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t\tif ( color ) {\n\n\t\t\t\tcolorAttachments = descriptor.colorAttachments;\n\n\t\t\t\tconst colorAttachment = colorAttachments[ 0 ];\n\n\t\t\t\tcolorAttachment.clearValue = clearValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tdepthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsupportsDepth = renderTargetContext.depth;\n\t\t\tsupportsStencil = renderTargetContext.stencil;\n\n\t\t\tif ( color ) {\n\n\t\t\t\tconst descriptor = this._getRenderPassDescriptor( renderTargetContext, { loadOp: GPULoadOp.Clear, clearValue } );\n\n\t\t\t\tcolorAttachments = descriptor.colorAttachments;\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderTargetContext.depthTexture );\n\n\t\t\t\tdepthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.texture.createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsDepth ) {\n\n\t\t\tif ( depth ) {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderer.getClearDepth();\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsStencil ) {\n\n\t\t\tif ( stencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'clear' } );\n\t\tconst currentPass = encoder.beginRenderPass( {\n\t\t\tcolorAttachments,\n\t\t\tdepthStencilAttachment\n\t\t} );\n\n\t\tcurrentPass.end();\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\t// compute\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * prepares the state for upcoming compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( computeGroup ) {\n\n\t\tconst groupGPU = this.get( computeGroup );\n\n\n\t\tconst descriptor = {\n\t\t\tlabel: 'computeGroup_' + computeGroup.id\n\t\t};\n\n\t\tthis.initTimestampQuery( computeGroup, descriptor );\n\n\t\tgroupGPU.cmdEncoderGPU = this.device.createCommandEncoder( { label: 'computeGroup_' + computeGroup.id } );\n\n\t\tgroupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );\n\n\t}\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t */\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { passEncoderGPU } = this.get( computeGroup );\n\n\t\t// pipeline\n\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t// bind groups\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tpassEncoderGPU.setBindGroup( i, bindingsData.group );\n\n\t\t}\n\n\t\tconst maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n\n\t\tconst computeNodeData = this.get( computeNode );\n\n\t\tif ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };\n\n\t\tconst { dispatchSize } = computeNodeData;\n\n\t\tif ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {\n\n\t\t\tdispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );\n\t\t\tdispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );\n\n\t\t} else {\n\n\t\t\tdispatchSize.x = computeNode.dispatchCount;\n\n\t\t}\n\n\t\tpassEncoderGPU.dispatchWorkgroups(\n\t\t\tdispatchSize.x,\n\t\t\tdispatchSize.y,\n\t\t\tdispatchSize.z\n\t\t);\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * finalizes work after compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( computeGroup ) {\n\n\t\tconst groupData = this.get( computeGroup );\n\n\t\tgroupData.passEncoderGPU.end();\n\n\t\tthis.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.device.queue.onSubmittedWorkDone();\n\n\t}\n\n\t// render object\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( renderObject, info ) {\n\n\t\tconst { object, context, pipeline } = renderObject;\n\t\tconst bindings = renderObject.getBindings();\n\t\tconst renderContextData = this.get( context );\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tconst currentSets = renderContextData.currentSets;\n\t\tconst passEncoderGPU = renderContextData.currentPass;\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t// pipeline\n\n\t\tif ( currentSets.pipeline !== pipelineGPU ) {\n\n\t\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t\tcurrentSets.pipeline = pipelineGPU;\n\n\t\t}\n\n\t\t// bind groups\n\n\t\tconst currentBindingGroups = currentSets.bindingGroups;\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tif ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {\n\n\t\t\t\tpassEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );\n\t\t\t\tcurrentBindingGroups[ bindGroup.index ] = bindGroup.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst index = renderObject.getIndex();\n\n\t\tconst hasIndex = ( index !== null );\n\n\t\t// index\n\n\t\tif ( hasIndex === true ) {\n\n\t\t\tif ( currentSets.index !== index ) {\n\n\t\t\t\tconst buffer = this.get( index ).buffer;\n\t\t\t\tconst indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t\t\tpassEncoderGPU.setIndexBuffer( buffer, indexFormat );\n\n\t\t\t\tcurrentSets.index = index;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = renderObject.getVertexBuffers();\n\n\t\tfor ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {\n\n\t\t\tconst vertexBuffer = vertexBuffers[ i ];\n\n\t\t\tif ( currentSets.attributes[ i ] !== vertexBuffer ) {\n\n\t\t\t\tconst buffer = this.get( vertexBuffer ).buffer;\n\t\t\t\tpassEncoderGPU.setVertexBuffer( i, buffer );\n\n\t\t\t\tcurrentSets.attributes[ i ] = vertexBuffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// occlusion queries - handle multiple consecutive draw calls for an object\n\n\t\tif ( renderContextData.occlusionQuerySet !== undefined ) {\n\n\t\t\tconst lastObject = renderContextData.lastOcclusionObject;\n\n\t\t\tif ( lastObject !== object ) {\n\n\t\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.endOcclusionQuery();\n\t\t\t\t\trenderContextData.occlusionQueryIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.beginOcclusionQuery( renderContextData.occlusionQueryIndex );\n\t\t\t\t\trenderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;\n\n\t\t\t\t}\n\n\t\t\t\trenderContextData.lastOcclusionObject = object;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// draw\n\n\t\tconst draw = () => {\n\n\t\t\tif ( object.isBatchedMesh === true ) {\n\n\t\t\t\tconst starts = object._multiDrawStarts;\n\t\t\t\tconst counts = object._multiDrawCounts;\n\t\t\t\tconst drawCount = object._multiDrawCount;\n\t\t\t\tconst drawInstances = object._multiDrawInstances;\n\n\t\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\t\tconst count = drawInstances ? drawInstances[ i ] : 1;\n\t\t\t\t\tconst firstInstance = count > 1 ? 0 : i;\n\n\t\t\t\t\tif ( hasIndex === true ) {\n\n\t\t\t\t\t\tpassEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / index.array.BYTES_PER_ELEMENT, 0, firstInstance );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpassEncoderGPU.draw( counts[ i ], count, starts[ i ], firstInstance );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( hasIndex === true ) {\n\n\t\t\t\tconst { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;\n\n\t\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\t\tif ( indirect !== null ) {\n\n\t\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\t\tpassEncoderGPU.drawIndexedIndirect( buffer, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpassEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.update( object, indexCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\tconst { vertexCount, instanceCount, firstVertex } = drawParams;\n\n\t\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\t\tif ( indirect !== null ) {\n\n\t\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\t\tpassEncoderGPU.drawIndirect( buffer, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpassEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.update( object, vertexCount, instanceCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0 ) {\n\n\t\t\tconst cameraData = this.get( renderObject.camera );\n\t\t\tconst cameras = renderObject.camera.cameras;\n\t\t\tconst cameraIndex = renderObject.getBindingGroup( 'cameraIndex' );\n\n\t\t\tif ( cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length ) {\n\n\t\t\t\tconst bindingsData = this.get( cameraIndex );\n\t\t\t\tconst indexesGPU = [];\n\n\t\t\t\tconst data = new Uint32Array( [ 0, 0, 0, 0 ] );\n\n\t\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\t\tdata[ 0 ] = i;\n\n\t\t\t\t\tconst bindGroupIndex = this.bindingUtils.createBindGroupIndex( data, bindingsData.layout );\n\n\t\t\t\t\tindexesGPU.push( bindGroupIndex );\n\n\t\t\t\t}\n\n\t\t\t\tcameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this\n\n\t\t\t}\n\n\t\t\tconst pixelRatio = this.renderer.getPixelRatio();\n\n\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\tconst subCamera = cameras[ i ];\n\n\t\t\t\tif ( object.layers.test( subCamera.layers ) ) {\n\n\t\t\t\t\tconst vp = subCamera.viewport;\n\n\t\t\t\t\tpassEncoderGPU.setViewport(\n\t\t\t\t\t\tMath.floor( vp.x * pixelRatio ),\n\t\t\t\t\t\tMath.floor( vp.y * pixelRatio ),\n\t\t\t\t\t\tMath.floor( vp.width * pixelRatio ),\n\t\t\t\t\t\tMath.floor( vp.height * pixelRatio ),\n\t\t\t\t\t\tcontext.viewportValue.minDepth,\n\t\t\t\t\t\tcontext.viewportValue.maxDepth\n\t\t\t\t\t);\n\n\t\t\t\t\tpassEncoderGPU.setBindGroup( cameraIndex.index, cameraData.indexesGPU[ i ] );\n\n\t\t\t\t\tdraw();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdraw();\n\n\t\t}\n\n\t}\n\n\t// cache key\n\n\t/**\n\t * Returns `true` if the render pipeline requires an update.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\n\t\tconst sampleCount = utils.getSampleCountRenderContext( renderObject.context );\n\t\tconst colorSpace = utils.getCurrentColorSpace( renderObject.context );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\t\tconst primitiveTopology = utils.getPrimitiveTopology( object, material );\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( data.material !== material || data.materialVersion !== material.version ||\n\t\t\tdata.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||\n\t\t\tdata.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||\n\t\t\tdata.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||\n\t\t\tdata.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||\n\t\t\tdata.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||\n\t\t\tdata.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||\n\t\t\tdata.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||\n\t\t\tdata.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||\n\t\t\tdata.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||\n\t\t\tdata.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||\n\t\t\tdata.primitiveTopology !== primitiveTopology ||\n\t\t\tdata.clippingContextCacheKey !== renderObject.clippingContextCacheKey\n\t\t) {\n\n\t\t\tdata.material = material; data.materialVersion = material.version;\n\t\t\tdata.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;\n\t\t\tdata.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;\n\t\t\tdata.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;\n\t\t\tdata.colorWrite = material.colorWrite;\n\t\t\tdata.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;\n\t\t\tdata.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;\n\t\t\tdata.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;\n\t\t\tdata.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;\n\t\t\tdata.side = material.side; data.alphaToCoverage = material.alphaToCoverage;\n\t\t\tdata.sampleCount = sampleCount;\n\t\t\tdata.colorSpace = colorSpace;\n\t\t\tdata.colorFormat = colorFormat;\n\t\t\tdata.depthStencilFormat = depthStencilFormat;\n\t\t\tdata.primitiveTopology = primitiveTopology;\n\t\t\tdata.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n\n\t\t\tneedsUpdate = true;\n\n\t\t}\n\n\t\treturn needsUpdate;\n\n\t}\n\n\t/**\n\t * Returns a cache key that is used to identify render pipelines.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {String} The cache key.\n\t */\n\tgetRenderCacheKey( renderObject ) {\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\t\tconst renderContext = renderObject.context;\n\n\t\treturn [\n\t\t\tmaterial.transparent, material.blending, material.premultipliedAlpha,\n\t\t\tmaterial.blendSrc, material.blendDst, material.blendEquation,\n\t\t\tmaterial.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,\n\t\t\tmaterial.colorWrite,\n\t\t\tmaterial.depthWrite, material.depthTest, material.depthFunc,\n\t\t\tmaterial.stencilWrite, material.stencilFunc,\n\t\t\tmaterial.stencilFail, material.stencilZFail, material.stencilZPass,\n\t\t\tmaterial.stencilFuncMask, material.stencilWriteMask,\n\t\t\tmaterial.side,\n\t\t\tutils.getSampleCountRenderContext( renderContext ),\n\t\t\tutils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),\n\t\t\tutils.getPrimitiveTopology( object, material ),\n\t\t\trenderObject.getGeometryCacheKey(),\n\t\t\trenderObject.clippingContextCacheKey\n\t\t].join();\n\n\t}\n\n\t// textures\n\n\t/**\n\t * Creates a GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( texture ) {\n\n\t\tthis.textureUtils.createSampler( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( texture ) {\n\n\t\tthis.textureUtils.destroySampler( texture );\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {Number} x - The x coordinate of the copy origin.\n\t * @param {Number} y - The y coordinate of the copy origin.\n\t * @param {Number} width - The width of the copy.\n\t * @param {Number} height - The height of the copy.\n\t * @param {Number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * Inits a time stamp query for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} descriptor - The query descriptor.\n\t */\n\tinitTimestampQuery( renderContext, descriptor ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\n\t\tif ( ! this.timestampQueryPool[ type ] ) {\n\n\t\t\t// TODO: Variable maxQueries?\n\t\t\tthis.timestampQueryPool[ type ] = new WebGPUTimestampQueryPool( this.device, type, 2048 );\n\n\t\t}\n\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\tconst baseOffset = timestampQueryPool.allocateQueriesForContext( renderContext );\n\n\t\tdescriptor.timestampWrites = {\n\t\t\tquerySet: timestampQueryPool.querySet,\n\t\t\tbeginningOfPassWriteIndex: baseOffset,\n\t\t\tendOfPassWriteIndex: baseOffset + 1,\n\t\t  };\n\n\t}\n\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {WGSLNodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new WGSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( program ) {\n\n\t\tconst programGPU = this.get( program );\n\n\t\tprogramGPU.module = {\n\t\t\tmodule: this.device.createShaderModule( { code: program.code, label: program.stage + ( program.name !== '' ? `_${ program.name }` : '' ) } ),\n\t\t\tentryPoint: 'main'\n\t\t};\n\n\t}\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t// pipelines\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tthis.pipelineUtils.createRenderPipeline( renderObject, promises );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tthis.pipelineUtils.createComputePipeline( computePipeline, bindings );\n\n\t}\n\n\t/**\n\t * Prepares the state for encoding render bundles.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginBundle( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData._currentPass = renderContextData.currentPass;\n\t\trenderContextData._currentSets = renderContextData.currentSets;\n\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );\n\n\t}\n\n\t/**\n\t * After processing render bundles this method finalizes related work.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {RenderBundle} bundle - The render bundle.\n\t */\n\tfinishBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst bundleEncoder = renderContextData.currentPass;\n\t\tconst bundleGPU = bundleEncoder.finish();\n\n\t\tthis.get( bundle ).bundleGPU = bundleGPU;\n\n\t\t// restore render pass state\n\n\t\trenderContextData.currentSets = renderContextData._currentSets;\n\t\trenderContextData.currentPass = renderContextData._currentPass;\n\n\t}\n\n\t/**\n\t * Adds a render bundle to the render context data.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {RenderBundle} bundle - The render bundle to add.\n\t */\n\taddBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData.renderBundles.push( this.get( bundle ).bundleGPU );\n\n\t}\n\n\t// bindings\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tupdateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tthis.bindingUtils.updateBinding( binding );\n\n\t}\n\n\t// attributes\n\n\t/**\n\t * Creates the buffer of an indexed shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of an indirect storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateIndirectStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t// canvas\n\n\t/**\n\t * Triggers an update of the default render pass descriptor.\n\t */\n\tupdateSize() {\n\n\t\tthis.colorBuffer = this.textureUtils.getColorBuffer();\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t}\n\n\t// utils public\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @return {Number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn 16;\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @param {String} name - The feature's name.\n\t * @return {Boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\treturn this.device.features.has( name );\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n\t * @param {Number} [level=0] - The mip level to copy.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tlet dstX = 0;\n\t\tlet dstY = 0;\n\t\tlet dstLayer = 0;\n\n\t\tlet srcX = 0;\n\t\tlet srcY = 0;\n\t\tlet srcLayer = 0;\n\n\t\tlet srcWidth = srcTexture.image.width;\n\t\tlet srcHeight = srcTexture.image.height;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\tsrcX = srcRegion.x;\n\t\t\tsrcY = srcRegion.y;\n\t\t\tsrcLayer = srcRegion.z || 0;\n\t\t\tsrcWidth = srcRegion.width;\n\t\t\tsrcHeight = srcRegion.height;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\t\t\tdstLayer = dstPosition.z || 0;\n\n\t\t}\n\n\t\tconst encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );\n\n\t\tconst sourceGPU = this.get( srcTexture ).texture;\n\t\tconst destinationGPU = this.get( dstTexture ).texture;\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\tmipLevel: level,\n\t\t\t\torigin: { x: srcX, y: srcY, z: srcLayer }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU,\n\t\t\t\tmipLevel: level,\n\t\t\t\torigin: { x: dstX, y: dstY, z: dstLayer }\n\t\t\t},\n\t\t\t[\n\t\t\t\tsrcWidth,\n\t\t\t\tsrcHeight,\n\t\t\t\t1\n\t\t\t]\n\t\t);\n\n\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tlet sourceGPU = null;\n\n\t\tif ( renderContext.renderTarget ) {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.get( renderContext.depthTexture ).texture;\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.get( renderContext.textures[ 0 ] ).texture;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.context.getCurrentTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst destinationGPU = this.get( texture ).texture;\n\n\t\tif ( sourceGPU.format !== destinationGPU.format ) {\n\n\t\t\tconsole.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet encoder;\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\trenderContextData.currentPass.end();\n\n\t\t\tencoder = renderContextData.encoder;\n\n\t\t} else {\n\n\t\t\tencoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );\n\n\t\t}\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\torigin: [ rectangle.x, rectangle.y, 0 ],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU\n\t\t\t},\n\t\t\t[\n\t\t\t\trectangle.z,\n\t\t\t\trectangle.w\n\t\t\t]\n\t\t);\n\n\t\tif ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\tconst { descriptor } = renderContextData;\n\n\t\t\tfor ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {\n\n\t\t\t\tdescriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t\tif ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\tif ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\trenderContextData.currentPass = encoder.beginRenderPass( descriptor );\n\t\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\n\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( renderContext );\n\n\t\t\t}\n\n\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\trenderContextData.currentPass.setScissorRect( x, y, width, height );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t\t}\n\n\t}\n\n}\n\nclass IESSpotLight extends SpotLight {\n\n\tconstructor( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tsuper( color, intensity, distance, angle, penumbra, decay );\n\n\t\tthis.iesMap = null;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.iesMap = source.iesMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * This version of a node library represents the standard version\n * used in {@link WebGPURenderer}. It maps lights, tone mapping\n * techniques and materials to node-based implementations.\n *\n * @private\n * @augments NodeLibrary\n */\nclass StandardNodeLibrary extends NodeLibrary {\n\n\t/**\n\t * Constructs a new standard node library.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.addMaterial( MeshPhongNodeMaterial, 'MeshPhongMaterial' );\n\t\tthis.addMaterial( MeshStandardNodeMaterial, 'MeshStandardMaterial' );\n\t\tthis.addMaterial( MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial' );\n\t\tthis.addMaterial( MeshToonNodeMaterial, 'MeshToonMaterial' );\n\t\tthis.addMaterial( MeshBasicNodeMaterial, 'MeshBasicMaterial' );\n\t\tthis.addMaterial( MeshLambertNodeMaterial, 'MeshLambertMaterial' );\n\t\tthis.addMaterial( MeshNormalNodeMaterial, 'MeshNormalMaterial' );\n\t\tthis.addMaterial( MeshMatcapNodeMaterial, 'MeshMatcapMaterial' );\n\t\tthis.addMaterial( LineBasicNodeMaterial, 'LineBasicMaterial' );\n\t\tthis.addMaterial( LineDashedNodeMaterial, 'LineDashedMaterial' );\n\t\tthis.addMaterial( PointsNodeMaterial, 'PointsMaterial' );\n\t\tthis.addMaterial( SpriteNodeMaterial, 'SpriteMaterial' );\n\t\tthis.addMaterial( ShadowNodeMaterial, 'ShadowMaterial' );\n\n\t\tthis.addLight( PointLightNode, PointLight );\n\t\tthis.addLight( DirectionalLightNode, DirectionalLight );\n\t\tthis.addLight( RectAreaLightNode, RectAreaLight );\n\t\tthis.addLight( SpotLightNode, SpotLight );\n\t\tthis.addLight( AmbientLightNode, AmbientLight );\n\t\tthis.addLight( HemisphereLightNode, HemisphereLight );\n\t\tthis.addLight( LightProbeNode, LightProbe );\n\t\tthis.addLight( IESSpotLightNode, IESSpotLight );\n\n\t\tthis.addToneMapping( linearToneMapping, LinearToneMapping );\n\t\tthis.addToneMapping( reinhardToneMapping, ReinhardToneMapping );\n\t\tthis.addToneMapping( cineonToneMapping, CineonToneMapping );\n\t\tthis.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );\n\t\tthis.addToneMapping( agxToneMapping, AgXToneMapping );\n\t\tthis.addToneMapping( neutralToneMapping, NeutralToneMapping );\n\n\t}\n\n}\n\n/*\nconst debugHandler = {\n\n\tget: function ( target, name ) {\n\n\t\t// Add |update\n\t\tif ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );\n\n\t\treturn target[ name ];\n\n\t}\n\n};\n*/\n\n/**\n * This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability\n * to target different backends. By default, the renderer tries to use a WebGPU backend if the\n * browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.\n *\n * @augments module:Renderer~Renderer\n */\nclass WebGPURenderer extends Renderer {\n\n\t/**\n\t * Constructs a new WebGPU renderer.\n\t *\n\t * @param {Object} parameters - The configuration parameter.\n\t * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @param {Number} [parameters.outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.\n\t * @param {Number} [parameters.colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best\n\t * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tlet BackendClass;\n\n\t\tif ( parameters.forceWebGL ) {\n\n\t\t\tBackendClass = WebGLBackend;\n\n\t\t} else {\n\n\t\t\tBackendClass = WebGPUBackend;\n\n\t\t\tparameters.getFallback = () => {\n\n\t\t\t\tconsole.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );\n\n\t\t\t\treturn new WebGLBackend( parameters );\n\n\t\t\t};\n\n\t\t}\n\n\t\tconst backend = new BackendClass( parameters );\n\n\t\t//super( new Proxy( backend, debugHandler ) );\n\t\tsuper( backend, parameters );\n\n\t\t/**\n\t\t * The generic default value is overwritten with the\n\t\t * standard node library for type mapping.\n\t\t *\n\t\t * @type {StandardNodeLibrary}\n\t\t */\n\t\tthis.library = new StandardNodeLibrary();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGPURenderer = true;\n\n\t}\n\n}\n\n/**\n * A specialized group which enables applications access to the\n * Render Bundle API of WebGPU. The group with all its descendant nodes\n * are considered as one render bundle and processed as such by\n * the renderer.\n *\n * This module is only fully supported by `WebGPURenderer` with a WebGPU backend.\n * With a WebGL backend, the group can technically be rendered but without\n * any performance improvements.\n *\n * @augments Group\n */\nclass BundleGroup extends Group {\n\n\t/**\n\t * Constructs a new bundle group.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBundleGroup = true;\n\n\t\t/**\n\t\t * This property is only relevant for detecting types\n\t\t * during serialization/deserialization. It should always\n\t\t * match the class name.\n\t\t *\n\t\t * @type {String}\n\t\t * @readonly\n\t\t * @default 'BundleGroup'\n\t\t */\n\t\tthis.type = 'BundleGroup';\n\n\t\t/**\n\t\t * Whether the bundle is static or not. When set to `true`, the structure\n\t\t * is assumed to be static and does not change. E.g. no new objects are\n\t\t * added to the group\n\t\t *\n\t\t * If a change is required, an update can still be forced by setting the\n\t\t * `needsUpdate` flag to `true`.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.static = true;\n\n\t\t/**\n\t\t * The bundle group's version.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t}\n\n\t/**\n\t * Set this property to `true` when the bundle group has changed.\n\t *\n\t * @type {Boolean}\n\t * @default false\n\t * @param {Boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\n/**\n * This module is responsible to manage the post processing setups in apps.\n * You usually create a single instance of this class and use it to define\n * the output of your post processing effect chain.\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n */\nclass PostProcessing {\n\n\t/**\n\t * Constructs a new post processing management module.\n\t *\n\t * @param {Renderer} renderer - A reference to the renderer.\n\t * @param {Node<vec4>} outputNode - An optional output node.\n\t */\n\tconstructor( renderer, outputNode = vec4( 0, 0, 1, 1 ) ) {\n\n\t\t/**\n\t\t * A reference to the renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * A node which defines the final output of the post\n\t\t * processing. This is usually the last node in a chain\n\t\t * of effect nodes.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.outputNode = outputNode;\n\n\t\t/**\n\t\t * Whether the default output tone mapping and color\n\t\t * space transformation should be enabled or not.\n\t\t *\n\t\t * It is enabled by default by it must be disabled when\n\t\t * effects must be executed after tone mapping and color\n\t\t * space conversion. A typical example is FXAA which\n\t\t * requires sRGB input.\n\t\t *\n\t\t * When set to `false`, the app must control the output\n\t\t * transformation with `RenderOutputNode`.\n\t\t *\n\t\t * ```js\n\t\t * const outputPass = renderOutput( scenePass );\n\t\t * ```\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.outputColorTransform = true;\n\n\t\t/**\n\t\t * Must be set to `true` when the output node changes.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.needsUpdate = true;\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.name = 'PostProcessing';\n\n\t\t/**\n\t\t * The full screen quad that is used to render\n\t\t * the effects.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quadMesh = new QuadMesh( material );\n\n\t}\n\n\t/**\n\t * When `PostProcessing` is used to apply post processing effects,\n\t * the application must use this version of `render()` inside\n\t * its animation loop (not the one from the renderer).\n\t */\n\trender() {\n\n\t\tthis._update();\n\n\t\tconst renderer = this.renderer;\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\n\t\t//\n\n\t\tthis._quadMesh.render( renderer );\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis._quadMesh.material.dispose();\n\n\t}\n\n\t/**\n\t * Updates the state of the module.\n\t *\n\t * @private\n\t */\n\t_update() {\n\n\t\tif ( this.needsUpdate === true ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tconst toneMapping = renderer.toneMapping;\n\t\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\t\tthis._quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput( this.outputNode, toneMapping, outputColorSpace ) : this.outputNode.context( { toneMapping, outputColorSpace } );\n\t\t\tthis._quadMesh.material.needsUpdate = true;\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * When `PostProcessing` is used to apply post processing effects,\n\t * the application must use this version of `renderAsync()` inside\n\t * its animation loop (not the one from the renderer).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync() {\n\n\t\tthis._update();\n\n\t\tconst renderer = this.renderer;\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\n\t\t//\n\n\t\tawait this._quadMesh.renderAsync( renderer );\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t}\n\n}\n\n/**\n * This special type of texture is intended for compute shaders.\n * It can be used to compute the data of a texture with a compute shader.\n *\n * Note: This type of texture can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments Texture\n */\nclass StorageTexture extends Texture {\n\n\t/**\n\t * Constructs a new storage texture.\n\t *\n\t * @param {Number} [width=1] - The storage texture's width.\n\t * @param {Number} [height=1] - The storage texture's height.\n\t */\n\tconstructor( width = 1, height = 1 ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The image object which just represents the texture's dimension.\n\t\t *\n\t\t * @type {{width: Number, height: Number}}\n\t\t */\n\t\tthis.image = { width, height };\n\n\t\t/**\n\t\t * The default `magFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.magFilter = LinearFilter;\n\n\t\t/**\n\t\t * The default `minFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.minFilter = LinearFilter;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTexture = true;\n\n\t}\n\n}\n\n/**\n * This special type of buffer attribute is intended for compute shaders.\n * It can be used to encode draw parameters for indirect draw calls.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments StorageBufferAttribute\n */\nclass IndirectStorageBufferAttribute extends StorageBufferAttribute {\n\n\t/**\n\t * Constructs a new storage buffer attribute.\n\t *\n\t * @param {Number|Uint32Array} count - The item count. It is also valid to pass a `Uint32Array` as an argument.\n\t * The subsequent parameter is then obsolete.\n\t * @param {Number} itemSize - The item size.\n\t */\n\tconstructor( count, itemSize ) {\n\n\t\tsuper( count, itemSize, Uint32Array );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isIndirectStorageBufferAttribute = true;\n\n\t}\n\n}\n\n/**\n * A loader for loading node objects in the three.js JSON Object/Scene format.\n *\n * @augments Loader\n */\nclass NodeLoader extends Loader {\n\n\t/**\n\t * Constructs a new node loader.\n\t *\n\t * @param {LoadingManager?} manager - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of textures.\n\t\t *\n\t\t * @type {Object<String,Texture>}\n\t\t */\n\t\tthis.textures = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<String,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t}\n\n\t/**\n\t * Loads the node definitions from the given URL.\n\t *\n\t * @param {String} url - The path/URL of the file to be loaded.\n\t * @param {Function} onLoad - Will be called when load completes.\n\t * @param {Function} onProgress - Will be called while load progresses.\n\t * @param {Function} onError - Will be called when errors are thrown during the loading process.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( text ) => {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( this.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parse the node dependencies for the loaded node.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @return {Object<String,Node>} A dictionary with node dependencies.\n\t */\n\tparseNodes( json ) {\n\n\t\tconst nodes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tconst { uuid, type } = nodeJSON;\n\n\t\t\t\tnodes[ uuid ] = this.createNodeFromType( type );\n\t\t\t\tnodes[ uuid ].uuid = uuid;\n\n\t\t\t}\n\n\t\t\tconst meta = { nodes, textures: this.textures };\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tnodeJSON.meta = meta;\n\n\t\t\t\tconst node = nodes[ nodeJSON.uuid ];\n\t\t\t\tnode.deserialize( nodeJSON );\n\n\t\t\t\tdelete nodeJSON.meta;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodes;\n\n\t}\n\n\t/**\n\t * Parses the node from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @return {Node} The parsed node.\n\t */\n\tparse( json ) {\n\n\t\tconst node = this.createNodeFromType( json.type );\n\t\tnode.uuid = json.uuid;\n\n\t\tconst nodes = this.parseNodes( json.nodes );\n\t\tconst meta = { nodes, textures: this.textures };\n\n\t\tjson.meta = meta;\n\n\t\tnode.deserialize( json );\n\n\t\tdelete json.meta;\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of textures.\n\t *\n\t * @param {Object<String,Texture>} value - The texture library defines as `<uuid,texture>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a node object from the given type.\n\t *\n\t * @param {String} type - The node type.\n\t * @return {Node} The created node instance.\n\t */\n\tcreateNodeFromType( type ) {\n\n\t\tif ( this.nodes[ type ] === undefined ) {\n\n\t\t\tconsole.error( 'THREE.NodeLoader: Node type not found:', type );\n\t\t\treturn float();\n\n\t\t}\n\n\t\treturn nodeObject( new this.nodes[ type ]() );\n\n\t}\n\n}\n\n/**\n * A special type of material loader for loading node materials.\n *\n * @augments MaterialLoader\n */\nclass NodeMaterialLoader extends MaterialLoader {\n\n\t/**\n\t * Constructs a new node material loader.\n\t *\n\t * @param {LoadingManager?} manager - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<String,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node material types.\n\t\t *\n\t\t * @type {Object<String,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.nodeMaterials = {};\n\n\t}\n\n\t/**\n\t * Parses the node material from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @return {NodeMaterial}. The parsed material.\n\t */\n\tparse( json ) {\n\n\t\tconst material = super.parse( json );\n\n\t\tconst nodes = this.nodes;\n\t\tconst inputNodes = json.inputNodes;\n\n\t\tfor ( const property in inputNodes ) {\n\n\t\t\tconst uuid = inputNodes[ property ];\n\n\t\t\tmaterial[ property ] = nodes[ uuid ];\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node material types.\n\t *\n\t * @param {Object<String,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a node material from the given type.\n\t *\n\t * @param {String} type - The node material type.\n\t * @return {Node} The created node material instance.\n\t */\n\tcreateMaterialFromType( type ) {\n\n\t\tconst materialClass = this.nodeMaterials[ type ];\n\n\t\tif ( materialClass !== undefined ) {\n\n\t\t\treturn new materialClass();\n\n\t\t}\n\n\t\treturn super.createMaterialFromType( type );\n\n\t}\n\n}\n\n/**\n * A special type of object loader for loading 3D objects using\n * node materials.\n *\n * @augments ObjectLoader\n */\nclass NodeObjectLoader extends ObjectLoader {\n\n\t/**\n\t * Constructs a new node object loader.\n\t *\n\t * @param {LoadingManager?} manager - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<String,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node material types.\n\t\t *\n\t\t * @type {Object<String,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.nodeMaterials = {};\n\n\t\t/**\n\t\t * A reference to hold the `nodes` JSON property.\n\t\t *\n\t\t * @private\n\t\t * @type {Object?}\n\t\t */\n\t\tthis._nodesJSON = null;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node material types.\n\t *\n\t * @param {Object<String,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {Function} onLoad - The onLoad callback function.\n\t * @return {Object3D}. The parsed 3D object.\n\t */\n\tparse( json, onLoad ) {\n\n\t\tthis._nodesJSON = json.nodes;\n\n\t\tconst data = super.parse( json, onLoad );\n\n\t\tthis._nodesJSON = null; // dispose\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON and textures.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {Object<String,Texture>} textures - The texture library.\n\t * @return {Object<String,Node>}. The parsed nodes.\n\t */\n\tparseNodes( json, textures ) {\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new NodeLoader();\n\t\t\tloader.setNodes( this.nodes );\n\t\t\tloader.setTextures( textures );\n\n\t\t\treturn loader.parseNodes( json );\n\n\t\t}\n\n\t\treturn {};\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON and textures.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {Object<String,Texture>} textures - The texture library.\n\t * @return {Object<String,NodeMaterial>}. The parsed materials.\n\t */\n\tparseMaterials( json, textures ) {\n\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst nodes = this.parseNodes( this._nodesJSON, textures );\n\n\t\t\tconst loader = new NodeMaterialLoader();\n\t\t\tloader.setTextures( textures );\n\t\t\tloader.setNodes( nodes );\n\t\t\tloader.setNodeMaterials( this.nodeMaterials );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n}\n\n/**\n * In earlier three.js versions, clipping was defined globally\n * on the renderer or on material level. This special version of\n * `THREE.Group` allows to encode the clipping state into the scene\n * graph. Meaning if you create an instance of this group, all\n * descendant 3D objects will be affected by the respective clipping\n * planes.\n *\n * Note: `ClippingGroup` can only be used with `WebGPURenderer`.\n *\n * @augments Group\n */\nclass ClippingGroup extends Group {\n\n\t/**\n\t * Constructs a new clipping group.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isClippingGroup = true;\n\n\t\t/**\n\t\t * An array with clipping planes.\n\t\t *\n\t\t * @type {Array<Plane>}\n\t\t */\n\t\tthis.clippingPlanes = [];\n\n\t\t/**\n\t\t * Whether clipping should be enabled or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * Whether the intersection of the clipping planes is used to clip objects, rather than their union.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clipIntersection = false;\n\n\t\t/**\n\t\t * Whether shadows should be clipped or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clipShadows = false;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayCamera, ArrayElementNode, ArrayNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, Camera, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix2, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, MemberNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RendererUtils, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowBaseNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, StructNode, StructTypeNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, WebXRController, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };\n"],"names":["screenSizeVec","viewportVec","uniformsLib","_rendererState","equationToGL","factorToGL","refreshUniforms","NodeMaterialObserver","constructor","builder","renderObjects","WeakMap","hasNode","containsNode","hasAnimation","object","isSkinnedMesh","renderId","firstInitialization","renderObject","has","getRenderObjectData","data","get","undefined","geometry","material","getMaterialData","id","attributes","getAttributesData","indexVersion","index","version","drawRange","start","count","worldMatrix","matrixWorld","clone","center","morphTargetInfluences","slice","bundle","transmission","width","height","context","bufferWidth","bufferHeight","set","attributesData","name","attribute","property","isNode","renderer","nodes","modelViewMatrix","modelNormalViewMatrix","value","isTexture","equals","renderObjectData","copy","materialData","mtlValue","storedGeometryData","storedAttributes","storedAttributeNames","Object","keys","currentAttributeNames","length","storedAttributeData","storedIndexVersion","currentIndexVersion","morphChanged","i","needsRefresh","nodeFrame","isStatic","static","isBundle","cyrb53","seed","h1","h2","Array","val","Math","imul","ch","charCodeAt","hashString","str","hashArray","array","hash$1","params","getCacheKey$1","force","values","childNode","push","getSelf","getNodeChildren","getCacheKey","node","toJSON","startsWith","isArray","child","subProperty","typeFromLength","Map","dataFromObject","getTypedArrayFromType","type","test","Int32Array","Uint32Array","Float32Array","getLengthFromType","console","error","getValueType","typeOf","isVector2","isVector3","isVector4","isMatrix2","isMatrix3","isMatrix4","isColor","ArrayBuffer","getValueFromType","last4","_three_core_js__WEBPACK_IMPORTED_MODULE_0__","Ilk","FM8","Pa4","Ltg","UcC","Vkp","yGw","base64ToArrayBuffer","getDataFromObject","arrayBufferToBase64","arrayBuffer","chars","Uint8Array","String","fromCharCode","btoa","base64","from","atob","c","buffer","NodeShaderStage","VERTEX","FRAGMENT","NodeUpdateType","NONE","FRAME","RENDER","OBJECT","NodeAccess","READ_ONLY","WRITE_ONLY","READ_WRITE","defaultShaderStages","defaultBuildStages","shaderStages","vectorComponents","_nodeId","Node","pBf","nodeType","updateType","updateBeforeType","updateAfterType","uuid","M8C","generateUUID","global","_cacheKey","_cacheKeyVersion","defineProperty","needsUpdate","onUpdate","callback","update","bind","onFrameUpdate","onRenderUpdate","onObjectUpdate","onReference","updateReference","self","isGlobal","getChildren","dispose","dispatchEvent","traverse","customCacheKey","getScope","getHash","getUpdateType","getUpdateBeforeType","getUpdateAfterType","getElementType","getNodeType","getMemberType","nodeProperties","getNodeProperties","outputNode","getShared","hash","nodeFromHash","getNodeFromHash","setup","analyze","usageCount","increaseUsage","build","generate","output","updateBefore","warn","updateAfter","refNode","addNode","addChain","result","buildStage","getBuildStage","properties","initialized","isNodeOutput","nodeData","getDataFromNode","snippet","flowCodes","nodeBlock","addFlowCodeHierarchy","format","removeChain","addSequentialNode","getSerializeChildren","serialize","json","nodeChildren","inputNodes","Number","isInteger","meta","deserialize","inputArray","inputObject","isRoot","textures","images","extractFromCache","cache","key","metadata","generator","ArrayElementNode","indexNode","isArrayElementNode","nodeSnippet","indexSnippet","ConvertNode","convertTo","requestType","overloadingType","split","getTypeLength","TempNode","isTempNode","hasDependencies","getVectorType","propertyName","nodeVar","getVarFromNode","getPropertyName","addLineFlowCode","JoinNode","getTypeFromLength","reduce","cur","primitiveType","getComponentType","snippetValues","input","inputSnippet","inputPrimitiveType","getType","join","_stringVectorComponents","SplitNode","components","isSplitNode","getVectorLength","vectorLength","max","indexOf","nodeTypeLength","SetNode","sourceNode","targetNode","sourceType","componentType","targetType","targetSnippet","sourceSnippet","component","FlipNode","sourceCache","sourceProperty","componentIndex","InputNode","isInputNode","precision","getInputType","setPrecision","toArray","valueType","fromArray","_regNum","ConstNode","isConstNode","generateConst","MemberNode","isMemberNode","currentStack","NodeElements","addMethodChaining","nodeElement","parseSwizzle","props","replace","parseSwizzleAndSort","sort","shaderNodeHandler","NodeClosure","nodeObjects","shift","prop","nodeObj","isStackNode","assign","add","endsWith","nodeObject","toLowerCase","Reflect","nodeObjectsCacheMap","nodeBuilderFunctionsCacheMap","ShaderNodeObject","obj","altType","Proxy","getConstNode","Fn","ShaderNodeObjects","objects","ShaderNodeArray","len","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","nodeArray","ShaderNodeImmutable","ShaderCallNodeInternal","shaderNode","getOutputNode","call","onceOutput","layout","functionNodesCacheMap","functionNode","buildFunctionNode","currentFunctionNode","includes","jsFunc","once","setupOutput","addStack","stack","removeStack","ShaderNodeInternal","setLayout","inputs","floats","PI","boolsCacheMap","bool","uintsCacheMap","uint","intsCacheMap","map","el","int","floatsCacheMap","float","constNodesCacheMap","safeGetNodeType","_","ConvertType","cacheMap","every","param","defined","v","getConstNodeType","ShaderNode","nodeProxy","nodeImmutable","fn","setCurrentStack","getCurrentStack","If","append","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat2","mat3","mat4","element","convert","types","ArrayNode","isArrayNode","generateArray","fill","UniformGroupNode","shared","order","isUniformGroup","uniformGroup","sharedUniformGroup","frameGroup","renderGroup","objectGroup","UniformNode","isUniformNode","groupNode","label","setGroup","group","getGroup","getUniformHash","frame","sharedNode","setHashNode","sharedNodeType","nodeUniform","getUniformFromNode","shaderStage","uniform","arg1","arg2","PropertyNode","varying","isPropertyNode","getVaryingFromNode","needsInterpolation","varyingProperty","diffuseColor","emissive","roughness","metalness","clearcoat","clearcoatRoughness","sheen","sheenRoughness","iridescence","iridescenceIOR","iridescenceThickness","alphaT","anisotropy","anisotropyT","anisotropyB","specularColor","specularF90","shininess","dashSize","gapSize","pointWidth","ior","thickness","attenuationDistance","attenuationColor","dispersion","AssignNode","needsSplitAssign","isAvailable","targetLength","target","source","sourceVar","targetRoot","FunctionCallNode","parameters","setParameters","getParameters","getInputs","generateInput","inputNode","functionName","func","OperatorNode","op","aNode","bNode","finalOp","isOperatorNode","typeA","typeB","getIntegerType","typeLength","isMatrix","isVector","getVectorFromMatrix","changeComponentType","a","b","outputLength","fnOpSnippet","getFunctionOperator","useComparisonMethod","getMethod","sub","mul","div","modInt","equal","notEqual","lessThan","greaterThan","lessThanEqual","greaterThanEqual","and","or","not","xor","bitAnd","bitNot","bitOr","bitXor","shiftLeft","shiftRight","remainder","MathNode","method","cNode","isMathNode","aType","bType","cType","aLen","bLen","cLen","LENGTH","DISTANCE","DOT","CROSS","ALL","EQUALS","MOD","inputType","coordinateSystem","TRANSFORM_DIRECTION","tA","tB","normalize","xyz","NEGATE","ONE_MINUS","RECIPROCAL","DIFFERENCE","abs","_RZ","STEP","MIN","MAX","REFRACT","MIX","JCZ","ATAN","ANY","RADIANS","DEGREES","EXP","EXP2","LOG","LOG2","SQRT","INVERSE_SQRT","FLOOR","CEIL","NORMALIZE","FRACT","SIN","COS","TAN","ASIN","ACOS","ABS","SIGN","DFDX","DFDY","ROUND","TRUNC","FWIDTH","TRANSPOSE","BITCAST","REFLECT","POW","CLAMP","SMOOTHSTEP","FACEFORWARD","EPSILON","INFINITY","PI2","all","any","radians","degrees","exp","exp2","log","log2","sqrt","inverseSqrt","floor","ceil","fract","sin","cos","tan","asin","acos","atan","sign","negate","oneMinus","dFdx","dFdy","round","reciprocal","trunc","fwidth","transpose","bitcast","min$1","max$1","mod","step","reflect","distance","difference","dot","cross","pow","pow2","pow3","pow4","transformDirection","cbrt","lengthSq","mix","clamp","low","high","saturate","refract","smoothstep","faceForward","rand","uv","xy","mixElement","t","e1","e2","smoothstepElement","x","atan2","y","ConditionalNode","condNode","ifNode","elseNode","ifType","elseType","currentNodeBlock","parentNodeBlock","nodeProperty","needsOutput","addFlowCode","tab","addFlowTab","ifSnippet","removeFlowTab","elseSnippet","select","cond","ContextNode","isContextNode","previousContext","getContext","setContext","VarNode","readOnly","isVarNode","isWebGPUBackend","backend","isDeterministic","shouldTreatAsReadOnly","vectorType","declarationPrefix","getArrayCount","getVar","createVar","Var","Const","temp","VaryingNode","isVaryingNode","setupVarying","needsReassign","reassignPosition","needsPositionReassign","flowNodeFromShaderStage","isPositionNodeInput","vertexStage","sRGBTransferEOTF","sRGBTransferOETF","WORKING_COLOR_SPACE","OUTPUT_COLOR_SPACE","ColorSpaceNode","colorNode","resolveColorSpace","colorSpace","epp","workingColorSpace","outputColorSpace","enabled","getTransfer","j17","rgb","getPrimaries","_getMatrix","toOutputColorSpace","toWorkingColorSpace","workingToColorSpace","colorSpaceToWorking","ReferenceElementNode$1","referenceNode","isReferenceElementNode","uniformType","arrayType","elementType","ReferenceBaseNode","reference","setNodeType","updateValue","getValueFromReference","state","reference$1","RendererReferenceNode","rendererReference","ToneMappingNode","toneMapping","exposureNode","toneMappingExposure","uL9","toneMappingFn","library","getToneMappingFunction","mapping","exposure","BufferAttributeNode","bufferType","bufferStride","bufferOffset","isBufferNode","usage","W2J","instanced","isBufferAttribute","isInstancedBufferAttribute","bufferData","globalCache","getData","setData","getTypeFromAttribute","itemSize","stride","offset","isInterleavedBuffer","vpT","bufferAttribute","kB5","setUsage","nodeAttribute","getBufferAttributeFromNode","nodeVarying","setInstanced","dynamicBufferAttribute","dj0","instancedBufferAttribute","instancedDynamicBufferAttribute","bufferNode","ComputeNode","computeNode","workgroupSize","isComputeNode","dispatchCount","onInitFunction","updateDispatchCount","size","onInit","compute","CacheNode","parent","isCacheNode","previousCache","getCache","getCacheFromNode","setCache","BypassNode","callNode","isBypassNode","bypass","RemapNode","inLowNode","inHighNode","outLowNode","outHighNode","doClamp","remap","remapClamp","ExpressionNode","expression","Discard","conditional","RenderOutputNode","isRenderOutputNode","aCh","renderOutput","AttributeNode","attributeName","_attributeName","getAttributeName","hasGeometryAttribute","getAttribute","setAttributeName","geometryAttribute","attributeType","TextureSizeNode","textureNode","levelNode","isTextureSizeNode","textureProperty","level","textureSize","MaxMipLevelNode","_textureNode","texture","image","maxMipLevel","TextureNode","uvNode","biasNode","isTextureNode","compareNode","depthNode","gradNode","sampler","updateMatrix","_value","_matrixUniform","setUpdateMatrix","isDepthTexture","JQ4","Kz5","getDefaultUV","channel","getTransformedUV","matrix","setupUV","isFlipY","ImageBitmap","flipY","isRenderTargetTexture","isFramebufferTexture","setY","forceUVContext","getUV","getTextureLevel","generateUV","generateSnippet","uvSnippet","levelSnippet","biasSnippet","depthSnippet","compareSnippet","gradSnippet","generateTextureLevel","generateTextureBias","generateTextureGrad","generateTextureCompare","generateTextureLoad","generateTexture","isReference","needsToWorkingColorSpace","setSampler","getSampler","sample","blur","amountNode","bias","compare","grad","gradNodeX","gradNodeY","depth","matrixUniform","matrixAutoUpdate","newNode","textureLoad","BufferNode","bufferCount","UniformArrayElementNode","uniformArrayNode","isArrayBufferElementNode","paddedType","getPaddedType","UniformArrayNode","isArrayBufferNode","charAt","vector","r","g","elements","z","w","paddedElementLength","uniformArray","cameraIndex","toVarying","cameraNear","camera","near","cameraFar","far","cameraProjectionMatrix","isArrayCamera","cameras","matrices","subCamera","projectionMatrix","cameraProjectionMatrices","toVar","cameraProjectionMatrixInverse","projectionMatrixInverse","cameraViewMatrix","matrixWorldInverse","cameraViewMatrices","cameraWorldMatrix","cameraNormalMatrix","normalMatrix","cameraPosition","setFromMatrixPosition","Object3DNode","object3d","_uniformNode","WORLD_MATRIX","POSITION","VIEW_POSITION","DIRECTION","SCALE","uniformNode","setFromMatrixScale","getWorldDirection","applyMatrix4","objectDirection","objectWorldMatrix","objectPosition","objectScale","objectViewPosition","ModelNode","modelDirection","modelWorldMatrix","modelPosition","modelScale","modelViewPosition","modelNormalMatrix","getNormalMatrix","modelWorldMatrixInverse","invert","mediumpModelViewMatrix","highpModelViewMatrix","isHighPrecisionModelViewMatrix","multiplyMatrices","highpModelNormalViewMatrix","positionGeometry","positionLocal","positionPrevious","positionWorld","positionWorldDirection","positionView","setupPositionView","positionViewDirection","FrontFacingNode","isFrontFacingNode","side","_Li","getFrontFacing","frontFacing","faceDirection","normalGeometry","normalLocal","hasAttribute","normalFlat","normalView","flatShading","transformNormalToView","normalWorld","transformedNormalView","setupNormal","transformedNormalWorld","transformedClearcoatNormalView","setupClearcoatNormal","transformNormal","normal","m","transformedNormal","materialRefractionRatio","refractionRatio","reflectView","refractView","reflectVector","refractVector","CubeTextureNode","isCubeTextureNode","fY$","vxC","yz","cubeUV","cubeTexture","ReferenceElementNode","ReferenceNode","referenceBuffer","MaterialReferenceNode","isMaterialReferenceNode","materialReference","tangentGeometry","computeTangents","tangentLocal","tangentView","tangentWorld","transformedTangentView","transformedTangentWorld","bitangentGeometry","crossNormalTangent","bitangentLocal","bitangentView","bitangentWorld","transformedBitangentView","getBitangent","transformedBitangentWorld","TBNViewMatrix","parallaxDirection","transformedBentNormalView","bentNormal","perturbNormal2Arb","eye_pos","surf_norm","mapN","q0","q1","st0","st1","q1perp","q0perp","N","T","B","det","scale","NormalMapNode","scaleNode","normalMapType","IOt","normalMap","PA7","tangent","dHdxy_fwd","bumpScale","sampleTexture","texNode","Hll","perturbNormalArb","surf_pos","dHdxy","vSigmaX","R1","vSigmaY","R2","vN","fDet","vGrad","BumpMapNode","bumpMap","_propertyCache","MaterialNode","getFloat","getColor","getTexture","COLOR","OPACITY","opacityNode","alphaMap","SPECULAR_STRENGTH","specularMap","SPECULAR_INTENSITY","specularIntensityNode","specularIntensityMap","SPECULAR_COLOR","specularColorNode","specularColorMap","ROUGHNESS","roughnessNode","roughnessMap","METALNESS","metalnessNode","metalnessMap","EMISSIVE","emissiveIntensityNode","emissiveNode","emissiveMap","NORMAL","CLEARCOAT","clearcoatNode","clearcoatMap","CLEARCOAT_ROUGHNESS","clearcoatRoughnessNode","clearcoatRoughnessMap","CLEARCOAT_NORMAL","clearcoatNormalMap","SHEEN","sheenNode","sheenColorMap","SHEEN_ROUGHNESS","sheenRoughnessNode","sheenRoughnessMap","ANISOTROPY","anisotropyMap","anisotropyPolar","anisotropyMat","materialAnisotropyVector","rg","IRIDESCENCE_THICKNESS","iridescenceThicknessMaximum","iridescenceThicknessRange","iridescenceThicknessMap","iridescenceThicknessMinimum","TRANSMISSION","transmissionNode","transmissionMap","THICKNESS","thicknessNode","thicknessMap","IOR","LIGHT_MAP","AO","outputType","ALPHA_TEST","SHININESS","SPECULAR","REFLECTIVITY","ROTATION","IRIDESCENCE","IRIDESCENCE_IOR","ATTENUATION_DISTANCE","ATTENUATION_COLOR","LINE_SCALE","LINE_DASH_SIZE","LINE_GAP_SIZE","LINE_WIDTH","LINE_DASH_OFFSET","POINT_SIZE","DISPERSION","materialAlphaTest","materialColor","materialShininess","materialEmissive","materialOpacity","materialSpecular","materialSpecularIntensity","materialSpecularColor","materialSpecularStrength","materialReflectivity","materialRoughness","materialMetalness","materialNormal","materialClearcoat","materialClearcoatRoughness","materialClearcoatNormal","materialRotation","materialSheen","materialSheenRoughness","materialAnisotropy","materialIridescence","materialIridescenceIOR","materialIridescenceThickness","materialTransmission","materialThickness","materialIOR","materialAttenuationDistance","materialAttenuationColor","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineWidth","materialLineDashOffset","materialPointSize","materialDispersion","materialLightMap","materialAO","anisotropyRotation","modelViewProjection","setupModelViewProjection","IndexNode","isIndexNode","getVertexIndex","INSTANCE","getInstanceIndex","DRAW","getDrawIndex","INVOCATION_LOCAL","getInvocationLocalIndex","INVOCATION_SUBGROUP","getInvocationSubgroupIndex","SUBGROUP","getSubgroupIndex","vertexIndex","instanceIndex","subgroupIndex","invocationSubgroupIndex","invocationLocalIndex","drawIndex","InstanceNode","instanceMatrix","instanceColor","instanceMatrixNode","instanceColorNode","bufferColor","$TI","bufferFn","lb7","instancePosition","instanceNormal","instance","InstancedMeshNode","instancedMesh","BatchNode","batchMesh","batchingIdNode","indirectId","getIndirectIndex","_indirectTexture","matricesTexture","_matricesTexture","j","toInt","batchingMatrix","colorsTexture","_colorsTexture","getBatchingColor","bm","batchingNormal","mulAssign","batch","_frameId","SkinningNode","skinnedMesh","useReference","bindMatrixNode","bindMatrixInverseNode","boneMatricesNode","skinIndexNode","skinWeightNode","skeleton","bones","bindMatrix","bindMatrixInverse","boneMatrices","previousBoneMatricesNode","getSkinnedPosition","position","boneMatX","boneMatY","boneMatZ","boneMatW","skinVertex","skinned","getSkinnedNormal","skinMatrix","getPreviousSkinnedPosition","previousBoneMatrices","needsPreviousBoneMatrices","mrt","getMRT","useVelocity","skinPosition","skinNormal","frameId","skinningReference","LoopNode","getVarName","getProperties","stackNode","l","returnsNode","end","condition","internalParam","startSnippet","endSnippet","declarationSnippet","conditionalSnippet","updateSnippet","forSnippet","stackSnippet","returnsSnippet","Loop","Break","_morphTextures","_morphVec4","getMorph","bufferMap","influence","texelIndex","bufferAttrib","MorphNode","mesh","morphBaseInfluence","hasMorphPosition","morphAttributes","hasMorphNormals","morphAttribute","morphTargetsCount","getEntry","hasMorphColors","entry","morphTargets","morphNormals","morphColors","vertexDataCount","bufferTexture","p3g","VzW","vertexDataStride","morphTarget","morphNormal","morphColor","fromBufferAttribute","addEventListener","disposeTexture","delete","removeEventListener","morphTexture","addAssign","morphTargetsRelative","morphReference","LightingNode","isLightingNode","AONode","aoNode","ambientOcclusion","LightingContextNode","lightingModel","backdropNode","backdropAlphaNode","directDiffuse","directSpecular","indirectDiffuse","indirectSpecular","radiance","irradiance","iblIrradiance","reflectedLight","backdrop","backdropAlpha","lightingContext","IrradianceNode","ScreenNode","isViewportNode","VIEWPORT","SIZE","renderTarget","getRenderTarget","viewport","getViewport","multiplyScalar","getPixelRatio","getDrawingBufferSize","screenCoordinate","screenSize","COORDINATE","coord","getFragCoord","UV","screenUV","viewportSize","zw","viewportCoordinate","viewportUV","viewportResolution","viewportTopLeft","viewportBottomLeft","_size$4","ViewportTextureNode","framebufferTexture","Wzm","minFilter","D1R","generateMipmaps","isOutputTextureNode","currentGenerateMipmaps","copyFramebufferToTexture","viewportTextureNode","viewportTexture","viewportMipTexture","sharedDepthbuffer","ViewportDepthTextureNode","$YQ","viewportDepthTexture","ViewportDepthNode","valueNode","isViewportDepthNode","DEPTH_BASE","getFragDepth","depthBase","DEPTH","isPerspectiveCamera","viewZToPerspectiveDepth","viewZToOrthographicDepth","LINEAR_DEPTH","perspectiveDepthToViewZ","viewZ","viewZToLogarithmicDepth","numerator","denominator","linearDepth","viewportLinearDepth","BuiltinNode","isBuiltinNode","builtin","ClippingNode","DEFAULT","intersectionPlanes","unionPlanes","clippingContext","hardwareClipping","ALPHA_TO_COVERAGE","setupAlphaToCoverage","HARDWARE","setupHardwareClipping","setupDefault","distanceToPlane","distanceGradient","clipOpacity","numUnionPlanes","clippingPlanes","plane","numIntersectionPlanes","intersectionClipOpacity","discard","clipped","enableHardwareClipping","hw_clip_distances","getClipDistance","clipping","clippingAlpha","hash2D","hash3D","getAlphaHashThreshold","maxDeriv","pixScale","pixScales","alpha","lerpFactor","cases","NodeMaterial","F5T","isNodeMaterial","fog","lights","lightsNode","envNode","normalNode","alphaTestNode","positionNode","geometryNode","shadowPositionNode","receivedShadowNode","castShadowNode","mrtNode","fragmentNode","vertexNode","customProgramCacheKey","setupObserver","resultNode","setupVertex","addFlow","clippingNode","setupClipping","depthWrite","depthTest","depthBuffer","setupDepth","setupDiffuseColor","setupVariants","outgoingLightNode","setupLighting","basicOutput","materialMRT","merge","isOutputStructNode","observer","samples","alphaToCoverage","candidateCount","logarithmicDepthBuffer","setupPosition","vertex","displacementMap","displacementScale","displacementBias","isBatchedMesh","isInstancedMesh","vertexColors","batchColor","alphaTest","alphaHash","transparent","blending","bdR","setupOutgoingLight","setupEnvironment","envMap","isCubeTexture","setupLightMap","lightMap","setupLights","materialLightsNode","lightMapNode","aoMap","lightsN","lighting","createNode","getLights","setupLightingModel","hasLights","fogNode","setDefaultValues","descriptors","getOwnPropertyDescriptors","prototype","getOwnPropertyDescriptor","_defaultValues$d","nls","LineBasicNodeMaterial","isLineBasicNodeMaterial","setValues","_defaultValues$c","FT0","LineDashedNodeMaterial","isLineDashedNodeMaterial","dashOffset","offsetNode","dashScaleNode","dashSizeNode","gapSizeNode","vLineDistance","vLineDistanceOffset","_sharedFramebuffer","ViewportSharedTextureNode","viewportSharedTexture","directionToColor","_defaultValues$a","RSm","MeshNormalNodeMaterial","isMeshNormalNodeMaterial","EquirectUVNode","dirNode","dir","equirectUV","CubeRenderTarget","oAp","options","isCubeRenderTarget","fromEquirectangularTexture","texture$1","currentMinFilter","magFilter","DvJ","jFi","Kj0","scene","xsS","wem","_am","currentMRT","setMRT","_cache$1","CubeMapNode","_cubeTexture","_cubeTextureNode","defaultTexture","BtG","_defaultTexture","dSO","Bf4","cubeMap","mapTextureMapping","onTextureDispose","event","cubeMapNode","BasicEnvironmentNode","environment","BasicLightMapNode","RECIPROCAL_PI","irradianceLightMap","LightingModel","finish","direct","directRectArea","indirect","BasicLightingModel","outgoingLight","combine","Ns1","qhX","NDo","_defaultValues$9","vBJ","MeshBasicNodeMaterial","isMeshBasicNodeMaterial","F_Schlick","f0","f90","dotVH","fresnel","BRDF_Lambert","G_BlinnPhong_Implicit","D_BlinnPhong","dotNH","BRDF_BlinnPhong","lightDirection","halfDir","F","G","D","PhongLightingModel","specular","lightColor","dotNL","_defaultValues$8","YBo","MeshLambertNodeMaterial","isMeshLambertNodeMaterial","_defaultValues$7","xoR","MeshPhongNodeMaterial","isMeshPhongNodeMaterial","shininessNode","specularNode","getGeometryRoughness","dxy","getRoughness","geometryRoughness","roughnessFactor","min","V_GGX_SmithCorrelated","dotNV","a2","gv","gl","V_GGX_SmithCorrelated_Anisotropic","alphaB","dotTV","dotBV","dotTL","dotBL","qualifier","D_GGX","denom","D_GGX_Anisotropic","dotTH","dotBH","v2","w2","BRDF_GGX","V","f","USE_IRIDESCENCE","USE_ANISOTROPY","DFGApprox","c0","c1","a004","EnvironmentBRDF","fab","Schlick_to_F0","x2","x5","D_Charlie","invAlpha","sin2h","cos2h","V_Neubelt","BRDF_Sheen","LTC_Uv","LTC_ClippedSphereFormFactor","LTC_EdgeVectorFormFactor","v1","theta_sintheta","LTC_Evaluate","P","mInv","p0","p1","p2","p3","lightNormal","T1","T2","mat","coords0","coords1","coords2","coords3","vectorFormFactor","bC","w0","w1","w3","g0","g1","h0","bicubic","texelSize","lod","uvScaled","iuv","fuv","g0x","g1x","h0x","h1x","h0y","h1y","textureBicubic","lodNode","fLodSize","cLodSize","fLodSizeInv","cLodSizeInv","fSample","cSample","getVolumeTransmissionRay","n","modelMatrix","refractionVector","applyIorToRoughness","viewportBackSideTexture","viewportFrontSideTexture","getTransmissionSample","fragCoord","vTexture","volumeAttenuation","transmissionDistance","attenuationCoefficient","getIBLVolumeRefraction","viewMatrix","projMatrix","transmittedLight","transmittance","halfSpread","iors","transmissionRay","refractedRayExit","ndcPos","refractionCoords","divAssign","transmissionSample","attenuatedColor","transmittanceFactor","XYZ_TO_REC709","Fresnel0ToIor","sqrtF0","fresnel0","IorToFresnel0","transmittedIor","incidentIor","evalSensitivity","OPD","phase","pos","VAR","evalIridescence","outsideIOR","eta2","cosTheta1","thinFilmThickness","baseF0","cosTheta2Sq","sinTheta2Sq","cosTheta2","R12","T121","phi12","phi21","baseIOR","R23","toVec3","phi23","phi","R123","r123","Rs","I","C0","Cm","Sm","IBLSheenBRDF","viewDir","r2","DG","clearcoatF0","clearcoatF90","PhysicalLightingModel","clearcoatRadiance","clearcoatSpecularDirect","clearcoatSpecularIndirect","sheenSpecularDirect","sheenSpecularIndirect","iridescenceFresnel","iridescenceF0","dotNVi","computeMultiscattering","singleScatter","multiScatter","FssEss","Fr","Ems","Ess","Favg","Fms","ccIrradiance","dotNLcc","lightPosition","halfWidth","halfHeight","ltc_1","ltc_2","t1","t2","clearcoatEnv","singleScattering","multiScattering","cosineWeightedIrradiance","totalScattering","diffuse","aoNV","aoExp","Fcc","clearcoatLight","sheenEnergyComp","sheenLight","cubeUV_r0","cubeUV_m0","cubeUV_r1","cubeUV_m1","cubeUV_r4","cubeUV_m4","cubeUV_r5","cubeUV_m5","cubeUV_r6","cubeUV_m6","cubeUV_minMipLevel","cubeUV_minTileSize","getFace","direction","absDirection","face","Else","ElseIf","roughnessToMip","mip","getDirection","uv_immutable","zyx","xzy","xz","textureCubeUV","sampleDir_immutable","roughness_immutable","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","sampleDir","mipF","mipInt","color0","bilinearCubeUV","color1","direction_immutable","mipInt_immutable","filterInt","faceSize","subAssign","getSample","outputDirection","theta","axis","cosTheta","latitudinal","poleAxis","weights","dTheta","gl_FragColor","_generator","_cache","PMREMNode","_pmrem","xEZ","_texture","_width","_height","_maxMip","updateFromTexture","cubeUVSize","_generateCubeUVSize","imageHeight","maxMip","texelWidth","texelHeight","pmrem","pmremVersion","isPMREMTexture","_getPMREMFromTexture","cacheTexture","isCubeMapReady","fromCubemap","fromEquirectangular","createPMREMGenerator","pmremTexture","_envNodeCache","EnvironmentNode","cacheEnvNode","intensity","radianceNormalView","useAnisotropy","createRadianceContext","createIrradianceContext","isolateRadiance","isolateIrradiance","isolateClearcoatRadiance","normalViewNode","reflectVec","normalWorldNode","_defaultValues$6","Wid","MeshStandardNodeMaterial","isMeshStandardNodeMaterial","environmentNode","setupSpecular","_defaultValues$5","EJi","MeshPhysicalNodeMaterial","isMeshPhysicalNodeMaterial","clearcoatNormalNode","iridescenceNode","iridescenceIORNode","iridescenceThicknessNode","iorNode","attenuationDistanceNode","attenuationColorNode","dispersionNode","anisotropyNode","useClearcoat","useIridescence","useSheen","useTransmission","useDispersion","anisotropyV","getGradientIrradiance","gradientMap","fw","ToonLightingModel","_defaultValues$4","IKL","MeshToonNodeMaterial","isMeshToonNodeMaterial","MatcapUVNode","matcapUV","_defaultValues$3","kaV","MeshMatcapNodeMaterial","isMeshMatcapNodeMaterial","matcapColor","matcap","RotateNode","rotationNode","cosAngle","sinAngle","rotationMatrix","rotationXMatrix","rotation","rotationYMatrix","rotationZMatrix","rotate","_defaultValues$2","xeV","SpriteNodeMaterial","isSpriteNodeMaterial","_useSizeAttenuation","sizeAttenuation","mvPosition","orthoScale","alignedPosition","rotatedPosition","_defaultValues$1","UY4","PointsNodeMaterial","sizeNode","isPointsNodeMaterial","mvp","aspect","pointSize","_useAlphaToCoverage","ShadowMaskModel","shadowNode","shadowMask","_defaultValues","Tn7","ShadowNodeMaterial","isShadowNodeMaterial","ret","Texture3DNode","isTexture3DNode","texture3D","Animation","info","_context","_animationLoop","_requestId","time","requestAnimationFrame","autoReset","reset","stop","cancelAnimationFrame","getAnimationLoop","setAnimationLoop","ChainMap","weakMap","_id$9","RenderObject","geometries","renderContext","_nodes","_geometries","pipeline","vertexBuffers","drawParams","clippingContextCacheKey","cacheKey","initialNodesCacheKey","getDynamicCacheKey","initialCacheKey","_nodeBuilderState","_bindings","_monitor","onDispose","isRenderObject","onMaterialDispose","updateClipping","clippingNeedsUpdate","hardwareClippingPlanes","unionClippingCount","getNodeBuilderState","getForRender","getMonitor","getBindings","createBindings","getBindingGroup","bindingGroup","getIndex","getIndirect","getChainArray","setGeometry","getAttributes","nodeAttributes","Set","isInterleavedBufferAttribute","getVertexBuffers","getDrawParameters","vertexCount","firstVertex","instanceCount","firstInstance","isInstancedBufferGeometry","rangeFactor","wireframe","isPoints","isLineSegments","isLine","isLineLoop","lastVertex","itemCount","Infinity","getGeometryCacheKey","normalized","targets","getMaterialCacheKey","getKeys","proto","getPrototypeOf","descriptor","valueKey","receiveShadow","needsGeometryUpdate","isShadowPassMaterial","_chainKeys$5","RenderObjects","pipelines","bindings","chainMaps","passId","chainMap","getChainMap","createRenderObject","DataMap","AttributeType","INDEX","STORAGE","INDIRECT","Attributes","attributeData","destroyAttribute","createAttribute","createIndexAttribute","createStorageAttribute","createIndirectStorageAttribute","_getBufferAttribute","updateAttribute","getWireframeVersion","getWireframeIndex","indices","geometryIndex","geometryPosition","H7L","lCJ","qlB","Geometries","wireframes","attributeCall","updateForRender","initGeometry","updateAttributes","memory","geometryAttributes","wireframeAttribute","isStorageBufferAttribute","isStorageInstancedBufferAttribute","callId","render","calls","Info","frameCalls","drawCalls","triangles","points","lines","timestamp","isMesh","isSprite","Pipeline","usedTimes","RenderPipeline","vertexProgram","fragmentProgram","ComputePipeline","computeProgram","isComputePipeline","_id$8","ProgrammableStage","code","stage","transforms","Pipelines","caches","programs","fragment","getForCompute","_needsComputeUpdate","previousPipeline","nodeBuilderState","stageCompute","computeShader","_releaseProgram","createProgram","_getComputeCacheKey","_releasePipeline","_getComputePipeline","promises","_needsRenderUpdate","stageVertex","vertexShader","stageFragment","fragmentShader","_getRenderCacheKey","_getRenderPipeline","createComputePipeline","createRenderPipeline","getRenderCacheKey","program","needsRenderUpdate","Bindings","bindGroup","groupData","_init","updateForCompute","_updateBindings","_update","binding","isSampledTexture","updateTexture","isStorageBuffer","isIndirectStorageBufferAttribute","needsBindingsUpdate","cacheBindings","cacheIndex","isNodeUniformsGroup","updated","updateGroup","isUniformBuffer","updateBinding","isSampler","texturesTextureData","generation","textureData","externalTexture","isDefaultTexture","isStorageTexture","store","needsMipmap","needsMipmaps","updateBindings","painterSortStable","groupOrder","renderOrder","reversePainterSortStable","needsDoublePass","hasTransmission","ehD","forceSinglePass","RenderList","renderItems","renderItemsIndex","opaque","transparentDoublePass","bundles","getNode","lightsArray","occlusionQueryCount","begin","getNextRenderItem","renderItem","occlusionTest","unshift","pushBundle","pushLight","light","customOpaqueSort","customTransparentSort","setLights","il","_chainKeys$4","RenderLists","lists","list","_id$7","RenderContext","clearColor","clearColorValue","clearDepth","clearDepthValue","stencil","clearStencil","clearStencilValue","viewportValue","scissor","scissorValue","depthTexture","activeCubeFace","activeMipmapLevel","sampleCount","isRenderContext","_chainKeys$3","_defaultScene","_defaultCamera","V1s","RenderContexts","attachmentState","stencilBuffer","_getChainMap","renderState","getForClear","_size$3","Textures","updateRenderTarget","renderTargetData","depthTextureMips","getSize","mipWidth","mipHeight","useDepthTexture","textureNeedsUpdate","brP","qkB","wJv","isXRRenderTarget","_destroyTexture","isRenderTarget","destroySampler","destroyTexture","ywz","levels","getMipLevels","createSampler","createTexture","complete","dataReady","mipmaps","createDefaultTexture","isCompressedTexture","isEnvironmentTexture","Color4","ParameterNode","isParameterNode","StackNode","_currentCond","boolNode","methodNode","previousStack","else","elseif","StructTypeNode","membersLayout","entries","atomic","isStructLayoutNode","getLength","member","find","structType","getStructTypeFromNode","StructNode","structLayoutNode","isStructNode","generateStruct","OutputStructNode","members","getOutputStructTypeFromNode","getOutputStructName","structPrefix","outputStruct","getTextureIndex","MRTNode","outputNodes","isMRTNode","toUint","word","toFloat","parabola","k","tri","tri3","p","triNoise3D","speed","rz","bp","dg","FunctionOverloadingNode","functionNodes","parametersNodes","_candidateFnCall","candidateFnCall","candidateFn","candidateScore","score","overloadingBaseFn","overloadingFn","deltaTime","rotateUV","spherizeUV","strength","delta","delta2","deltaOffset","delta4","billboarding","horizontal","vertical","viewportSafeUV","depthDiff","SpriteSheetUVNode","countNode","frameNode","frameNum","column","row","uvFrameOffset","spritesheetUV","TriplanarTexturesNode","textureXNode","textureYNode","textureZNode","bf","tx","ty","zx","tz","textureX","textureY","textureZ","triplanarTextures","_reflectorPlane","JOQ","_normal","_reflectorWorldPosition","_cameraWorldPosition","_rotationMatrix","_lookAtPosition","clipPlane","_view","_target","_q","_size$2","_defaultRT","ACn","_defaultUV","flipX","_inReflector","ReflectorNode","_reflectorBaseNode","reflector","ReflectorBaseNode","_depthNode","getDepthNode","isQuadMesh","reflectorNode","Tme","resolution","bounces","virtualCameras","renderTargets","_updateResolution","setSize","getVirtualCamera","virtualCamera","cLu","FDw","extractRotation","subVectors","up","lookAt","updateMatrixWorld","setFromNormalAndCoplanarPoint","constant","visible","currentRenderTarget","currentAutoClear","autoClear","setRenderTarget","_camera","iKG","QuadGeometry","u9r","setAttribute","a$l","_geometry","QuadMesh","renderAsync","_size$1","RTTNode","pixelRatio","autoUpdate","_rttNode","_quadMesh","autoSize","getSharedContext","effectiveWidth","effectiveHeight","setPixelRatio","rtt","getViewPosition","screenPosition","clipSpacePosition","viewSpacePosition","getScreenPosition","viewPosition","sampleClipPos","sampleUv","getNormalFromDepth","l2","l1","r1","b2","b1","dl","dr","db","dt","ce","StorageInstancedBufferAttribute","typeClass","isView","StorageBufferAttribute","TlE","StorageArrayElementNode","storageBufferNode","isStorageArrayElementNode","structTypeNode","isPBO","setupPBO","isAssignContext","generatePBO","storageElement","StorageBufferNode","isStruct","isStorageBufferNode","access","isAtomic","_attribute","_varying","setPBO","getPBO","setAccess","toReadOnly","setAtomic","toAtomic","getAttributeData","registerTransform","storage","VertexColorNode","isVertexColorNode","PointUVNode","isPointUVNode","pointUV","_e1","USm","_m1","SceneNode","BACKGROUND_BLURRINESS","BACKGROUND_INTENSITY","BACKGROUND_ROTATION","background","xfE","backgroundRotation","makeRotationFromEuler","identity","backgroundBlurriness","backgroundIntensity","StorageTextureNode","storeNode","isStorageTextureNode","generateStore","toReadWrite","toWriteOnly","storeSnippet","generateTextureStore","storageTexture","UserDataNode","userData","_objectData","VelocityNode","previousModelWorldMatrix","previousProjectionMatrix","previousCameraViewMatrix","setProjectionMatrix","previousModelMatrix","getPreviousMatrix","cameraData","currentProjectionMatrix","currentCameraViewMatrix","previousModelViewMatrix","clipPositionCurrent","clipPositionPrevious","objectData","velocity","blendBurn","base","blend","blendDodge","blendScreen","blendOverlay","blendColor","outAlpha","grayscale","luminance","saturation","adjustment","vibrance","average","mx","amt","hue","luminanceCoefficients","getLuminanceCoefficients","cdl","slope","power","GUF","luma","pv","PosterizeNode","stepsNode","posterize","_size","PassTextureNode","passNode","PassMultipleTextureNode","textureName","previousTexture","getPreviousTexture","PassNode","_pixelRatio","_textures","_textureNodes","_linearDepthNodes","_viewZNodes","_previousTextures","_previousTextureNodes","_cameraNear","_cameraFar","_mrt","isPassNode","refTexture","toggleTexture","prevTexture","getTextureNode","getPreviousTextureNode","getViewZNode","viewZNode","getLinearDepthNode","linearDepthNode","isWebGLBackend","getColorBufferType","ToonOutlinePassNode","alphaNode","_materialCache","currentRenderObjectFunction","getRenderObjectFunction","setRenderObjectFunction","isMeshToonMaterial","outlineMaterial","_getOutlineMaterial","_createMaterial","isMeshToonOutlineMaterial","outlineNormal","ratio","pos2","norm","originalMaterial","linearToneMapping","reinhardToneMapping","cineonToneMapping","RRTAndODTFit","acesFilmicToneMapping","ACESInputMat","ACESOutputMat","LINEAR_REC2020_TO_LINEAR_SRGB","LINEAR_SRGB_TO_LINEAR_REC2020","agxDefaultContrastApprox","x_immutable","x4","agxToneMapping","colortone","AgXInsetMatrix","AgXOutsetMatrix","AgxMinEv","AgxMaxEv","neutralToneMapping","StartCompression","Desaturation","peak","d","newPeak","CodeNode","language","isCodeNode","setIncludes","getIncludes","include","nodeCode","getCodeFromNode","FunctionNode","getNodeFunction","nodeFunction","parser","parseFunction","getCode","nativeFn","ScriptableValueNode","events","isScriptableValueNode","isScriptableOutputNode","URL","revokeObjectURL","refresh","getValue","createObjectURL","Blob","scriptableValue","Resources","Parameters","scriptableNode","getLayout","getInputLayout","ScriptableNodeResources","ScriptableNode","codeNode","_local","_output","_outputs","_source","_method","_object","_needsOutputUpdate","onRefresh","isScriptableNode","setLocal","getLocal","_refresh","getOutputLayout","setOutput","outputs","getOutput","getParameter","setParameter","deleteParameter","getDefaultOutput","clearParameters","getObject","callAsync","getDefaultOutputNode","THREE","TSL","clear","_exec","interfaceProps","declarations","scriptable","getViewZ","rangeFogFactor","densityFogFactor","density","RangeNode","minNode","maxNode","minLength","maxLength","minValue","maxValue","setScalar","minElementValue","getComponent","maxElementValue","lerp","random","range","ComputeBuiltinNode","builtinName","_builtinName","getBuiltinName","setBuiltinName","hasBuiltin","computeBuiltin","numWorkgroups","workgroupId","globalId","localId","subgroupSize","BarrierNode","barrier","WorkgroupInfoElementNode","workgroupInfoNode","isWorkgroupInfoElementNode","WorkgroupInfoNode","isWorkgroupInfoNode","setScope","getScopedArray","AtomicFunctionNode","pointerNode","methodSnippet","varSnippet","ATOMIC_LOAD","ATOMIC_STORE","ATOMIC_ADD","ATOMIC_SUB","ATOMIC_MAX","ATOMIC_MIN","ATOMIC_AND","ATOMIC_OR","ATOMIC_XOR","atomicNode","atomicFunc","getLightData","uniforms","lightShadowMatrix","shadowMatrix","castShadow","shadow","updateMatrices","lightProjectionUV","projectionUV","spotLightCoord","lightTargetPosition","targetPosition","lightViewPosition","lightTargetDirection","sortLights","getLightNodeById","lightNodes","lightNode","isAnalyticLightNode","_lightsNodeRef","LightsNode","totalDiffuseNode","totalSpecularNode","_lights","_lightNodes","_lightNodesHash","lightIDs","setupLightsNode","previousLightNodes","nodeLibrary","lightNodeClass","getLightNodeClass","totalDiffuse","ShadowBaseNode","isShadowBaseNode","setupShadowPosition","shadowPositionWorld","shadowMaterialLib","linearDistance","dist","linearShadowDistance","nearDistance","farDistance","getShadowMaterial","isPointLight","BasicShadowFilter","shadowCoord","PCFShadowFilter","depthCompare","mapSize","radius","dx0","dy0","dx1","dy1","dx2","dy2","dx3","dy3","PCFSoftShadowFilter","dx","dy","VSMShadowFilter","occlusion","distribution","hardShadow","variance","softnessProbability","VSMPassVertical","shadowPass","mean","squaredMean","uvStride","uvStart","uvOffset","std_dev","VSMPassHorizontal","_shadowFilterLib","ShadowNode","shadowMap","vsmShadowMapVertical","vsmShadowMapHorizontal","vsmMaterialVertical","vsmMaterialHorizontal","_node","isShadowNode","setupShadowFilter","filterFn","frustumTest","setupShadowCoord","shadowPosition","coordZ","isOrthographicCamera","cameraNearLocal","cameraFarLocal","getShadowFilterFn","setupShadow","shadowMapType","compareFunction","D67","createRenderTarget","updateProjectionMatrix","dwk","av9","shadowPassVertical","shadowPassHorizontal","shadowIntensity","normalBias","filterNode","shadowDepthTexture","shadowTexture","shadowColor","shadowOutput","renderShadow","updateShadow","shadowType","depthVersion","_depthVersionCached","layers","mask","saveRendererState","getActiveCubeFace","getActiveMipmapLevel","renderObjectFunction","getClearColor","clearAlpha","getClearAlpha","scissorTest","getScissorTest","setClearColor","saveSceneState","backgroundNode","overrideMaterial","onBeforeShadow","onAfterShadow","vsmPass","setScissorTest","AnalyticLightNode","baseColorNode","shadowColorNode","setupShadowNode","customShadowNode","getDistanceAttenuation","lightDistance","cutoffDistance","decayExponent","distanceFalloff","_clearColor$2","cubeToUV","texelSizeY","absV","scaleToCube","planar","almostOne","almostATexel","signX","signY","BasicPointShadowFilter","bd3D","dp","PointShadowFilter","xyy","yyy","xyx","yyx","xxy","yxy","xxx","yxx","pointShadowFilter","lightToPosition","lightToPositionLength","_viewport","_viewportSize","_shadowMapSize","PointShadowNode","_MY","shadowFrameExtents","getFrameExtents","multiply","previousAutoClear","previousClearColor","previousClearAlpha","viewportCount","getViewportCount","vp","pointShadow","directPointLight","lVector","lightAttenuation","PointLightNode","cutoffDistanceNode","decayExponentNode","decay","checker","cx","cy","shapeCircle","len2","dlen","mx_select","b_immutable","t_immutable","f_immutable","mx_negate_if","val_immutable","mx_floor","mx_floorfrac","mx_bilerp","v0_immutable","v1_immutable","v2_immutable","v3_immutable","s_immutable","s","v3","v0","s1","mx_trilerp","v4_immutable","v5_immutable","v6_immutable","v7_immutable","r_immutable","v7","v6","v5","v4","mx_gradient_float","hash_immutable","y_immutable","h","u","z_immutable","mx_gradient_vec3","mx_gradient_scale2d_0","v_immutable","mx_gradient_scale3d_0","mx_gradient_scale2d","mx_gradient_scale3d","mx_rotl32","k_immutable","mx_bjmix","bitXorAssign","mx_bjfinal","a_immutable","c_immutable","mx_bits_to_01","bits_immutable","mx_fade","mx_hash_int_0","mx_hash_int_1","mx_hash_int","xx_immutable","xx","yy_immutable","yy","mx_hash_vec3","mx_perlin_noise_float","p_immutable","X","Y","fx","fy","Z","fz","mx_perlin_noise_vec3","mx_cell_noise_float_0","mx_cell_noise_float$1","ix","mx_cell_noise_vec3_0","mx_cell_noise_vec3","iy","iz","iw","mx_fractal_noise_float$1","octaves_immutable","lacunarity_immutable","diminish_immutable","diminish","lacunarity","octaves","amplitude","mx_fractal_noise_vec3$1","mx_fractal_noise_vec2$1","mx_fractal_noise_vec4$1","mx_worley_distance","xoff_immutable","yoff_immutable","jitter_immutable","metric_immutable","metric","jitter","yoff","xoff","tmp","off","cellpos","diff","zoff_immutable","zoff","mx_worley_noise_float_0","localpos","sqdist","mx_worley_noise_vec2_0","mx_worley_noise_vec3_0","mx_worley_noise_float$1","mx_worley_noise_vec2$1","mx_worley_noise_vec3$1","mx_hsvtorgb","hsv","hi","q","mx_rgbtohsv","mincomp","maxcomp","mx_srgb_texture_to_lin_rec709","color_immutable","isAbove","mx_aastep","threshold","afwidth","_ramp","_split","getParallaxCorrectNormal","cubeSize","cubePos","nDir","rbmax","rbmin","rbminmax","correction","boxIntersection","getShIrradianceAt","shCoefficients","freeze","__proto__","Continue","NodeType","BOOLEAN","INTEGER","FLOAT","VECTOR2","VECTOR3","VECTOR4","MATRIX2","MATRIX3","MATRIX4","Return","addNodeElement","atomicAdd","atomicAnd","atomicLoad","atomicMax","atomicMin","atomicOr","atomicStore","atomicSub","atomicXor","attributeArray","typedArray","burn","colorToDirection","convertColorSpace","sourceColorSpace","targetColorSpace","convertToTexture","densityFog","depthPass","dodge","faceforward","gain","glsl","src","glslFn","instancedArray","inversesqrt","js","logarithmicDepthToViewZ","exponent","E","loop","mx_cell_noise_float","texcoord","mx_contrast","amount","pivot","mx_fractal_noise_float","mx_fractal_noise_vec2","mx_fractal_noise_vec3","mx_fractal_noise_vec4","mx_noise_float","mx_noise_vec3","mx_noise_vec4","noise_vec4","mx_ramplr","valuel","valuer","mx_ramptb","valuet","valueb","mx_safepower","in1","in2","mx_splitlr","mx_splittb","mx_transform_uv","uv_scale","uv_offset","uv_geo","mx_worley_noise_float","mx_worley_noise_vec2","mx_worley_noise_vec3","orthographicDepthToViewZ","oscSawtooth","oscSine","oscSquare","oscTriangle","overlay","parallaxUV","parameter","pass","passTexture","pcurve","rangeFog","aTexture","screen","sinc","skinning","channels","storageBarrier","storageObject","string","struct","structLayout","names","textureBarrier","textureStore","timerDelta","timeScale","timerGlobal","timerLocal","toonOutlinePass","triplanarTexture","tslFn","vertexColor","wgsl","wgslFn","workgroupArray","workgroupBarrier","_clearColor$1","Background","renderList","getBackgroundNode","forceClear","_clearColor","getRGB","sceneData","backgroundMesh","backgroundMeshNode","viewProj","setZ","nodeMaterial","xo$","frustumCulled","onBeforeRender","copyPosition","backgroundCacheKey","environmentBlendMode","xr","getEnvironmentBlendMode","depthClearValue","_clearDepth","stencilClearValue","_clearStencil","autoClearColor","autoClearDepth","autoClearStencil","_id$6","BindGroup","bindingsReference","NodeBuilderState","updateNodes","updateBeforeNodes","updateAfterNodes","instanceGroup","bindingsGroup","instanceBinding","NodeAttribute","isNodeAttribute","NodeUniform","isNodeUniform","NodeVar","isNodeVar","NodeVarying","isNodeVarying","NodeCode","_id$5","NodeCache","nodesData","StructType","Uniform","boundary","setValue","NumberUniform","isNumberUniform","Vector2Uniform","isVector2Uniform","Vector3Uniform","isVector3Uniform","Vector4Uniform","isVector4Uniform","ColorUniform","isColorUniform","Matrix2Uniform","isMatrix2Uniform","Matrix3Uniform","isMatrix3Uniform","Matrix4Uniform","isMatrix4Uniform","NumberNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix2NodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","EXTRA_LOD_SIGMA","_flatCamera","_cubeCamera","cPb","_oldTarget","_oldActiveCubeFace","_oldActiveMipmapLevel","PHI","INV_PHI","_axisDirections","_uniformsMap","_faceLib","_direction","_outputDirection","PMREMGenerator","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_lodMeshes","_blurMaterial","_cubemapMaterial","_equirectMaterial","_backgroundBox","_hasInitialized","hasInitialized","fromScene","sigma","_setSize","cubeUVRenderTarget","_allocateTargets","fromSceneAsync","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","init","equirectangular","_setSizeFromTexture","fromEquirectangularAsync","_fromTexture","cubemap","fromCubemapAsync","compileCubemapShader","_getCubemapMaterial","_compileMaterial","compileEquirectangularShader","_getEquirectMaterial","_dispose","outputTarget","_setViewport","_textureToCubeUV","wk1","_createRenderTarget","sizeLods","lodPlanes","sigmas","lodMeshes","_createPlanes","lodMax","totalLods","sizeLod","uv1","positionSize","uvSize","faceIndex","faceIndexSize","coordinates","faceIdx","planes","_getBlurShader","materialUniforms","_getMaterial","tmpMesh","compile","cubeCamera","upSign","forwardSign","originalAutoClear","backgroundBox","backgroundMaterial","useSolidColor","col","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","sigmaPixels","STANDARD_DEVIATIONS","sum","weight","outputSize","g8_","envTexture","rendererCache","typeFromArray","Int8Array","Int16Array","Uint16Array","NodeBuilder","sequentialNodes","hashNodes","flowNodes","flowCode","structs","bindingsIndexes","bindGroups","bufferAttributes","varyings","codes","vars","flow","chaining","stacks","flowsData","getBindGroupsCache","bindGroupsCache","createCubeRenderTarget","_getBindGroup","groupName","bindingsArray","sharedGroup","getBindGroupArray","bindingsGroups","groups","groupUniforms","sortBindingGroups","buildUpdateNodes","currentNode","isFilteredTexture","qyh","aH4","lastChain","pop","generateTextureLod","generateArrayDeclaration","snippets","getComponentTypeFromTexture","isDataTexture","exec","baseType","prefix","getTypeFromArray","dataAttribute","e62","vecType","vecNum","newComponentType","lastStack","variable","idNS","flowCodeBlock","needsFlowCode","nodeBlockHierarchy","addLineFlowCodeBlock","codeBlock","getFlowData","flowNode","flowData","flowChildNode","previous","buildFunctionCode","flowShaderNode","Symbol","iterator","next","done","flowStagesNode","previousFlow","previousVars","previousBuildStage","setBuildStage","getVars","previousShaderStage","setShaderStage","getAttributesArray","concat","getVaryings","getUniforms","getCodes","getShaderStage","buildCode","fromMaterial","getNodeUniform","fromType","toType","fromTypeLength","toTypeLength","getSignature","UZH","createNodeMaterial","NodeFrame","updateMap","updateBeforeMap","updateAfterMap","_getMaps","referenceMap","nodeRef","maps","renderMap","frameMap","updateBeforeNode","updateAfterNode","updateNode","lastTime","performance","now","NodeFunctionInput","isConst","isNodeFunctionInput","DirectionalLightNode","_matrix41","_matrix42","_ltcLib","RectAreaLightNode","premultiply","LTC_FLOAT_1","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","setLTC","ltc","SpotLightNode","coneCosNode","penumbraCosNode","angle","penumbra","getSpotAttenuation","angleCosine","angleCos","spotAttenuation","projectedTexture","inSpotLightMap","IESSpotLightNode","iesMap","AmbientLightNode","HemisphereLightNode","lightPositionNode","lightDirectionNode","groundColorNode","groundColor","LightProbeNode","lightProbe","sh","coefficients","NodeParser","NodeFunction","isNodeFunction","declarationRegexp$1","propertiesRegexp$1","pragmaMain","parse$1","pragmaMainIndex","trim","mainCode","declaration","match","inputsCode","propsMatches","nameMatch","parseInt","isNaN","blockCode","substring","headerCode","GLSLNodeFunction","declarationCode","GLSLNodeParser","_outputNodeMap","_chainKeys$2","_cacheKeyValues","Nodes","nodeBuilderCache","callHashCache","groupsData","cacheLib","nodeUniformsGroup","uniformsGroupData","getForRenderCacheKey","nodeBuilder","createNodeBuilder","getEnvironmentNode","getFogNode","_createNodeBuilderState","computeData","updateEnvironment","updateBackground","updateFog","cacheKeyData","isToneMappingState","forceUpdate","getCacheNode","nodeCache","sceneFog","isFogExp2","isFog","getNodeFrame","getNodeFrameForRender","getOutputCacheKey","currentColorSpace","hasOutputChange","monitor","_plane","ClippingContext","parentContext","clipIntersection","viewNormalMatrix","clippingGroupContexts","parentVersion","projectPlanes","destination","updateGlobal","clippingGroup","dstClippingPlanes","srcClippingPlanes","getGroupContext","clipShadows","RenderBundle","bundleGroup","_chainKeys$1","RenderBundles","NodeLibrary","materialNodes","toneMappingNodes","nodeMaterialClass","getMaterialNodeClass","addToneMapping","toneMappingNode","addType","materialType","addMaterial","materialNodeClass","materialClassType","addLight","lightClass","addClass","nodeClass","baseClass","_defaultLights","_chainKeys","Lighting","XRRenderTarget","hasExternalTextures","autoAllocateDepthBuffer","_cameraLPos","_cameraRPos","XRManager","isPresenting","cameraAutoUpdate","_cameraL","_cameraR","_cameras","_cameraXR","HkE","_currentDepthNear","_currentDepthFar","_controllers","_controllerInputSources","_currentRenderTarget","_xrRenderTarget","_currentAnimationContext","_currentAnimationLoop","_currentPixelRatio","_currentSize","_onSessionEvent","onSessionEvent","_onSessionEnd","onSessionEnd","_onInputSourcesChange","onInputSourcesChange","_onAnimationFrame","onAnimationFrame","_referenceSpace","_referenceSpaceType","_customReferenceSpace","_framebufferScaleFactor","_foveation","_session","_glBaseLayer","_glBinding","_glProjLayer","_xrFrame","_useLayers","XRWebGLBinding","getController","controller","_getController","getTargetRaySpace","getControllerGrip","getGripSpace","getHand","getHandSpace","getFoveation","setFoveation","foveation","fixedFoveation","getFramebufferScaleFactor","setFramebufferScaleFactor","getReferenceSpaceType","setReferenceSpaceType","getReferenceSpace","setReferenceSpace","space","getCamera","getFrame","getSession","setSession","session","makeXRCompatible","_animation","depthFormat","depthType","glDepthFormat","DEPTH24_STENCIL8","DEPTH_COMPONENT24","projectionlayerInit","colorFormat","RGBA8","scaleFactor","glBinding","glProjLayer","createProjectionLayer","updateRenderState","textureWidth","textureHeight","glBaseLayer","XRWebGLLayer","antialias","framebufferScaleFactor","baseLayer","framebufferWidth","framebufferHeight","requestReferenceSpace","updateCamera","depthNear","depthFar","cameraXR","cameraL","cameraR","setProjectionFromUnion","ipd","distanceTo","projL","projR","topFov","bottomFov","leftFov","rightFov","zOffset","xOffset","decompose","quaternion","translateX","translateZ","compose","near2","far2","makePerspective","left","right","fov","I3e","zoom","NiX","controllerIndex","inputSource","referenceSpace","disconnect","setXRTarget","controllers","controllerInputSources","removed","added","connect","pose","getViewerPose","views","framebuffer","cameraXRNeedsUpdate","view","glSubImage","getViewSubImage","setXRRenderTargetTextures","colorTexture","ignoreDepthValues","depthStencilTexture","enable","transform","detectedPlanes","_scene","_drawingBufferSize","_screen","_frustum","iWj","_projScreenMatrix","_vector4","Renderer","isRenderer","getFallback","colorBufferType","domElement","getDomElement","KI_","sortObjects","_getFallback","_scissor","_scissorTest","_attributes","_objects","_pipelines","_bundles","_renderLists","_renderContexts","_background","_quad","_currentRenderContext","_opaqueSort","_transparentSort","_frameBufferTarget","alphaClear","_renderTarget","_activeCubeFace","_activeMipmapLevel","_renderObjectFunction","_currentRenderObjectFunction","_currentRenderBundle","_handleObjectFunction","_renderObjectDirect","_isDeviceLost","onDeviceLost","_onDeviceLost","_colorBufferType","_initialized","_initPromise","_compilationPromises","_iA","debug","checkShaderErrors","onShaderError","getShaderAsync","compileAsync","Promise","resolve","reject","targetScene","previousRenderId","previousRenderContext","previousRenderObjectFunction","previousCompilationPromises","sceneRef","isScene","compilationPromises","_createObjectPipeline","_projectObject","traverseVisible","isLight","opaqueObjects","transparentObjects","transparentDoublePassObjects","_renderObjects","_renderTransparents","_renderScene","waitForGPU","errorMessage","api","message","reason","_renderBundle","renderBundle","renderBundleData","renderContexts","renderBundleNeedsUpdate","beginBundle","finishBundle","addBundle","_getFrameBufferTarget","currentToneMapping","useToneMapping","useColorSpace","frameBufferTarget","isPostProcessingRenderTarget","useFrameBufferTarget","outputRenderTarget","matrixWorldAutoUpdate","minDepth","maxDepth","setFromProjectionMatrix","beginRender","_renderBundles","finishRender","quad","onAfterRender","getMaxAnisotropy","getArrayBufferAsync","setDrawingBufferSize","setViewport","updateSize","updateStyle","style","setOpaqueSort","setTransparentSort","getScissor","setScissor","boolean","setClearAlpha","getClearDepth","setClearDepth","getClearStencil","setClearStencil","isOccluded","clearAsync","clearColorAsync","clearDepthAsync","clearStencilAsync","timestampQueryPool","forEach","queryPool","computeNodes","computeAsync","computeList","beginCompute","onInitFn","computeBindings","computePipeline","finishCompute","hasFeatureAsync","hasFeature","resolveTimestampsAsync","initTextureAsync","initTexture","rectangle","copyTextureToTexture","srcTexture","dstTexture","srcRegion","dstPosition","readRenderTargetPixelsAsync","textureIndex","copyTextureToBuffer","isGroup","isClippingGroup","isLOD","intersectsSprite","intersectsObject","boundingSphere","computeBoundingSphere","groupMaterial","materialIndex","isBundleGroup","baseRenderList","children","doublePassList","Wl3","overridePositionNode","overrideColorNode","overrideDepthNode","shadowSide","draw","Binding","visibility","setVisibility","Buffer","isBuffer","bytesPerElement","BYTES_PER_ELEMENT","_buffer","byteLength","floatLength","GPU_CHUNK_BYTES","UniformBuffer","_id$4","NodeUniformBuffer","UniformsGroup","isUniformsGroup","_values","addUniform","removeUniform","splice","chunkOffset","remainingSizeInChunk","updateByType","updateNumber","updateVector2","updateVector3","updateVector4","updateColor","updateMatrix3","updateMatrix4","_getBufferForType","e","arraysEqual","setArray","_id$3","NodeUniformsGroup","_id$2","SampledTexture","isVideoTexture","NodeSampledTexture","NodeSampledCubeTexture","isSampledCubeTexture","NodeSampledTexture3D","isSampledTexture3D","glslMethods","textureDimensions","precisionLib","medium","supports$1","swizzleAssign","storageBuffer","defaultPrecisions","GLSLNodeBuilder","uniformGroups","extensions","builtins","pbo","originalArray","numElements","D9w","hEm","CtA","F5G","UCm","E2K","typeMap","LsT","T95","iAb","Uint8ClampedArray","newSize","newArray","pboTexture","IEO","isPBOTexture","pboNode","storageArrayElementNode","elementNodeData","bufferNodeData","propertySizeName","uvIndexSnippet","bindingSnippets","typePrefix","isDataArrayTexture","isCompressedArrayTexture","bufferCountSnippet","groupSnippets","_getGLSLUniformStruct","gpuType","location","getStructMembers","getStructs","outputSnippet","flat","acc","curr","enableExtension","behavior","getExtensions","ext","extensionName","planeCount","varyingName","attributeNode","getTransforms","_getGLSLVertexCode","shaderData","_getGLSLFragmentCode","shadersData","mainNode","flowSlotData","slotName","stageData","uniformGPU","uniformsStage","uniformsGroup","_vector2","_color4","Backend","destroyProgram","updateViewport","trackTimestamp","O4K","duration","resolveQueriesAsync","canvas","O5A","_id$1","DualAttributeData","dualBuffer","buffers","bufferGPU","activeBufferIndex","baseId","transformBuffer","switchBuffers","WebGLAttributeUtils","STATIC_DRAW","_createBuffer","isFloat16BufferAttribute","HALF_FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","updateRanges","bindBuffer","bufferSubData","clearUpdateRanges","deleteBuffer","COPY_READ_BUFFER","writeBuffer","createBuffer","COPY_WRITE_BUFFER","STREAM_READ","copyBufferSubData","utils","_clientWaitAsync","dstBuffer","getBufferSubData","WebGLState","currentFlipSided","currentCullFace","currentProgram","currentBlendingEnabled","currentBlending","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentColorMask","currentDepthFunc","currentDepthMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilMask","currentLineWidth","currentClippingPlanes","currentBoundFramebuffers","currentDrawbuffers","maxTextures","MAX_TEXTURE_IMAGE_UNITS","currentTextureSlot","currentBoundTextures","currentBoundBufferBases","bGH","FUNC_ADD","Wbm","FUNC_SUBTRACT","rOj","FUNC_REVERSE_SUBTRACT","c8b","ZERO","ghN","ONE","KhW","SRC_COLOR","k74","SRC_ALPHA","RlZ","SRC_ALPHA_SATURATE","Vdb","DST_COLOR","fSK","DST_ALPHA","iWC","ONE_MINUS_SRC_COLOR","LgZ","ONE_MINUS_SRC_ALPHA","Wpd","ONE_MINUS_DST_COLOR","Hy8","ONE_MINUS_DST_ALPHA","scissorParam","SCISSOR_BOX","viewportParam","currentScissor","currentViewport","_tempVec4","disable","setFlipSided","flipSided","frontFace","CW","CCW","setCullFace","cullFace","PeU","CULL_FACE","tm_","BACK","S2y","FRONT","FRONT_AND_BACK","setLineWidth","lineWidth","setBlending","blendEquation","blendSrc","blendDst","blendEquationAlpha","blendSrcAlpha","blendDstAlpha","premultipliedAlpha","BLEND","Xaj","currentBlendEquation","currentBlendEquationAlpha","blendFuncSeparate","WMw","blendFunc","N4l","M5h","blendEquationSeparate","setColorMask","colorMask","setDepthTest","DEPTH_TEST","setDepthMask","depthMask","setDepthFunc","depthFunc","BVF","NEVER","Se2","ALWAYS","Zr5","LESS","vCF","LEQUAL","eD","EQUAL","ksN","GEQUAL","w$m","GREATER","M6v","NOTEQUAL","SCISSOR_TEST","setStencilTest","stencilTest","STENCIL_TEST","setStencilMask","stencilMask","setStencilFunc","stencilFunc","stencilRef","setStencilOp","stencilFail","stencilZFail","stencilZPass","stencilOp","setMaterial","frontFaceCW","colorWrite","stencilWrite","stencilWriteMask","stencilFuncMask","setPolygonOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","SAMPLE_ALPHA_TO_COVERAGE","CLIP_DISTANCE0_WEBGL","units","POLYGON_OFFSET_FILL","useProgram","bindFramebuffer","DRAW_FRAMEBUFFER","FRAMEBUFFER","drawBuffers","COLOR_ATTACHMENT0","activeTexture","webglSlot","TEXTURE0","bindTexture","webglType","webglTexture","boundTexture","bindBufferBase","unbindTexture","WebGLUtils","extension","k0A","UNSIGNED_SHORT_4_4_4_4","irR","UNSIGNED_SHORT_5_5_5_1","tQZ","UNSIGNED_INT_5_9_9_9_REV","OTo","ALPHA","RGB","RGBA","Y8D","LUMINANCE","cRx","LUMINANCE_ALPHA","DEPTH_COMPONENT","DEPTH_STENCIL","RED","RED_INTEGER","RG","RG_INTEGER","RGBA_INTEGER","wuA","BFQ","v3W","ILR","COMPRESSED_SRGB_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","_AM","vCx","eaV","CaW","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","fto","l0P","ekQ","COMPRESSED_SRGB8_ETC2","COMPRESSED_RGB8_ETC2","COMPRESSED_SRGB8_ALPHA8_ETC2_EAC","COMPRESSED_RGBA8_ETC2_EAC","ptH","jZA","y2t","gi4","Djp","BG$","NYV","xJs","pKu","GG6","Gih","FUD","iiP","SvJ","COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR","COMPRESSED_RGBA_ASTC_4x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR","COMPRESSED_RGBA_ASTC_5x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR","COMPRESSED_RGBA_ASTC_5x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR","COMPRESSED_RGBA_ASTC_6x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR","COMPRESSED_RGBA_ASTC_6x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR","COMPRESSED_RGBA_ASTC_8x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR","COMPRESSED_RGBA_ASTC_8x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR","COMPRESSED_RGBA_ASTC_8x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR","COMPRESSED_RGBA_ASTC_10x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR","COMPRESSED_RGBA_ASTC_10x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR","COMPRESSED_RGBA_ASTC_10x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR","COMPRESSED_RGBA_ASTC_10x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR","COMPRESSED_RGBA_ASTC_12x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR","COMPRESSED_RGBA_ASTC_12x12_KHR","bsb","COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT","COMPRESSED_RGBA_BPTC_UNORM_EXT","HdW","vuL","ZTh","lGU","COMPRESSED_RED_RGTC1_EXT","COMPRESSED_SIGNED_RED_RGTC1_EXT","COMPRESSED_RED_GREEN_RGTC2_EXT","COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT","UNSIGNED_INT_24_8","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","res","clientWaitSync","SYNC_FLUSH_COMMANDS_BIT","WAIT_FAILED","deleteSync","TIMEOUT_EXPIRED","wrappingToGL","filterToGL","compareToGL","WebGLTextureUtils","defaultTextures","rpg","REPEAT","uWy","CLAMP_TO_EDGE","OoA","MIRRORED_REPEAT","TyD","NEAREST","YLQ","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","xoQ","T6w","M$G","F1y","Jjb","Zen","O78","getGLTextureType","TEXTURE_CUBE_MAP","TEXTURE_2D_ARRAY","isData3DTexture","TEXTURE_3D","TEXTURE_2D","getInternalFormat","internalFormatName","glFormat","glType","forceLinearTransfer","internalFormat","R32F","R16F","R8","R16","R32UI","R8I","R16I","R32I","R8UI","R16UI","RG32F","RG16F","RG8","RG16","RG32UI","RG8I","RG16I","RG32I","RG8UI","RG16UI","RGB32F","RGB16F","RGB8","RGB16","RGB32UI","RGB8I","RGB16I","RGB32I","SRGB8","UNSIGNED_SHORT_5_6_5","RGB565","RGB5_A1","RGB4","RGB9_E5","RGB_INTEGER","RGB8UI","RGB16UI","RGBA32F","RGBA16F","RGBA16","RGBA32UI","RGBA8I","RGBA16I","RGBA32I","SRGB8_ALPHA8","RGBA4","RGBA8UI","RGBA16UI","DEPTH_COMPONENT16","DEPTH_COMPONENT32F","setTextureParameters","textureType","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultiplyAlpha","UNPACK_ALIGNMENT","unpackAlignment","UNPACK_COLORSPACE_CONVERSION_WEBGL","texParameteri","TEXTURE_WRAP_S","wrapS","TEXTURE_WRAP_T","wrapT","TEXTURE_WRAP_R","wrapR","TEXTURE_MAG_FILTER","hasMipmaps","TEXTURE_MIN_FILTER","TEXTURE_COMPARE_MODE","COMPARE_REF_TO_TEXTURE","TEXTURE_COMPARE_FUNC","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","glTextureType","textureGPU","isDefault","glInternalFormat","texStorage3D","texStorage2D","copyBufferToTexture","PIXEL_UNPACK_BUFFER","texSubImage2D","getImage","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","mipmap","compressedTexSubImage3D","texSubImage3D","compressedTexSubImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","texImage2D","generateMipmap","deallocateRenderBuffers","renderContextData","renderBufferStorageSetup","framebuffers","deleteFramebuffer","depthRenderbuffer","deleteRenderbuffer","stencilRenderbuffer","msaaFrameBuffer","msaaRenderbuffers","deleteTexture","minX","minY","dstX","dstY","dstTextureGPU","currentUnpackRowLen","UNPACK_ROW_LENGTH","currentUnpackImageHeight","UNPACK_IMAGE_HEIGHT","currentUnpackSkipPixels","UNPACK_SKIP_PIXELS","currentUnpackSkipRows","UNPACK_SKIP_ROWS","currentUnpackSkipImages","UNPACK_SKIP_IMAGES","srcTextureData","dstTextureData","srcRenderContextData","dstRenderContextData","srcFramebuffer","dstFramebuffer","READ_FRAMEBUFFER","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","blitFramebuffer","requireDrawFrameBuffer","srcHeight","attachment","partial","DEPTH_ATTACHMENT","STENCIL_BUFFER_BIT","renderTargetContextData","fb","flippedY","copyTexSubImage2D","createFramebuffer","framebufferTexture2D","_setFramebuffer","setupRenderBufferStorage","renderbuffer","useMultisampledRTT","bindRenderbuffer","RENDERBUFFER","multisampledRTTExt","renderbufferStorageMultisampleEXT","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","typedArrayType","_getTypedArrayType","elementCount","_getBytesPerTexel","PIXEL_PACK_BUFFER","readPixels","bytesPerComponent","WebGLExtensions","availableExtensions","getSupportedExtensions","getExtension","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","GLFeatureName","WebGLBufferRenderer","mode","drawElements","drawArrays","renderInstances","primcount","drawElementsInstanced","drawArraysInstanced","renderMultiDraw","starts","counts","drawCount","multiDrawElementsWEBGL","multiDrawArraysWEBGL","renderMultiDrawInstances","multiDrawElementsInstancedWEBGL","multiDrawArraysInstancedWEBGL","TimestampQueryPool","maxQueries","currentQueryIndex","queryOffsets","isDisposed","lastValue","pendingResolve","allocateQueriesForContext","WebGLTimestampQueryPool","queries","createQuery","activeQuery","queryStates","toUpperCase","baseOffset","beginQuery","query","TIME_ELAPSED_EXT","endQuery","resolvePromises","resolveQuery","totalDuration","results","timeoutId","isResolved","cleanup","clearTimeout","finalizeResolution","checkQuery","GPU_DISJOINT_EXT","getQueryParameter","QUERY_RESULT_AVAILABLE","setTimeout","elapsed","QUERY_RESULT","deleteQuery","WebGLBackend","attributeUtils","capabilities","textureUtils","bufferRenderer","vaoCache","transformFeedbackCache","disjoint","parallel","_currentContext","_knownBindings","WeakSet","_xrFamebuffer","glContext","onContextLost","preventDefault","contextLossInfo","statusMessage","originalEvent","_onContextLost","getContextAttributes","xrCompatible","xrFamebuffer","initTimestampQuery","prepareTimestampBuffer","drawingBufferWidth","drawingBufferHeight","currentOcclusionQueries","occlusionQueries","currentOcclusionQueryObjects","occlusionQueryObjects","lastOcclusionObject","occlusionQueryIndex","ANY_SAMPLES_PASSED","resolveOccludedAsync","_useMultisampledRTT","viewY","invalidateSubFramebuffer","invalidationArray","invalidateFramebuffer","occluded","check","completed","setFrameBuffer","clearBufferfv","clearBufferfi","clearBufferiv","STENCIL","computeGroup","RASTERIZER_DISCARD","programGPU","transformBuffers","vaoKey","_getVaoKey","vaoGPU","_createVao","bindVertexArray","_bindUniforms","transformFeedbackGPU","_getTransformFeedback","bindTransformFeedback","TRANSFORM_FEEDBACK","beginTransformFeedback","POINTS","endTransformFeedback","dualAttributeData","contextData","determinant","staticVao","geometryId","lastObject","LINES","LINE_STRIP","LINE_LOOP","wireframeLinewidth","TRIANGLES","indexData","_multiDrawInstances","_multiDrawStarts","_multiDrawCounts","_multiDrawCount","indexesGPU","UNIFORM_BUFFER","cameraIndexData","shader","createShader","FRAGMENT_SHADER","VERTEX_SHADER","shaderSource","compileShader","shaderGPU","attachShader","linkProgram","checkStatus","getProgramParameter","COMPLETION_STATUS_KHR","_completeCompile","_handleSource","errorLine","lines2","to","line","_getShaderErrors","status","getShaderParameter","COMPILE_STATUS","errors","getShaderInfoLog","errorMatches","getShaderSource","_logProgramError","glFragmentShader","glVertexShader","programLog","getProgramInfoLog","LINK_STATUS","vertexErrors","fragmentErrors","getError","VALIDATE_STATUS","_setupBindings","transformVaryingNames","transformAttributeNodes","transformFeedbackVaryings","SEPARATE_ATTRIBS","attributeNodes","ARRAY_BUFFER","uniformBuffers","bindGroupData","DYNAMIC_DRAW","bindingData","ELEMENT_ARRAY_BUFFER","keysMatching","filter","currentFrameBuffer","isCube","isWebGLCubeRenderTarget","isRenderTarget3D","isRenderTargetArray","msaaFb","cubeFramebuffers","cubeFace","layer","framebufferTextureLayer","framebufferTexture2DMultisampleEXT","createRenderbuffer","xrDepthRenderbuffer","depthStyle","createVertexArray","enableVertexAttribArray","vertexAttribIPointer","vertexAttribPointer","vertexAttribDivisor","meshPerAttribute","isInstancedInterleavedBuffer","createTransformFeedback","TRANSFORM_FEEDBACK_BUFFER","getUniformBlockIndex","uniformBlockBinding","getUniformLocation","uniform1i","loseContext","GPUPrimitiveTopology","PointList","LineList","LineStrip","TriangleList","TriangleStrip","GPUCompareFunction","Never","Less","Equal","LessEqual","Greater","NotEqual","GreaterEqual","Always","GPUStoreOp","Store","GPULoadOp","Load","Clear","GPUFrontFace","GPUCullMode","None","Front","Back","GPUIndexFormat","Uint16","Uint32","GPUTextureFormat","R8Unorm","R8Snorm","R8Uint","R8Sint","R16Uint","R16Sint","R16Float","RG8Unorm","RG8Snorm","RG8Uint","RG8Sint","R32Uint","R32Sint","R32Float","RG16Uint","RG16Sint","RG16Float","RGBA8Unorm","RGBA8UnormSRGB","RGBA8Snorm","RGBA8Uint","RGBA8Sint","BGRA8Unorm","BGRA8UnormSRGB","RGB9E5UFloat","RGB10A2Unorm","RG11B10uFloat","RG32Uint","RG32Sint","RG32Float","RGBA16Uint","RGBA16Sint","RGBA16Float","RGBA32Uint","RGBA32Sint","RGBA32Float","Stencil8","Depth16Unorm","Depth24Plus","Depth24PlusStencil8","Depth32Float","Depth32FloatStencil8","BC1RGBAUnorm","BC1RGBAUnormSRGB","BC2RGBAUnorm","BC2RGBAUnormSRGB","BC3RGBAUnorm","BC3RGBAUnormSRGB","BC4RUnorm","BC4RSnorm","BC5RGUnorm","BC5RGSnorm","BC6HRGBUFloat","BC6HRGBFloat","BC7RGBAUnorm","BC7RGBAUnormSRGB","ETC2RGB8Unorm","ETC2RGB8UnormSRGB","ETC2RGB8A1Unorm","ETC2RGB8A1UnormSRGB","ETC2RGBA8Unorm","ETC2RGBA8UnormSRGB","EACR11Unorm","EACR11Snorm","EACRG11Unorm","EACRG11Snorm","ASTC4x4Unorm","ASTC4x4UnormSRGB","ASTC5x4Unorm","ASTC5x4UnormSRGB","ASTC5x5Unorm","ASTC5x5UnormSRGB","ASTC6x5Unorm","ASTC6x5UnormSRGB","ASTC6x6Unorm","ASTC6x6UnormSRGB","ASTC8x5Unorm","ASTC8x5UnormSRGB","ASTC8x6Unorm","ASTC8x6UnormSRGB","ASTC8x8Unorm","ASTC8x8UnormSRGB","ASTC10x5Unorm","ASTC10x5UnormSRGB","ASTC10x6Unorm","ASTC10x6UnormSRGB","ASTC10x8Unorm","ASTC10x8UnormSRGB","ASTC10x10Unorm","ASTC10x10UnormSRGB","ASTC12x10Unorm","ASTC12x10UnormSRGB","ASTC12x12Unorm","ASTC12x12UnormSRGB","GPUAddressMode","ClampToEdge","Repeat","MirrorRepeat","GPUFilterMode","Linear","Nearest","GPUBlendFactor","Zero","One","Src","OneMinusSrc","SrcAlpha","OneMinusSrcAlpha","Dst","OneMinusDstColor","DstAlpha","OneMinusDstAlpha","SrcAlphaSaturated","Constant","OneMinusConstant","GPUBlendOperation","Add","Subtract","ReverseSubtract","Min","Max","GPUColorWriteFlags","All","GPUStencilOperation","Keep","Replace","Invert","IncrementClamp","DecrementClamp","IncrementWrap","DecrementWrap","GPUBufferBindingType","Storage","ReadOnlyStorage","GPUStorageTextureAccess","WriteOnly","ReadOnly","ReadWrite","GPUTextureSampleType","Float","UnfilterableFloat","Depth","SInt","UInt","GPUTextureDimension","TwoD","ThreeD","GPUTextureViewDimension","TwoDArray","Cube","GPUTextureAspect","GPUInputStepMode","Vertex","Instance","GPUFeatureName","DepthClipControl","TextureCompressionBC","TextureCompressionETC2","TextureCompressionASTC","TimestampQuery","IndirectFirstInstance","ShaderF16","RG11B10UFloat","BGRA8UNormStorage","Float32Filterable","ClipDistances","DualSourceBlending","Subgroups","Sampler","NodeSampler","StorageBuffer","_id","NodeStorageBuffer","WebGPUTexturePassUtils","device","mipmapVertexSource","mipmapFragmentSource","flipYFragmentSource","mipmapSampler","flipYSampler","transferPipelines","flipYPipelines","mipmapVertexShaderModule","createShaderModule","mipmapFragmentShaderModule","flipYFragmentShaderModule","getTransferPipeline","module","entryPoint","primitive","topology","stripIndexFormat","getFlipYPipeline","textureGPUDescriptor","baseArrayLayer","transferPipeline","flipYPipeline","tempTexture","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","srcView","createView","baseMipLevel","mipLevelCount","dimension","dstView","commandEncoder","createCommandEncoder","sourceView","destinationView","bindGroupLayout","getBindGroupLayout","createBindGroup","resource","passEncoder","beginRenderPass","colorAttachments","loadOp","storeOp","clearValue","setPipeline","setBindGroup","queue","submit","destroy","useCount","passes","_mipmapCreateBundles","_mipmapRunBundles","passDescriptor","createRenderBundleEncoder","colorFormats","renderBundles","executeBundles","_compareToWebGPU","_flipMap","WebGPUTextureUtils","_passUtils","defaultCubeTexture","defaultVideoFrame","colorBuffer","samplerDescriptorGPU","addressModeU","_convertAddressMode","addressModeV","addressModeW","_convertFilterMode","mipmapFilter","getFormat","_getDefaultCubeTextureGPU","_getDefaultVideoFrame","_getDefaultTextureGPU","getCurrentColorFormat","getPreferredCanvasFormat","_getDimension","primarySamples","isMSAA","getTextureSampleData","COPY_DST","COPY_SRC","STORAGE_BINDING","textureDescriptorGPU","video","videoFrame","VideoFrame","displayWidth","displayHeight","close","msaaTextureDescriptorGPU","msaaTexture","_generateMipmaps","getColorBuffer","getSampleCount","getDepthBuffer","depthTextureGPU","_copyBufferToTexture","_copyCompressedBufferToTexture","_copyCubeMapToTexture","_copyImageToTexture","bytesPerTexel","bytesPerRow","readBuffer","GPUBufferUsage","MAP_READ","encoder","origin","mapAsync","GPUMapMode","READ","getMappedRange","_isEnvironmentTexture","codedWidth","codedHeight","flipIndex","originDepth","copyExternalImageToTexture","mipLevel","_getPassUtils","passUtils","_flipY","writeTexture","blockData","_getBlockData","isTextureArray","bytesPerImage","rowsPerImage","BC4RSNorm","addressMode","filterMode","formatGPU","features","declarationRegexp","propertiesRegexp","wgslTypeLib$1","parse","resolvedType","WGSLNodeFunction","WGSLNodeParser","GPUShaderStage","COMPUTE","accessNames","wrapNames","gpuShaderStageLib","supports","wgslFnOpLib","wgslTypeLib","wgslCodeCache","wgslPolyfill","tsl_xor","mod_float","mod_vec2","mod_vec3","mod_vec4","equals_bool","equals_bvec2","equals_bvec3","equals_bvec4","repeatWrapping_float","mirrorWrapping_float","clampWrapping_float","biquadraticTexture","wgslMethods","navigator","userAgent","pow_float","pow_vec2","pow_vec3","pow_vec4","diagnostics","WGSLNodeBuilder","directives","scopedArrays","_generateTextureSample","generateFilteredTexture","_generateVideoSample","_generateTextureSampleLevel","isUnfilterable","generateWrapFunction","coordType","addWrapSnippet","wrap","generateTextureDimension","dimensionsSnippet","textureDimensionNode","textureDimensionsParams","dimensionType","isMultisampled","arrayLayerCount","isTextureCube","cubeFaceCount","_include","wrapFunction","textureDimension","coordSnippet","valueSnippet","isSampleCompare","isCustomStruct","_getUniformGroupCount","fnOp","getNodeAccess","getStorageAccess","getBuiltin","getSubgroupSize","enableSubGroups","enableDirective","getDirectives","directive","enableSubgroupsF16","enableClipDistances","enableShaderF16","enableDualSourceBlending","getBuiltins","getScopedArrays","attributesSnippet","_getWGSLStruct","bufferSnippets","structSnippets","uniformIndexes","multisampled","componentPrefix","bufferAccessMode","bufferTypeSnippet","bufferSnippet","_getWGSLStructBinding","isOutputStruct","returnType","structSnippet","_getWGSLVertexCode","_getWGSLFragmentCode","_getWGSLComputeCode","wgslMethod","_getWGSLMethod","structName","WebGPUUtils","getCurrentDepthStencilFormat","getTextureFormatGPU","getCurrentColorSpace","getPrimitiveTopology","getSampleCountRenderContext","gpu","typedArraysToVertexFormatPrefix","typedAttributeToVertexFormatPrefix","typeArraysToVertexFormatPrefixForItemSize1","WebGPUAttributeUtils","subarray","mappedAtCreation","unmap","isTypedArray","_isTypedArray","byteOffsetFactor","dataOffset","createShaderVertexBuffers","slot","vertexBufferLayout","arrayStride","stepMode","_getVertexFormat","shaderLocation","readBufferGPU","cmdEncoder","copyBufferToBuffer","gpuCommands","ArrayType","prefixOptions","paddedItemSize","paddedBytesPerUnit","bytesPerUnit","DataView","WebGPUBindingUtils","bindGroupLayoutCache","createBindingsLayout","bindingGPU","sampleType","viewDimension","createBindGroupLayout","bindGroupGPU","bindingsData","bindLayoutGPU","versions","createBindGroupIndex","UNIFORM","layoutGPU","bindingPoint","entriesGPU","resourceGPU","importExternalTexture","dimensionViewGPU","aspectGPU","WebGPUPipelineUtils","_getSampleCount","pipelineData","bindGroupLayouts","_getBlending","stencilFront","_getStencilCompare","failOp","_getStencilOperation","depthFailOp","passOp","colorWriteMask","_getColorWriteMask","writeMask","vertexModule","fragmentModule","primitiveState","_getPrimitiveState","_getDepthCompare","depthStencilFormat","pipelineDescriptor","multisample","alphaToCoverageEnabled","createPipelineLayout","depthStencil","renderDepth","renderStencil","depthWriteEnabled","stencilBack","stencilReadMask","createRenderPipelineAsync","then","createBundleEncoder","pipelineGPU","srcFactor","_getBlendFactor","dstFactor","operation","_getBlendOperation","setBlend","srcRGB","dstRGB","srcAlpha","dstAlpha","blendFactor","stencilCompare","MyG","cum","uXU","yt0","jwo","j4z","OAl","RvT","stencilOperation","x5V","ad5","ce8","eMJ","ZRs","jfJ","oqc","T_J","blendOperation","r_","Sm8","cullMode","WebGPUTimestampQueryPool","querySet","createQuerySet","bufferSize","resolveBuffer","QUERY_RESOLVE","resultBuffer","_resolveQueries","mapState","currentOffsets","queryCount","bytesUsed","resolveQuerySet","commandBuffer","times","BigUint64Array","startTime","endTime","WebGPUBackend","requiredLimits","defaultRenderPassdescriptor","bindingUtils","pipelineUtils","occludedResolveCache","adapterOptions","powerPreference","adapter","requestAdapter","supportedFeatures","deviceDescriptor","requiredFeatures","requestDevice","lost","deviceLossInfo","alphaMode","configure","_getDefaultRenderPassDescriptor","depthStencilAttachment","colorAttachment","resolveTarget","getCurrentTexture","_getRenderPassDescriptor","colorAttachmentsConfig","dimensions","sliceIndex","viewDescriptor","textureView","depthSlice","depthTextureData","occlusionQuerySet","currentOcclusionQuerySet","currentOcclusionQueryBuffer","occlusionQueryBuffer","depthLoadOp","depthStoreOp","stencilLoadOp","stencilStoreOp","currentPass","currentSets","bindingGroups","setScissorRect","endOcclusionQuery","queryResolveBuffer","BigInt","renderTargetContext","supportsDepth","supportsStencil","groupGPU","cmdEncoderGPU","passEncoderGPU","beginComputePass","maxComputeWorkgroupsPerDimension","limits","computeNodeData","dispatchSize","dispatchWorkgroups","onSubmittedWorkDone","currentBindingGroups","hasIndex","indexFormat","setIndexBuffer","vertexBuffer","setVertexBuffer","beginOcclusionQuery","drawInstances","drawIndexed","indexCount","firstIndex","drawIndexedIndirect","drawIndirect","bindGroupIndex","primitiveTopology","materialVersion","timestampWrites","beginningOfPassWriteIndex","endOfPassWriteIndex","_currentPass","_currentSets","bundleGPU","bundleEncoder","dstLayer","srcX","srcY","srcLayer","srcWidth","sourceGPU","destinationGPU","IESSpotLight","PMe","recursive","StandardNodeLibrary","cek","Ox3","T_f","Mig","vmT","lk7","EoG","CdI","YGz","LY2","Bgp","ORg","WebGPURenderer","BackendClass","forceWebGL","isWebGPURenderer"],"sourceRoot":""}